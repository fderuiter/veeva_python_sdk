// tslint:disable
/**
 * Veeva Vault API v25.1
 * The latest GA version of the Vault REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    VobjectsObjectNameActionsMergePostRequestInner,
    VobjectsObjectNameActionsMergePostRequestInnerFromJSON,
    VobjectsObjectNameActionsMergePostRequestInnerToJSON,
} from '../models';

export interface ApiGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest {
    componentTypeAndRecordName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ApiMdlComponentsComponentTypeAndRecordNameGetRequest {
    componentTypeAndRecordName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ApiMdlExecuteAsyncJobIdResultsGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ApiMdlExecuteAsyncPostRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ApiMdlExecutePostRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ApiMdlFilesPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface AudittrailAuditTrailTypeGetRequest {
    auditTrailType: string;
    startDate?: string;
    endDate?: string;
    allDates?: string;
    formatResult?: string;
    limit?: string;
    offset?: string;
    objects?: string;
    events?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface AuthDiscoveryPostRequest {
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface AuthOauthSessionOathOidcProfileIdPostRequest {
    oathOidcProfileId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface AuthPostRequest {
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CodeClassNameDeleteRequest {
    className: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CodeClassNameDisablePutRequest {
    className: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface CodeClassNameEnablePutRequest {
    className: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface CodeClassNameGetRequest {
    className: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CodeProfilerGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CodeProfilerPostRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CodeProfilerSessionNameActionsEndPostRequest {
    sessionName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CodeProfilerSessionNameDeleteRequest {
    sessionName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CodeProfilerSessionNameGetRequest {
    sessionName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CodeProfilerSessionNameResultsGetRequest {
    sessionName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CodePutRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest {
    edlHierarchyOrTemplate: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CompositesTreesEdlHierarchyOrTemplateGetRequest {
    edlHierarchyOrTemplate: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest {
    parentNodeId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface CompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest {
    parentNodeId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ConfigurationComponentTypeAndRecordNameGetRequest {
    componentTypeAndRecordName: string;
    loc?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ConfigurationComponentTypeGetRequest {
    componentType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ConfigurationObjectNameAndObjectTypeGetRequest {
    objectNameAndObjectType: string;
    loc?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ConfigurationObjecttypeGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ConfigurationRoleAssignmentRuleDeleteRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ConfigurationRoleAssignmentRuleGetRequest {
    lifecycleV?: string;
    roleV?: string;
    productV?: string;
    countryV?: string;
    studyV?: string;
    studyCountryV?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ConfigurationRoleAssignmentRulePostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ConfigurationRoleAssignmentRulePutRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface DelegationLoginPostRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface DelegationVaultsGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface KeepAlivePostRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface LimitsGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface LogsApiUsageGetRequest {
    date?: string;
    logFormat?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface LogsCodeDebugGetRequest {
    userId?: string;
    includeInactive?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface LogsCodeDebugIdActionsResetDeleteRequest {
    id: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface LogsCodeDebugIdActionsResetPostRequest {
    id: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface LogsCodeDebugIdFilesGetRequest {
    id: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface LogsCodeDebugIdGetRequest {
    id: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface LogsCodeDebugPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface LogsCodeRuntimeGetRequest {
    date?: string;
    logFormat?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MessagesMessageTypeActionsImportPostRequest {
    messageType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MessagesMessageTypeLanguageLangActionsExportPostRequest {
    messageType: string;
    lang: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataAudittrailAuditTrailTypeGetRequest {
    auditTrailType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataAudittrailGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataComponentsComponentTypeGetRequest {
    componentType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataComponentsGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsBindersTemplatesBindernodesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsBindersTemplatesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest {
    placemarkType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest {
    referenceType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest {
    annotationType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest {
    eventType: string;
    eventSubtype: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsEventsGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsLockGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsPropertiesFindCommonPostRequest {
    contentType?: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsPropertiesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsTemplatesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsTypesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsTypesTypeGetRequest {
    type: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsTypesTypeRelationshipsGetRequest {
    type: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest {
    type: string;
    subtype: string;
    classification: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest {
    type: string;
    subtype: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsGroupsGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsSecuritypoliciesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataObjectsUsersGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataVobjectsGetRequest {
    loc?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataVobjectsObjectNameActionsCanceldeploymentPostRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest {
    objectName: string;
    objectFieldName: string;
    loc?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataVobjectsObjectNameGetRequest {
    objectName: string;
    loc?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataVobjectsObjectNamePageLayoutsGetRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface MetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest {
    objectName: string;
    layoutName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface NotificationsHistoriesGetRequest {
    startDate?: string;
    endDate?: string;
    allDates?: boolean;
    formatResult?: string;
    limit?: string;
    offset?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectWorkflowActionsActionGetRequest {
    action: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectWorkflowActionsActionPostRequest {
    action: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectWorkflowActionsCanceltasksPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectWorkflowActionsCancelworkflowsPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectWorkflowActionsGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectWorkflowActionsReassigntasksPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectWorkflowActionsReplaceworkflowownerPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersActionsExportJobIdResultsGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdActionsExportPostRequest {
    binderId: string;
    source?: boolean;
    renditiontype?: string;
    docversion?: string;
    attachments?: string;
    _export?: string;
    docfield?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdActionsPostRequest {
    binderId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdBindingRulePutRequest {
    binderId: string;
    contentType?: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdDeleteRequest {
    binderId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest {
    binderId: string;
    nodeId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdDocumentsPostRequest {
    binderId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdDocumentsSectionIdDeleteRequest {
    binderId: string;
    sectionId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdDocumentsSectionIdPutRequest {
    binderId: string;
    sectionId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdGetRequest {
    binderId: string;
    depth?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdPostRequest {
    binderId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdPutRequest {
    binderId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
    binderId: string;
    roleNameAndUserOrGroup: string;
    id: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest {
    binderId: string;
    nodeId: string;
    contentType?: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdSectionsNodeIdPutRequest {
    binderId: string;
    nodeId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdSectionsPostRequest {
    binderId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdSectionsSectionIdDeleteRequest {
    binderId: string;
    sectionId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdSectionsSectionIdGetRequest {
    binderId: string;
    sectionId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdVersionsGetRequest {
    binderId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
    binderId: string;
    majorVersion: string;
    minorVersion: string;
    source?: boolean;
    renditiontype?: string;
    docversion?: string;
    attachments?: string;
    _export?: string;
    docfield?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest {
    binderId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest {
    binderId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest {
    binderId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
    binderId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
    binderId: string;
    majorVersion: string;
    minorVersion: string;
    relationshipId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
    binderId: string;
    majorVersion: string;
    minorVersion: string;
    relationshipId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest {
    binderId: string;
    majorVersion: string;
    minorVersion: string;
    sectionId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersIdRolesGetRequest {
    id: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersIdRolesPostRequest {
    id: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersIdRolesRoleNameGetRequest {
    id: string;
    roleName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
    id: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
    id: string;
    majorVersion: string;
    minorVersion: string;
    nameV: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
    id: string;
    majorVersion: string;
    minorVersion: string;
    nameV: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersLifecycleActionsPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersLifecycleActionsUserActionNamePutRequest {
    userActionName: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersPostRequest {
    async?: boolean;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersTemplatesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersTemplatesPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersTemplatesPutRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersTemplatesTemplateNameBindernodesGetRequest {
    templateName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersTemplatesTemplateNameBindernodesPostRequest {
    templateName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersTemplatesTemplateNameBindernodesPutRequest {
    templateName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersTemplatesTemplateNameDeleteRequest {
    templateName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsBindersTemplatesTemplateNameGetRequest {
    templateName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDeletionsDocumentsGetRequest {
    startDate?: string;
    endDate?: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDeletionsVobjectsObjectNameGetRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsActionsGetRequest {
    loc?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest {
    lifecycleAndStateAndAction: string;
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsActionsWorkflowNameGetRequest {
    workflowName: string;
    loc?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsActionsWorkflowNamePostRequest {
    workflowName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsAnnotationsBatchDeleteRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsAnnotationsBatchPostRequest {
    authorization: string;
    contentType: string;
    accept: string;
    xVaultAPIClientID: string;
}

export interface ObjectsDocumentsAnnotationsBatchPutRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsAnnotationsRepliesBatchPostRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsAttachmentsBatchDeleteRequest {
    accept?: string;
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsAttachmentsBatchPostRequest {
    accept?: string;
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsAttachmentsBatchPutRequest {
    accept?: string;
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsBatchActionsFileextractPostRequest {
    source?: boolean;
    renditions?: boolean;
    allversions?: boolean;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsBatchActionsReclassifyPutRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIMigrationMode?: boolean;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsBatchActionsRerenderPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsBatchDeleteRequest {
    idParam?: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsBatchLockDeleteRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsBatchPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIMigrationMode?: boolean;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsBatchPutRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIMigrationMode?: boolean;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAnchorsGetRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAnnotationsFileGetRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAnnotationsFilePostRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest {
    docId: string;
    attachmentId: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest {
    docId: string;
    attachmentId: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest {
    docId: string;
    attachmentId: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest {
    docId: string;
    attachmentId: string;
    accept?: string;
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
    docId: string;
    attachmentId: string;
    attachmentVersion: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
    docId: string;
    attachmentId: string;
    attachmentVersion: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
    docId: string;
    attachmentId: string;
    attachmentVersion: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
    docId: string;
    attachmentId: string;
    attachmentVersion: string;
    restore?: boolean;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest {
    docId: string;
    attachmentId: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsFileGetRequest {
    docId: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsGetRequest {
    docId: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAttachmentsPostRequest {
    docId: string;
    accept?: string;
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdAudittrailGetRequest {
    docId: string;
    startDate?: string;
    endDate?: string;
    formatResult?: string;
    limit?: string;
    offset?: string;
    events?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdDeleteRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdEventsGetRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdFileGetRequest {
    docId: string;
    lockDocument?: boolean;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdGetRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdLockDeleteRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdLockGetRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdLockPostRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdPostRequest {
    docId: string;
    suppressRendition?: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdPutRequest {
    docId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIMigrationMode?: boolean;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdRenditionsGetRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest {
    docId: string;
    renditionType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest {
    docId: string;
    renditionType: string;
    steadyState?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdRenditionsRenditionTypePostRequest {
    docId: string;
    renditionType: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdRenditionsRenditionTypePutRequest {
    docId: string;
    renditionType: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
    docId: string;
    roleNameAndUserOrGroup: string;
    id: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsGetRequest {
    docId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    annotationId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    annotationId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    limit?: string;
    offset?: string;
    annotationTypes?: string;
    paginationId?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    attachmentId: string;
    attachmentVersion: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    attachmentId: string;
    attachmentVersion: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIMigrationMode?: boolean;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    relationshipId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    relationshipId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    renditionType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    renditionType: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    renditionType: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    renditionType: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest {
    docId: string;
    majorVersion: string;
    minorVersion: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsGetRequest {
    namedFilter?: string;
    scope?: string;
    versionscope?: string;
    search?: string;
    limit?: string;
    sort?: string;
    start?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsIdRolesGetRequest {
    id: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsIdRolesPostRequest {
    id: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsIdRolesRoleNameGetRequest {
    id: string;
    roleName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
    id: string;
    majorVersion: string;
    minorVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
    id: string;
    majorVersion: string;
    minorVersion: string;
    nameV: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
    id: string;
    majorVersion: string;
    minorVersion: string;
    nameV: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsLifecycleActionsPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsLifecycleActionsUserActionNamePutRequest {
    userActionName: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsPostRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIMigrationMode?: boolean;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsRelationshipsBatchDeleteRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsRelationshipsBatchPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsRenditionsBatchDeleteRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsRenditionsBatchPostRequest {
    idParam?: string;
    largeSizeAsset?: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIMigrationMode?: boolean;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsRolesBatchDeleteRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsRolesBatchPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsTemplatesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsTemplatesPostRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsTemplatesPutRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsTemplatesTemplateNameDeleteRequest {
    templateName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsTemplatesTemplateNameFileGetRequest {
    templateName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsTemplatesTemplateNameGetRequest {
    templateName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsTemplatesTemplateNamePutRequest {
    templateName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsTokensPostRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsVersionsBatchActionsFileextractPostRequest {
    source?: boolean;
    renditions?: boolean;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsVersionsBatchDeleteRequest {
    idParam?: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDocumentsVersionsBatchPostRequest {
    idParam?: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIMigrationMode?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDomainGetRequest {
    includeApplication?: boolean;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsDomainsGetRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsEdlMatchedDocumentsBatchActionsAddPostRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsGroupsAutoGetRequest {
    limit?: string;
    offset?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsGroupsGetRequest {
    includeImplied?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsGroupsGroupIdDeleteRequest {
    groupId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsGroupsGroupIdGetRequest {
    groupId: string;
    includeImplied?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsGroupsGroupIdPutRequest {
    groupId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsGroupsPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsLicensesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsActionsGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsActionsWorkflowNameGetRequest {
    workflowName: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsActionsWorkflowNamePostRequest {
    workflowName: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsGetRequest {
    objectV?: string;
    recordIdV?: string;
    participant?: string;
    statusV?: string;
    offset?: string;
    pageSize?: string;
    loc?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksGetRequest {
    objectV?: string;
    recordIdV?: string;
    assigneeV?: string;
    statusV?: string;
    offset?: string;
    pageSize?: string;
    loc?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsGetRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest {
    taskId: string;
    taskAction: string;
    loc?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest {
    taskId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsTasksTaskIdGetRequest {
    taskId: string;
    loc?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsWorkflowIdActionsGetRequest {
    workflowId: string;
    loc?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest {
    workflowId: string;
    workflowAction: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest {
    workflowId: string;
    workflowAction: string;
    documentsSys?: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsObjectworkflowsWorkflowIdGetRequest {
    workflowId: string;
    loc?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsPicklistsGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsPicklistsPicklistNameGetRequest {
    picklistName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest {
    picklistName: string;
    picklistValueName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsPicklistsPicklistNamePicklistValueNamePutRequest {
    picklistName: string;
    picklistValueName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsPicklistsPicklistNamePostRequest {
    picklistName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsPicklistsPicklistNamePutRequest {
    picklistName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxActionsBuildproductionPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxActionsPromoteproductionPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxActionsRecheckusagePostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxBatchChangesizePostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxEntitlementsSetPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxNameDeleteRequest {
    name: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxSnapshotApiNameActionsUpdatePostRequest {
    apiName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxSnapshotApiNameActionsUpgradePostRequest {
    apiName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxSnapshotApiNameDeleteRequest {
    apiName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxSnapshotGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxSnapshotPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxVaultIdActionsRefreshPostRequest {
    vaultId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSandboxVaultIdGetRequest {
    vaultId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSecuritypoliciesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsSecuritypoliciesSecurityPolicyNameGetRequest {
    securityPolicyName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersGetRequest {
    vaults?: string;
    excludeVaultMembership?: string;
    excludeAppLicensing?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersIdGetRequest {
    id: string;
    excludeVaultMembership?: string;
    excludeAppLicensing?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersIdPermissionsGetRequest {
    id: string;
    filter?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersIdPutRequest {
    id: string;
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersMeGetRequest {
    excludeVaultMembership?: string;
    excludeAppLicensing?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersMePasswordPostRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersMePermissionsGetRequest {
    filter?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersMePutRequest {
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersPutRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersUserIdDeleteRequest {
    userId: string;
    domain?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsUsersUserIdVaultMembershipVaultIdPutRequest {
    userId: string;
    vaultId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsVaultActionsComparePostRequest {
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ObjectsVaultActionsConfigreportPostRequest {
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface QueryComponentsPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface QueryNextPagePostRequest {
    nextPage: string;
    authorization?: string;
    accept?: string;
    xVaultAPIDescribeQuery?: boolean;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface QueryPostRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIDescribeQuery?: boolean;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface QueryPreviousPagePostRequest {
    previousPage: string;
    authorization?: string;
    accept?: string;
    xVaultAPIDescribeQuery?: boolean;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2MeGetRequest {
    attributes?: string;
    excludedAttributes?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2MePutRequest {
    attributes?: string;
    excludedAttributes?: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2ResourceTypesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2ResourceTypesTypeGetRequest {
    type: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2SchemasGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2SchemasIdGetRequest {
    id: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2ServiceProviderConfigGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2TypeGetRequest {
    type: string;
    filter?: string;
    attributes?: string;
    excludedAttributes?: string;
    sortBy?: string;
    sortOrder?: string;
    startIndex?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2TypeIdGetRequest {
    type: string;
    id: string;
    attributes?: string;
    excludedAttributes?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2UsersGetRequest {
    filter?: string;
    attributes?: string;
    excludedAttributes?: string;
    sortBy?: string;
    sortOrder?: string;
    count?: string;
    startIndex?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2UsersIdGetRequest {
    id: string;
    filter?: string;
    attributes?: string;
    excludedAttributes?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2UsersIdPutRequest {
    id: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ScimV2UsersPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesCertificateCertIdGetRequest {
    certId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesConfigurationModeActionsDisablePostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesConfigurationModeActionsEnablePostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesDirectdataFilesGetRequest {
    extractType?: string;
    startTime?: number;
    stopTime?: number;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesDirectdataFilesNameGetRequest {
    name: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingItemsContentItemGetRequest {
    item: string;
    authorization?: string;
    accept?: string;
    range?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingItemsItemDeleteRequest {
    item: string;
    recursive?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingItemsItemGetRequest {
    item: string;
    recursive?: string;
    limit?: string;
    formatResult?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingItemsItemPutRequest {
    item: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingItemsPostRequest {
    authorization?: string;
    accept?: string;
    contentMD5?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingUploadGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingUploadPostRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingUploadUploadSessionIdDeleteRequest {
    uploadSessionId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingUploadUploadSessionIdGetRequest {
    uploadSessionId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingUploadUploadSessionIdPartsGetRequest {
    uploadSessionId: string;
    limit?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingUploadUploadSessionIdPostRequest {
    uploadSessionId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesFileStagingUploadUploadSessionIdPutRequest {
    uploadSessionId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIFilePartNumber?: string;
    contentMD5?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesJobsHistoriesGetRequest {
    startDate?: string;
    endDate?: string;
    status?: string;
    limit?: string;
    offset?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesJobsJobIdErrorsGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesJobsJobIdGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesJobsJobIdSummaryGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesJobsJobIdTasksGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesJobsMonitorsGetRequest {
    startDate?: string;
    endDate?: string;
    status?: string;
    limit?: string;
    offset?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesJobsStartNowJobIdPostRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesLoaderExtractPostRequest {
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesLoaderJobIdTasksTaskIdFailurelogGetRequest {
    jobId: string;
    taskId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesLoaderJobIdTasksTaskIdResultsGetRequest {
    jobId: string;
    taskId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest {
    jobId: string;
    taskId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest {
    jobId: string;
    taskId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesLoaderLoadPostRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesPackageActionsValidatePostRequest {
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesPackagePostRequest {
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesPackagePutRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesQueuesGetRequest {
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesQueuesQueueNameActionsDisableDeliveryPutRequest {
    queueName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesQueuesQueueNameActionsEnableDeliveryPutRequest {
    queueName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesQueuesQueueNameActionsResetPutRequest {
    queueName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesQueuesQueueNameGetRequest {
    queueName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface ServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest {
    packageId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface SessionDeleteRequest {
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface UicodeDistributionsDistributionNameCodeGetRequest {
    distributionName: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface UicodeDistributionsDistributionNameDeleteRequest {
    distributionName: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface UicodeDistributionsDistributionNameGetRequest {
    distributionName: string;
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface UicodeDistributionsGetRequest {
    accept?: string;
    authorization?: string;
    xVaultAPIClientID?: string;
}

export interface UicodeDistributionsPostRequest {
    accept?: string;
    authorization?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectVaultPackageVPackageIdActionsDeployPostRequest {
    packageId: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectVaultPackageVPackageIdActionsDeployResultsGetRequest {
    packageId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest {
    objectName: string;
    jobStatus: string;
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest {
    objectName: string;
    jobStatus: string;
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsEdlItemVActionsCreateplaceholderPostRequest {
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsMergesJobIdLogGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsMergesJobIdResultsGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsMergesJobIdStatusGetRequest {
    jobId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameActionsActionNamePostRequest {
    objectName: string;
    actionName: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameActionsChangetypePostRequest {
    objectName: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameActionsMergePostRequest {
    objectName: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
    vobjectsObjectNameActionsMergePostRequestInner?: Array<VobjectsObjectNameActionsMergePostRequestInner>;
}

export interface VobjectsObjectNameActionsRecalculaterollupsGetRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameActionsRecalculaterollupsPostRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameAttachmentsBatchDeleteRequest {
    objectName: string;
    idParam?: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameAttachmentsBatchPostRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameAttachmentsBatchPutRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameDeleteRequest {
    objectName: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameIdRolesRoleNameGetRequest {
    objectName: string;
    id: string;
    roleName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdActionsActionNameGetRequest {
    objectName: string;
    objectRecordId: string;
    actionName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdActionsActionNamePostRequest {
    objectName: string;
    objectRecordId: string;
    actionName: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest {
    objectName: string;
    objectRecordId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest {
    objectName: string;
    objectRecordId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdActionsGetRequest {
    objectName: string;
    objectRecordId: string;
    loc?: boolean;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest {
    objectName: string;
    objectRecordId: string;
    attachmentFieldName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest {
    objectName: string;
    objectRecordId: string;
    attachmentFieldName: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest {
    objectName: string;
    objectRecordId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest {
    objectName: string;
    objectRecordId: string;
    attachmentId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest {
    objectName: string;
    objectRecordId: string;
    attachmentId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest {
    objectName: string;
    objectRecordId: string;
    attachmentId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
    objectName: string;
    objectRecordId: string;
    attachmentId: string;
    attachmentVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
    objectName: string;
    objectRecordId: string;
    attachmentId: string;
    attachmentVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
    objectName: string;
    objectRecordId: string;
    attachmentId: string;
    attachmentVersion: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
    objectName: string;
    objectRecordId: string;
    attachmentId: string;
    attachmentVersion: string;
    restore?: boolean;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest {
    objectName: string;
    objectRecordId: string;
    attachmentId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest {
    objectName: string;
    objectRecordId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsGetRequest {
    objectName: string;
    objectRecordId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAttachmentsPostRequest {
    objectName: string;
    objectRecordId: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdAudittrailGetRequest {
    objectName: string;
    objectRecordId: string;
    startDate?: string;
    endDate?: string;
    formatResult?: string;
    limit?: string;
    offset?: string;
    events?: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameObjectRecordIdGetRequest {
    objectName: string;
    objectRecordId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNamePostRequest {
    objectName: string;
    idParam?: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIMigrationMode?: boolean;
    xVaultAPINoTriggers?: boolean;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNamePutRequest {
    objectName: string;
    authorization?: string;
    contentType?: string;
    accept?: string;
    xVaultAPIMigrationMode?: boolean;
    xVaultAPINoTriggers?: boolean;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameRolesDeleteRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsObjectNameRolesPostRequest {
    objectName: string;
    authorization?: string;
    accept?: string;
    contentType?: string;
    xVaultAPIClientID?: string;
}

export interface VobjectsOutboundPackageVPackageIdDependenciesGetRequest {
    packageId: string;
    authorization?: string;
    accept?: string;
    xVaultAPIClientID?: string;
}


/**
 * Retrieve API Versions
 */
function apiGetRaw<T>(requestParameters: ApiGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve API Versions
*/
export function apiGet<T>(requestParameters: ApiGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return apiGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Content File
 */
function apiMdlComponentsComponentTypeAndRecordNameFilesGetRaw<T>(requestParameters: ApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.componentTypeAndRecordName === null || requestParameters.componentTypeAndRecordName === undefined) {
        throw new runtime.RequiredError('componentTypeAndRecordName','Required parameter requestParameters.componentTypeAndRecordName was null or undefined when calling apiMdlComponentsComponentTypeAndRecordNameFilesGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/mdl/components/{component_type_and_record_name}/files`.replace(`{${"component_type_and_record_name"}}`, encodeURIComponent(String(requestParameters.componentTypeAndRecordName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Content File
*/
export function apiMdlComponentsComponentTypeAndRecordNameFilesGet<T>(requestParameters: ApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return apiMdlComponentsComponentTypeAndRecordNameFilesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Component Record (MDL)
 */
function apiMdlComponentsComponentTypeAndRecordNameGetRaw<T>(requestParameters: ApiMdlComponentsComponentTypeAndRecordNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.componentTypeAndRecordName === null || requestParameters.componentTypeAndRecordName === undefined) {
        throw new runtime.RequiredError('componentTypeAndRecordName','Required parameter requestParameters.componentTypeAndRecordName was null or undefined when calling apiMdlComponentsComponentTypeAndRecordNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/mdl/components/{component_type_and_record_name}`.replace(`{${"component_type_and_record_name"}}`, encodeURIComponent(String(requestParameters.componentTypeAndRecordName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Component Record (MDL)
*/
export function apiMdlComponentsComponentTypeAndRecordNameGet<T>(requestParameters: ApiMdlComponentsComponentTypeAndRecordNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return apiMdlComponentsComponentTypeAndRecordNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Asynchronous MDL Script Results
 */
function apiMdlExecuteAsyncJobIdResultsGetRaw<T>(requestParameters: ApiMdlExecuteAsyncJobIdResultsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling apiMdlExecuteAsyncJobIdResultsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/mdl/execute_async/{job_id}/results`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Asynchronous MDL Script Results
*/
export function apiMdlExecuteAsyncJobIdResultsGet<T>(requestParameters: ApiMdlExecuteAsyncJobIdResultsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return apiMdlExecuteAsyncJobIdResultsGetRaw(requestParameters, requestConfig);
}

/**
 * Execute MDL Script Asynchronously
 */
function apiMdlExecuteAsyncPostRaw<T>(requestParameters: ApiMdlExecuteAsyncPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/mdl/execute_async`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Execute MDL Script Asynchronously
*/
export function apiMdlExecuteAsyncPost<T>(requestParameters: ApiMdlExecuteAsyncPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return apiMdlExecuteAsyncPostRaw(requestParameters, requestConfig);
}

/**
 * Execute MDL Script
 */
function apiMdlExecutePostRaw<T>(requestParameters: ApiMdlExecutePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/mdl/execute`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Execute MDL Script
*/
export function apiMdlExecutePost<T>(requestParameters: ApiMdlExecutePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return apiMdlExecutePostRaw(requestParameters, requestConfig);
}

/**
 * Upload Content File
 */
function apiMdlFilesPostRaw<T>(requestParameters: ApiMdlFilesPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/mdl/files`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Upload Content File
*/
export function apiMdlFilesPost<T>(requestParameters: ApiMdlFilesPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return apiMdlFilesPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Audit Details
 */
function audittrailAuditTrailTypeGetRaw<T>(requestParameters: AudittrailAuditTrailTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.auditTrailType === null || requestParameters.auditTrailType === undefined) {
        throw new runtime.RequiredError('auditTrailType','Required parameter requestParameters.auditTrailType was null or undefined when calling audittrailAuditTrailTypeGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = requestParameters.startDate;
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = requestParameters.endDate;
    }


    if (requestParameters.allDates !== undefined) {
        queryParameters['all_dates'] = requestParameters.allDates;
    }


    if (requestParameters.formatResult !== undefined) {
        queryParameters['format_result'] = requestParameters.formatResult;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.objects !== undefined) {
        queryParameters['objects'] = requestParameters.objects;
    }


    if (requestParameters.events !== undefined) {
        queryParameters['events'] = requestParameters.events;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/audittrail/{audit_trail_type}`.replace(`{${"audit_trail_type"}}`, encodeURIComponent(String(requestParameters.auditTrailType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Audit Details
*/
export function audittrailAuditTrailTypeGet<T>(requestParameters: AudittrailAuditTrailTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return audittrailAuditTrailTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Authentication Type Discovery
 */
function authDiscoveryPostRaw<T>(requestParameters: AuthDiscoveryPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/auth/discovery`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Authentication Type Discovery
*/
export function authDiscoveryPost<T>(requestParameters: AuthDiscoveryPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return authDiscoveryPostRaw(requestParameters, requestConfig);
}

/**
 * OAuth 2.0 / OpenID Connect
 */
function authOauthSessionOathOidcProfileIdPostRaw<T>(requestParameters: AuthOauthSessionOathOidcProfileIdPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.oathOidcProfileId === null || requestParameters.oathOidcProfileId === undefined) {
        throw new runtime.RequiredError('oathOidcProfileId','Required parameter requestParameters.oathOidcProfileId was null or undefined when calling authOauthSessionOathOidcProfileIdPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/auth/oauth/session/{oath_oidc_profile_id}`.replace(`{${"oath_oidc_profile_id"}}`, encodeURIComponent(String(requestParameters.oathOidcProfileId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* OAuth 2.0 / OpenID Connect
*/
export function authOauthSessionOathOidcProfileIdPost<T>(requestParameters: AuthOauthSessionOathOidcProfileIdPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return authOauthSessionOathOidcProfileIdPostRaw(requestParameters, requestConfig);
}

/**
 * User Name and Password
 */
function authPostRaw<T>(requestParameters: AuthPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/auth`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* User Name and Password
*/
export function authPost<T>(requestParameters: AuthPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return authPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Single Source Code File
 */
function codeClassNameDeleteRaw<T>(requestParameters: CodeClassNameDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.className === null || requestParameters.className === undefined) {
        throw new runtime.RequiredError('className','Required parameter requestParameters.className was null or undefined when calling codeClassNameDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/{class_name}`.replace(`{${"class_name"}}`, encodeURIComponent(String(requestParameters.className))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Single Source Code File
*/
export function codeClassNameDelete<T>(requestParameters: CodeClassNameDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeClassNameDeleteRaw(requestParameters, requestConfig);
}

/**
 * Disable Vault Extension
 */
function codeClassNameDisablePutRaw<T>(requestParameters: CodeClassNameDisablePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.className === null || requestParameters.className === undefined) {
        throw new runtime.RequiredError('className','Required parameter requestParameters.className was null or undefined when calling codeClassNameDisablePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/{class_name}/disable`.replace(`{${"class_name"}}`, encodeURIComponent(String(requestParameters.className))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Disable Vault Extension
*/
export function codeClassNameDisablePut<T>(requestParameters: CodeClassNameDisablePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeClassNameDisablePutRaw(requestParameters, requestConfig);
}

/**
 * Enable Vault Extension
 */
function codeClassNameEnablePutRaw<T>(requestParameters: CodeClassNameEnablePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.className === null || requestParameters.className === undefined) {
        throw new runtime.RequiredError('className','Required parameter requestParameters.className was null or undefined when calling codeClassNameEnablePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/{class_name}/enable`.replace(`{${"class_name"}}`, encodeURIComponent(String(requestParameters.className))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Enable Vault Extension
*/
export function codeClassNameEnablePut<T>(requestParameters: CodeClassNameEnablePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeClassNameEnablePutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Single Source Code File
 */
function codeClassNameGetRaw<T>(requestParameters: CodeClassNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.className === null || requestParameters.className === undefined) {
        throw new runtime.RequiredError('className','Required parameter requestParameters.className was null or undefined when calling codeClassNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/{class_name}`.replace(`{${"class_name"}}`, encodeURIComponent(String(requestParameters.className))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Single Source Code File
*/
export function codeClassNameGet<T>(requestParameters: CodeClassNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeClassNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Profiling Sessions
 */
function codeProfilerGetRaw<T>(requestParameters: CodeProfilerGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/profiler`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Profiling Sessions
*/
export function codeProfilerGet<T>(requestParameters: CodeProfilerGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeProfilerGetRaw(requestParameters, requestConfig);
}

/**
 * Create Profiling Session
 */
function codeProfilerPostRaw<T>(requestParameters: CodeProfilerPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/profiler`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Profiling Session
*/
export function codeProfilerPost<T>(requestParameters: CodeProfilerPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeProfilerPostRaw(requestParameters, requestConfig);
}

/**
 * End Profiling Session
 */
function codeProfilerSessionNameActionsEndPostRaw<T>(requestParameters: CodeProfilerSessionNameActionsEndPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.sessionName === null || requestParameters.sessionName === undefined) {
        throw new runtime.RequiredError('sessionName','Required parameter requestParameters.sessionName was null or undefined when calling codeProfilerSessionNameActionsEndPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/profiler/{session_name}/actions/end`.replace(`{${"session_name"}}`, encodeURIComponent(String(requestParameters.sessionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* End Profiling Session
*/
export function codeProfilerSessionNameActionsEndPost<T>(requestParameters: CodeProfilerSessionNameActionsEndPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeProfilerSessionNameActionsEndPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Profiling Session
 */
function codeProfilerSessionNameDeleteRaw<T>(requestParameters: CodeProfilerSessionNameDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.sessionName === null || requestParameters.sessionName === undefined) {
        throw new runtime.RequiredError('sessionName','Required parameter requestParameters.sessionName was null or undefined when calling codeProfilerSessionNameDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/profiler/{session_name}`.replace(`{${"session_name"}}`, encodeURIComponent(String(requestParameters.sessionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Profiling Session
*/
export function codeProfilerSessionNameDelete<T>(requestParameters: CodeProfilerSessionNameDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeProfilerSessionNameDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Profiling Session
 */
function codeProfilerSessionNameGetRaw<T>(requestParameters: CodeProfilerSessionNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.sessionName === null || requestParameters.sessionName === undefined) {
        throw new runtime.RequiredError('sessionName','Required parameter requestParameters.sessionName was null or undefined when calling codeProfilerSessionNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/profiler/{session_name}`.replace(`{${"session_name"}}`, encodeURIComponent(String(requestParameters.sessionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Profiling Session
*/
export function codeProfilerSessionNameGet<T>(requestParameters: CodeProfilerSessionNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeProfilerSessionNameGetRaw(requestParameters, requestConfig);
}

/**
 * Download Profiling Session Results
 */
function codeProfilerSessionNameResultsGetRaw<T>(requestParameters: CodeProfilerSessionNameResultsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.sessionName === null || requestParameters.sessionName === undefined) {
        throw new runtime.RequiredError('sessionName','Required parameter requestParameters.sessionName was null or undefined when calling codeProfilerSessionNameResultsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code/profiler/{session_name}/results`.replace(`{${"session_name"}}`, encodeURIComponent(String(requestParameters.sessionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Profiling Session Results
*/
export function codeProfilerSessionNameResultsGet<T>(requestParameters: CodeProfilerSessionNameResultsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codeProfilerSessionNameResultsGetRaw(requestParameters, requestConfig);
}

/**
 * Add or Replace Single Source Code File
 */
function codePutRaw<T>(requestParameters: CodePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/code`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Add or Replace Single Source Code File
*/
export function codePut<T>(requestParameters: CodePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return codePutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Specific Root Nodes
 */
function compositesTreesEdlHierarchyOrTemplateActionsListnodesPostRaw<T>(requestParameters: CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.edlHierarchyOrTemplate === null || requestParameters.edlHierarchyOrTemplate === undefined) {
        throw new runtime.RequiredError('edlHierarchyOrTemplate','Required parameter requestParameters.edlHierarchyOrTemplate was null or undefined when calling compositesTreesEdlHierarchyOrTemplateActionsListnodesPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/composites/trees/{edl_hierarchy_or_template}/actions/listnodes`.replace(`{${"edl_hierarchy_or_template"}}`, encodeURIComponent(String(requestParameters.edlHierarchyOrTemplate))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Specific Root Nodes
*/
export function compositesTreesEdlHierarchyOrTemplateActionsListnodesPost<T>(requestParameters: CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return compositesTreesEdlHierarchyOrTemplateActionsListnodesPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Root Nodes
 */
function compositesTreesEdlHierarchyOrTemplateGetRaw<T>(requestParameters: CompositesTreesEdlHierarchyOrTemplateGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.edlHierarchyOrTemplate === null || requestParameters.edlHierarchyOrTemplate === undefined) {
        throw new runtime.RequiredError('edlHierarchyOrTemplate','Required parameter requestParameters.edlHierarchyOrTemplate was null or undefined when calling compositesTreesEdlHierarchyOrTemplateGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/composites/trees/{edl_hierarchy_or_template}`.replace(`{${"edl_hierarchy_or_template"}}`, encodeURIComponent(String(requestParameters.edlHierarchyOrTemplate))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Root Nodes
*/
export function compositesTreesEdlHierarchyOrTemplateGet<T>(requestParameters: CompositesTreesEdlHierarchyOrTemplateGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return compositesTreesEdlHierarchyOrTemplateGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve a Node\'s Children
 */
function compositesTreesEdlHierarchyVParentNodeIdChildrenGetRaw<T>(requestParameters: CompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.parentNodeId === null || requestParameters.parentNodeId === undefined) {
        throw new runtime.RequiredError('parentNodeId','Required parameter requestParameters.parentNodeId was null or undefined when calling compositesTreesEdlHierarchyVParentNodeIdChildrenGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/composites/trees/edl_hierarchy__v/{parent_node_id}/children`.replace(`{${"parent_node_id"}}`, encodeURIComponent(String(requestParameters.parentNodeId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve a Node\'s Children
*/
export function compositesTreesEdlHierarchyVParentNodeIdChildrenGet<T>(requestParameters: CompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return compositesTreesEdlHierarchyVParentNodeIdChildrenGetRaw(requestParameters, requestConfig);
}

/**
 * Update Node Order
 */
function compositesTreesEdlHierarchyVParentNodeIdChildrenPutRaw<T>(requestParameters: CompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.parentNodeId === null || requestParameters.parentNodeId === undefined) {
        throw new runtime.RequiredError('parentNodeId','Required parameter requestParameters.parentNodeId was null or undefined when calling compositesTreesEdlHierarchyVParentNodeIdChildrenPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/composites/trees/edl_hierarchy__v/{parent_node_id}/children`.replace(`{${"parent_node_id"}}`, encodeURIComponent(String(requestParameters.parentNodeId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Node Order
*/
export function compositesTreesEdlHierarchyVParentNodeIdChildrenPut<T>(requestParameters: CompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return compositesTreesEdlHierarchyVParentNodeIdChildrenPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Component Record (XML/JSON)
 */
function configurationComponentTypeAndRecordNameGetRaw<T>(requestParameters: ConfigurationComponentTypeAndRecordNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.componentTypeAndRecordName === null || requestParameters.componentTypeAndRecordName === undefined) {
        throw new runtime.RequiredError('componentTypeAndRecordName','Required parameter requestParameters.componentTypeAndRecordName was null or undefined when calling configurationComponentTypeAndRecordNameGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/configuration/{component_type_and_record_name}`.replace(`{${"component_type_and_record_name"}}`, encodeURIComponent(String(requestParameters.componentTypeAndRecordName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Component Record (XML/JSON)
*/
export function configurationComponentTypeAndRecordNameGet<T>(requestParameters: ConfigurationComponentTypeAndRecordNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return configurationComponentTypeAndRecordNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Component Record Collection
 */
function configurationComponentTypeGetRaw<T>(requestParameters: ConfigurationComponentTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.componentType === null || requestParameters.componentType === undefined) {
        throw new runtime.RequiredError('componentType','Required parameter requestParameters.componentType was null or undefined when calling configurationComponentTypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/configuration/{component_type}`.replace(`{${"component_type"}}`, encodeURIComponent(String(requestParameters.componentType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Component Record Collection
*/
export function configurationComponentTypeGet<T>(requestParameters: ConfigurationComponentTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return configurationComponentTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Details from a Specific Object
 */
function configurationObjectNameAndObjectTypeGetRaw<T>(requestParameters: ConfigurationObjectNameAndObjectTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectNameAndObjectType === null || requestParameters.objectNameAndObjectType === undefined) {
        throw new runtime.RequiredError('objectNameAndObjectType','Required parameter requestParameters.objectNameAndObjectType was null or undefined when calling configurationObjectNameAndObjectTypeGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/configuration/{object_name_and_object_type}`.replace(`{${"object_name_and_object_type"}}`, encodeURIComponent(String(requestParameters.objectNameAndObjectType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Details from a Specific Object
*/
export function configurationObjectNameAndObjectTypeGet<T>(requestParameters: ConfigurationObjectNameAndObjectTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return configurationObjectNameAndObjectTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Details from All Object Types
 */
function configurationObjecttypeGetRaw<T>(requestParameters: ConfigurationObjecttypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/configuration/Objecttype`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Details from All Object Types
*/
export function configurationObjecttypeGet<T>(requestParameters: ConfigurationObjecttypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return configurationObjecttypeGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Lifecycle Role Assignment Override Rules
 */
function configurationRoleAssignmentRuleDeleteRaw<T>(requestParameters: ConfigurationRoleAssignmentRuleDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/configuration/role_assignment_rule`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Lifecycle Role Assignment Override Rules
*/
export function configurationRoleAssignmentRuleDelete<T>(requestParameters: ConfigurationRoleAssignmentRuleDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return configurationRoleAssignmentRuleDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Lifecycle Role Assignment Rules (Default & Override)
 */
function configurationRoleAssignmentRuleGetRaw<T>(requestParameters: ConfigurationRoleAssignmentRuleGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.lifecycleV !== undefined) {
        queryParameters['lifecycle__v'] = requestParameters.lifecycleV;
    }


    if (requestParameters.roleV !== undefined) {
        queryParameters['role__v'] = requestParameters.roleV;
    }


    if (requestParameters.productV !== undefined) {
        queryParameters['product__v'] = requestParameters.productV;
    }


    if (requestParameters.countryV !== undefined) {
        queryParameters['country__v'] = requestParameters.countryV;
    }


    if (requestParameters.studyV !== undefined) {
        queryParameters['study__v'] = requestParameters.studyV;
    }


    if (requestParameters.studyCountryV !== undefined) {
        queryParameters['study_country__v'] = requestParameters.studyCountryV;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/configuration/role_assignment_rule`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Lifecycle Role Assignment Rules (Default & Override)
*/
export function configurationRoleAssignmentRuleGet<T>(requestParameters: ConfigurationRoleAssignmentRuleGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return configurationRoleAssignmentRuleGetRaw(requestParameters, requestConfig);
}

/**
 * Create Lifecycle Role Assignment Override Rules
 */
function configurationRoleAssignmentRulePostRaw<T>(requestParameters: ConfigurationRoleAssignmentRulePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/configuration/role_assignment_rule`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Lifecycle Role Assignment Override Rules
*/
export function configurationRoleAssignmentRulePost<T>(requestParameters: ConfigurationRoleAssignmentRulePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return configurationRoleAssignmentRulePostRaw(requestParameters, requestConfig);
}

/**
 * Update Lifecycle Role Assignment Rules (Default & Override)
 */
function configurationRoleAssignmentRulePutRaw<T>(requestParameters: ConfigurationRoleAssignmentRulePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/configuration/role_assignment_rule`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Lifecycle Role Assignment Rules (Default & Override)
*/
export function configurationRoleAssignmentRulePut<T>(requestParameters: ConfigurationRoleAssignmentRulePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return configurationRoleAssignmentRulePutRaw(requestParameters, requestConfig);
}

/**
 * Initiate Delegated Session
 */
function delegationLoginPostRaw<T>(requestParameters: DelegationLoginPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/delegation/login`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Delegated Session
*/
export function delegationLoginPost<T>(requestParameters: DelegationLoginPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return delegationLoginPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Delegations
 */
function delegationVaultsGetRaw<T>(requestParameters: DelegationVaultsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/delegation/vaults`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Delegations
*/
export function delegationVaultsGet<T>(requestParameters: DelegationVaultsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return delegationVaultsGetRaw(requestParameters, requestConfig);
}

/**
 * Session Keep Alive
 */
function keepAlivePostRaw<T>(requestParameters: KeepAlivePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/keep-alive`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Session Keep Alive
*/
export function keepAlivePost<T>(requestParameters: KeepAlivePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return keepAlivePostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Limits on Objects
 */
function limitsGetRaw<T>(requestParameters: LimitsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/limits`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Limits on Objects
*/
export function limitsGet<T>(requestParameters: LimitsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return limitsGetRaw(requestParameters, requestConfig);
}

/**
 * Download Daily API Usage
 */
function logsApiUsageGetRaw<T>(requestParameters: LogsApiUsageGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.date !== undefined) {
        queryParameters['date'] = requestParameters.date;
    }


    if (requestParameters.logFormat !== undefined) {
        queryParameters['log_format'] = requestParameters.logFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/logs/api_usage`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Daily API Usage
*/
export function logsApiUsageGet<T>(requestParameters: LogsApiUsageGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return logsApiUsageGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Debug Logs
 */
function logsCodeDebugGetRaw<T>(requestParameters: LogsCodeDebugGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.userId !== undefined) {
        queryParameters['user_id'] = requestParameters.userId;
    }


    if (requestParameters.includeInactive !== undefined) {
        queryParameters['include_inactive'] = requestParameters.includeInactive;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/logs/code/debug`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Debug Logs
*/
export function logsCodeDebugGet<T>(requestParameters: LogsCodeDebugGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return logsCodeDebugGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Debug Log
 */
function logsCodeDebugIdActionsResetDeleteRaw<T>(requestParameters: LogsCodeDebugIdActionsResetDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling logsCodeDebugIdActionsResetDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/logs/code/debug/{id}/actions/reset`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Debug Log
*/
export function logsCodeDebugIdActionsResetDelete<T>(requestParameters: LogsCodeDebugIdActionsResetDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return logsCodeDebugIdActionsResetDeleteRaw(requestParameters, requestConfig);
}

/**
 * Reset Debug Log
 */
function logsCodeDebugIdActionsResetPostRaw<T>(requestParameters: LogsCodeDebugIdActionsResetPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling logsCodeDebugIdActionsResetPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/logs/code/debug/{id}/actions/reset`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Reset Debug Log
*/
export function logsCodeDebugIdActionsResetPost<T>(requestParameters: LogsCodeDebugIdActionsResetPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return logsCodeDebugIdActionsResetPostRaw(requestParameters, requestConfig);
}

/**
 * Download Debug Log Files
 */
function logsCodeDebugIdFilesGetRaw<T>(requestParameters: LogsCodeDebugIdFilesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling logsCodeDebugIdFilesGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/logs/code/debug/{id}/files`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Debug Log Files
*/
export function logsCodeDebugIdFilesGet<T>(requestParameters: LogsCodeDebugIdFilesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return logsCodeDebugIdFilesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Single Debug Log
 */
function logsCodeDebugIdGetRaw<T>(requestParameters: LogsCodeDebugIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling logsCodeDebugIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/logs/code/debug/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Single Debug Log
*/
export function logsCodeDebugIdGet<T>(requestParameters: LogsCodeDebugIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return logsCodeDebugIdGetRaw(requestParameters, requestConfig);
}

/**
 * Create Debug Log
 */
function logsCodeDebugPostRaw<T>(requestParameters: LogsCodeDebugPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/logs/code/debug`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Debug Log
*/
export function logsCodeDebugPost<T>(requestParameters: LogsCodeDebugPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return logsCodeDebugPostRaw(requestParameters, requestConfig);
}

/**
 * Download SDK Runtime Log
 */
function logsCodeRuntimeGetRaw<T>(requestParameters: LogsCodeRuntimeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.date !== undefined) {
        queryParameters['date'] = requestParameters.date;
    }


    if (requestParameters.logFormat !== undefined) {
        queryParameters['log_format'] = requestParameters.logFormat;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/logs/code/runtime`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download SDK Runtime Log
*/
export function logsCodeRuntimeGet<T>(requestParameters: LogsCodeRuntimeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return logsCodeRuntimeGetRaw(requestParameters, requestConfig);
}

/**
 * Import Bulk Translation File
 */
function messagesMessageTypeActionsImportPostRaw<T>(requestParameters: MessagesMessageTypeActionsImportPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.messageType === null || requestParameters.messageType === undefined) {
        throw new runtime.RequiredError('messageType','Required parameter requestParameters.messageType was null or undefined when calling messagesMessageTypeActionsImportPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/{message_type}/actions/import`.replace(`{${"message_type"}}`, encodeURIComponent(String(requestParameters.messageType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Import Bulk Translation File
*/
export function messagesMessageTypeActionsImportPost<T>(requestParameters: MessagesMessageTypeActionsImportPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return messagesMessageTypeActionsImportPostRaw(requestParameters, requestConfig);
}

/**
 * Export Bulk Translation File
 */
function messagesMessageTypeLanguageLangActionsExportPostRaw<T>(requestParameters: MessagesMessageTypeLanguageLangActionsExportPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.messageType === null || requestParameters.messageType === undefined) {
        throw new runtime.RequiredError('messageType','Required parameter requestParameters.messageType was null or undefined when calling messagesMessageTypeLanguageLangActionsExportPost.');
    }

    if (requestParameters.lang === null || requestParameters.lang === undefined) {
        throw new runtime.RequiredError('lang','Required parameter requestParameters.lang was null or undefined when calling messagesMessageTypeLanguageLangActionsExportPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/messages/{message_type}/language/{lang}/actions/export`.replace(`{${"message_type"}}`, encodeURIComponent(String(requestParameters.messageType))).replace(`{${"lang"}}`, encodeURIComponent(String(requestParameters.lang))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Export Bulk Translation File
*/
export function messagesMessageTypeLanguageLangActionsExportPost<T>(requestParameters: MessagesMessageTypeLanguageLangActionsExportPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return messagesMessageTypeLanguageLangActionsExportPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Audit Metadata
 */
function metadataAudittrailAuditTrailTypeGetRaw<T>(requestParameters: MetadataAudittrailAuditTrailTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.auditTrailType === null || requestParameters.auditTrailType === undefined) {
        throw new runtime.RequiredError('auditTrailType','Required parameter requestParameters.auditTrailType was null or undefined when calling metadataAudittrailAuditTrailTypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/audittrail/{audit_trail_type}`.replace(`{${"audit_trail_type"}}`, encodeURIComponent(String(requestParameters.auditTrailType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Audit Metadata
*/
export function metadataAudittrailAuditTrailTypeGet<T>(requestParameters: MetadataAudittrailAuditTrailTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataAudittrailAuditTrailTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Audit Types
 */
function metadataAudittrailGetRaw<T>(requestParameters: MetadataAudittrailGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/audittrail`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Audit Types
*/
export function metadataAudittrailGet<T>(requestParameters: MetadataAudittrailGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataAudittrailGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Component Type Metadata
 */
function metadataComponentsComponentTypeGetRaw<T>(requestParameters: MetadataComponentsComponentTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.componentType === null || requestParameters.componentType === undefined) {
        throw new runtime.RequiredError('componentType','Required parameter requestParameters.componentType was null or undefined when calling metadataComponentsComponentTypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/components/{component_type}`.replace(`{${"component_type"}}`, encodeURIComponent(String(requestParameters.componentType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Component Type Metadata
*/
export function metadataComponentsComponentTypeGet<T>(requestParameters: MetadataComponentsComponentTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataComponentsComponentTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Component Metadata
 */
function metadataComponentsGetRaw<T>(requestParameters: MetadataComponentsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/components`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Component Metadata
*/
export function metadataComponentsGet<T>(requestParameters: MetadataComponentsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataComponentsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Template Node Metadata
 */
function metadataObjectsBindersTemplatesBindernodesGetRaw<T>(requestParameters: MetadataObjectsBindersTemplatesBindernodesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/binders/templates/bindernodes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Template Node Metadata
*/
export function metadataObjectsBindersTemplatesBindernodesGet<T>(requestParameters: MetadataObjectsBindersTemplatesBindernodesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsBindersTemplatesBindernodesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Template Metadata
 */
function metadataObjectsBindersTemplatesGetRaw<T>(requestParameters: MetadataObjectsBindersTemplatesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/binders/templates`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Template Metadata
*/
export function metadataObjectsBindersTemplatesGet<T>(requestParameters: MetadataObjectsBindersTemplatesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsBindersTemplatesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Annotation Placemark Type Metadata
 */
function metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRaw<T>(requestParameters: MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.placemarkType === null || requestParameters.placemarkType === undefined) {
        throw new runtime.RequiredError('placemarkType','Required parameter requestParameters.placemarkType was null or undefined when calling metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/annotations/placemarks/types/{placemark_type}`.replace(`{${"placemark_type"}}`, encodeURIComponent(String(requestParameters.placemarkType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Annotation Placemark Type Metadata
*/
export function metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet<T>(requestParameters: MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Annotation Reference Type Metadata
 */
function metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRaw<T>(requestParameters: MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.referenceType === null || requestParameters.referenceType === undefined) {
        throw new runtime.RequiredError('referenceType','Required parameter requestParameters.referenceType was null or undefined when calling metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/annotations/references/types/{reference_type}`.replace(`{${"reference_type"}}`, encodeURIComponent(String(requestParameters.referenceType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Annotation Reference Type Metadata
*/
export function metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet<T>(requestParameters: MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Annotation Type Metadata
 */
function metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRaw<T>(requestParameters: MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.annotationType === null || requestParameters.annotationType === undefined) {
        throw new runtime.RequiredError('annotationType','Required parameter requestParameters.annotationType was null or undefined when calling metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/annotations/types/{annotation_type}`.replace(`{${"annotation_type"}}`, encodeURIComponent(String(requestParameters.annotationType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Annotation Type Metadata
*/
export function metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet<T>(requestParameters: MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Event SubType Metadata
 */
function metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRaw<T>(requestParameters: MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.eventType === null || requestParameters.eventType === undefined) {
        throw new runtime.RequiredError('eventType','Required parameter requestParameters.eventType was null or undefined when calling metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet.');
    }

    if (requestParameters.eventSubtype === null || requestParameters.eventSubtype === undefined) {
        throw new runtime.RequiredError('eventSubtype','Required parameter requestParameters.eventSubtype was null or undefined when calling metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/events/{event_type}/types/{event_subtype}`.replace(`{${"event_type"}}`, encodeURIComponent(String(requestParameters.eventType))).replace(`{${"event_subtype"}}`, encodeURIComponent(String(requestParameters.eventSubtype))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Event SubType Metadata
*/
export function metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet<T>(requestParameters: MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Event Types and Subtypes
 */
function metadataObjectsDocumentsEventsGetRaw<T>(requestParameters: MetadataObjectsDocumentsEventsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/events`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Event Types and Subtypes
*/
export function metadataObjectsDocumentsEventsGet<T>(requestParameters: MetadataObjectsDocumentsEventsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsEventsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Lock Metadata
 */
function metadataObjectsDocumentsLockGetRaw<T>(requestParameters: MetadataObjectsDocumentsLockGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/lock`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Lock Metadata
*/
export function metadataObjectsDocumentsLockGet<T>(requestParameters: MetadataObjectsDocumentsLockGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsLockGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Common Document Fields
 */
function metadataObjectsDocumentsPropertiesFindCommonPostRaw<T>(requestParameters: MetadataObjectsDocumentsPropertiesFindCommonPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/properties/find_common`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Common Document Fields
*/
export function metadataObjectsDocumentsPropertiesFindCommonPost<T>(requestParameters: MetadataObjectsDocumentsPropertiesFindCommonPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsPropertiesFindCommonPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Document Fields
 */
function metadataObjectsDocumentsPropertiesGetRaw<T>(requestParameters: MetadataObjectsDocumentsPropertiesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/properties`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Document Fields
*/
export function metadataObjectsDocumentsPropertiesGet<T>(requestParameters: MetadataObjectsDocumentsPropertiesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsPropertiesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Template Metadata
 */
function metadataObjectsDocumentsTemplatesGetRaw<T>(requestParameters: MetadataObjectsDocumentsTemplatesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/templates`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Template Metadata
*/
export function metadataObjectsDocumentsTemplatesGet<T>(requestParameters: MetadataObjectsDocumentsTemplatesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsTemplatesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Document Types
 */
function metadataObjectsDocumentsTypesGetRaw<T>(requestParameters: MetadataObjectsDocumentsTypesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/types`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Document Types
*/
export function metadataObjectsDocumentsTypesGet<T>(requestParameters: MetadataObjectsDocumentsTypesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsTypesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Type
 */
function metadataObjectsDocumentsTypesTypeGetRaw<T>(requestParameters: MetadataObjectsDocumentsTypesTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.type === null || requestParameters.type === undefined) {
        throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling metadataObjectsDocumentsTypesTypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/types/{type}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Type
*/
export function metadataObjectsDocumentsTypesTypeGet<T>(requestParameters: MetadataObjectsDocumentsTypesTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsTypesTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Type Relationships
 */
function metadataObjectsDocumentsTypesTypeRelationshipsGetRaw<T>(requestParameters: MetadataObjectsDocumentsTypesTypeRelationshipsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.type === null || requestParameters.type === undefined) {
        throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling metadataObjectsDocumentsTypesTypeRelationshipsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/types/{type}/relationships`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Type Relationships
*/
export function metadataObjectsDocumentsTypesTypeRelationshipsGet<T>(requestParameters: MetadataObjectsDocumentsTypesTypeRelationshipsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsTypesTypeRelationshipsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Classification
 */
function metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRaw<T>(requestParameters: MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.type === null || requestParameters.type === undefined) {
        throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet.');
    }

    if (requestParameters.subtype === null || requestParameters.subtype === undefined) {
        throw new runtime.RequiredError('subtype','Required parameter requestParameters.subtype was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet.');
    }

    if (requestParameters.classification === null || requestParameters.classification === undefined) {
        throw new runtime.RequiredError('classification','Required parameter requestParameters.classification was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/types/{type}/subtypes/{subtype}/classifications/{classification}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"subtype"}}`, encodeURIComponent(String(requestParameters.subtype))).replace(`{${"classification"}}`, encodeURIComponent(String(requestParameters.classification))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Classification
*/
export function metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet<T>(requestParameters: MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Subtype
 */
function metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRaw<T>(requestParameters: MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.type === null || requestParameters.type === undefined) {
        throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeGet.');
    }

    if (requestParameters.subtype === null || requestParameters.subtype === undefined) {
        throw new runtime.RequiredError('subtype','Required parameter requestParameters.subtype was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/documents/types/{type}/subtypes/{subtype}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"subtype"}}`, encodeURIComponent(String(requestParameters.subtype))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Subtype
*/
export function metadataObjectsDocumentsTypesTypeSubtypesSubtypeGet<T>(requestParameters: MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Group Metadata
 */
function metadataObjectsGroupsGetRaw<T>(requestParameters: MetadataObjectsGroupsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/groups`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Group Metadata
*/
export function metadataObjectsGroupsGet<T>(requestParameters: MetadataObjectsGroupsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsGroupsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Security Policy Metadata
 */
function metadataObjectsSecuritypoliciesGetRaw<T>(requestParameters: MetadataObjectsSecuritypoliciesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/securitypolicies`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Security Policy Metadata
*/
export function metadataObjectsSecuritypoliciesGet<T>(requestParameters: MetadataObjectsSecuritypoliciesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsSecuritypoliciesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve User Metadata
 */
function metadataObjectsUsersGetRaw<T>(requestParameters: MetadataObjectsUsersGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/objects/users`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve User Metadata
*/
export function metadataObjectsUsersGet<T>(requestParameters: MetadataObjectsUsersGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataObjectsUsersGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Archived Document Signature Metadata
 */
function metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRaw<T>(requestParameters: MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/query/archived_documents/relationships/document_signature__sysr`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Archived Document Signature Metadata
*/
export function metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGet<T>(requestParameters: MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Signature Metadata
 */
function metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRaw<T>(requestParameters: MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/query/documents/relationships/document_signature__sysr`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Signature Metadata
*/
export function metadataQueryDocumentsRelationshipsDocumentSignatureSysrGet<T>(requestParameters: MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Collection
 */
function metadataVobjectsGetRaw<T>(requestParameters: MetadataVobjectsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/vobjects`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Collection
*/
export function metadataVobjectsGet<T>(requestParameters: MetadataVobjectsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataVobjectsGetRaw(requestParameters, requestConfig);
}

/**
 * Cancel Raw Object Deployment
 */
function metadataVobjectsObjectNameActionsCanceldeploymentPostRaw<T>(requestParameters: MetadataVobjectsObjectNameActionsCanceldeploymentPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling metadataVobjectsObjectNameActionsCanceldeploymentPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/vobjects/{object_name}/actions/canceldeployment`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Cancel Raw Object Deployment
*/
export function metadataVobjectsObjectNameActionsCanceldeploymentPost<T>(requestParameters: MetadataVobjectsObjectNameActionsCanceldeploymentPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataVobjectsObjectNameActionsCanceldeploymentPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Field Metadata
 */
function metadataVobjectsObjectNameFieldsObjectFieldNameGetRaw<T>(requestParameters: MetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling metadataVobjectsObjectNameFieldsObjectFieldNameGet.');
    }

    if (requestParameters.objectFieldName === null || requestParameters.objectFieldName === undefined) {
        throw new runtime.RequiredError('objectFieldName','Required parameter requestParameters.objectFieldName was null or undefined when calling metadataVobjectsObjectNameFieldsObjectFieldNameGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/vobjects/{object_name}/fields/{object_field_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_field_name"}}`, encodeURIComponent(String(requestParameters.objectFieldName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Field Metadata
*/
export function metadataVobjectsObjectNameFieldsObjectFieldNameGet<T>(requestParameters: MetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataVobjectsObjectNameFieldsObjectFieldNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Metadata
 */
function metadataVobjectsObjectNameGetRaw<T>(requestParameters: MetadataVobjectsObjectNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling metadataVobjectsObjectNameGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/vobjects/{object_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Metadata
*/
export function metadataVobjectsObjectNameGet<T>(requestParameters: MetadataVobjectsObjectNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataVobjectsObjectNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Page Layouts
 */
function metadataVobjectsObjectNamePageLayoutsGetRaw<T>(requestParameters: MetadataVobjectsObjectNamePageLayoutsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling metadataVobjectsObjectNamePageLayoutsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/vobjects/{object_name}/page_layouts`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Page Layouts
*/
export function metadataVobjectsObjectNamePageLayoutsGet<T>(requestParameters: MetadataVobjectsObjectNamePageLayoutsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataVobjectsObjectNamePageLayoutsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Page Layout Metadata
 */
function metadataVobjectsObjectNamePageLayoutsLayoutNameGetRaw<T>(requestParameters: MetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling metadataVobjectsObjectNamePageLayoutsLayoutNameGet.');
    }

    if (requestParameters.layoutName === null || requestParameters.layoutName === undefined) {
        throw new runtime.RequiredError('layoutName','Required parameter requestParameters.layoutName was null or undefined when calling metadataVobjectsObjectNamePageLayoutsLayoutNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/metadata/vobjects/{object_name}/page_layouts/{layout_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"layout_name"}}`, encodeURIComponent(String(requestParameters.layoutName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Page Layout Metadata
*/
export function metadataVobjectsObjectNamePageLayoutsLayoutNameGet<T>(requestParameters: MetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataVobjectsObjectNamePageLayoutsLayoutNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Email Notification Histories
 */
function notificationsHistoriesGetRaw<T>(requestParameters: NotificationsHistoriesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = requestParameters.startDate;
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = requestParameters.endDate;
    }


    if (requestParameters.allDates !== undefined) {
        queryParameters['all_dates'] = requestParameters.allDates;
    }


    if (requestParameters.formatResult !== undefined) {
        queryParameters['format_result'] = requestParameters.formatResult;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/notifications/histories`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Email Notification Histories
*/
export function notificationsHistoriesGet<T>(requestParameters: NotificationsHistoriesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return notificationsHistoriesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Bulk Workflow Action Details
 */
function objectWorkflowActionsActionGetRaw<T>(requestParameters: ObjectWorkflowActionsActionGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.action === null || requestParameters.action === undefined) {
        throw new runtime.RequiredError('action','Required parameter requestParameters.action was null or undefined when calling objectWorkflowActionsActionGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/object/workflow/actions/{action}`.replace(`{${"action"}}`, encodeURIComponent(String(requestParameters.action))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Bulk Workflow Action Details
*/
export function objectWorkflowActionsActionGet<T>(requestParameters: ObjectWorkflowActionsActionGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectWorkflowActionsActionGetRaw(requestParameters, requestConfig);
}

/**
 * Initiate Workflow Actions on Multiple Workflows
 */
function objectWorkflowActionsActionPostRaw<T>(requestParameters: ObjectWorkflowActionsActionPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.action === null || requestParameters.action === undefined) {
        throw new runtime.RequiredError('action','Required parameter requestParameters.action was null or undefined when calling objectWorkflowActionsActionPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/object/workflow/actions/{action}`.replace(`{${"action"}}`, encodeURIComponent(String(requestParameters.action))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Workflow Actions on Multiple Workflows
*/
export function objectWorkflowActionsActionPost<T>(requestParameters: ObjectWorkflowActionsActionPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectWorkflowActionsActionPostRaw(requestParameters, requestConfig);
}

/**
 * Cancel Workflow Tasks
 */
function objectWorkflowActionsCanceltasksPostRaw<T>(requestParameters: ObjectWorkflowActionsCanceltasksPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/object/workflow/actions/canceltasks`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Cancel Workflow Tasks
*/
export function objectWorkflowActionsCanceltasksPost<T>(requestParameters: ObjectWorkflowActionsCanceltasksPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectWorkflowActionsCanceltasksPostRaw(requestParameters, requestConfig);
}

/**
 * Cancel Workflows
 */
function objectWorkflowActionsCancelworkflowsPostRaw<T>(requestParameters: ObjectWorkflowActionsCancelworkflowsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/object/workflow/actions/cancelworkflows`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Cancel Workflows
*/
export function objectWorkflowActionsCancelworkflowsPost<T>(requestParameters: ObjectWorkflowActionsCancelworkflowsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectWorkflowActionsCancelworkflowsPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Bulk Workflow Actions
 */
function objectWorkflowActionsGetRaw<T>(requestParameters: ObjectWorkflowActionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/object/workflow/actions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Bulk Workflow Actions
*/
export function objectWorkflowActionsGet<T>(requestParameters: ObjectWorkflowActionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectWorkflowActionsGetRaw(requestParameters, requestConfig);
}

/**
 * Reassign Workflow Tasks
 */
function objectWorkflowActionsReassigntasksPostRaw<T>(requestParameters: ObjectWorkflowActionsReassigntasksPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/object/workflow/actions/reassigntasks`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Reassign Workflow Tasks
*/
export function objectWorkflowActionsReassigntasksPost<T>(requestParameters: ObjectWorkflowActionsReassigntasksPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectWorkflowActionsReassigntasksPostRaw(requestParameters, requestConfig);
}

/**
 * Replace Workflow Owner
 */
function objectWorkflowActionsReplaceworkflowownerPostRaw<T>(requestParameters: ObjectWorkflowActionsReplaceworkflowownerPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/object/workflow/actions/replaceworkflowowner`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Replace Workflow Owner
*/
export function objectWorkflowActionsReplaceworkflowownerPost<T>(requestParameters: ObjectWorkflowActionsReplaceworkflowownerPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectWorkflowActionsReplaceworkflowownerPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Export Results
 */
function objectsBindersActionsExportJobIdResultsGetRaw<T>(requestParameters: ObjectsBindersActionsExportJobIdResultsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling objectsBindersActionsExportJobIdResultsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/actions/export/{job_id}/results`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Export Results
*/
export function objectsBindersActionsExportJobIdResultsGet<T>(requestParameters: ObjectsBindersActionsExportJobIdResultsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersActionsExportJobIdResultsGetRaw(requestParameters, requestConfig);
}

/**
 * Export Binder (Latest Version)
 */
function objectsBindersBinderIdActionsExportPostRaw<T>(requestParameters: ObjectsBindersBinderIdActionsExportPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdActionsExportPost.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.source !== undefined) {
        queryParameters['source'] = requestParameters.source;
    }


    if (requestParameters.renditiontype !== undefined) {
        queryParameters['renditiontype'] = requestParameters.renditiontype;
    }


    if (requestParameters.docversion !== undefined) {
        queryParameters['docversion'] = requestParameters.docversion;
    }


    if (requestParameters.attachments !== undefined) {
        queryParameters['attachments'] = requestParameters.attachments;
    }


    if (requestParameters._export !== undefined) {
        queryParameters['export'] = requestParameters._export;
    }


    if (requestParameters.docfield !== undefined) {
        queryParameters['docfield'] = requestParameters.docfield;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/actions/export`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Export Binder (Latest Version)
*/
export function objectsBindersBinderIdActionsExportPost<T>(requestParameters: ObjectsBindersBinderIdActionsExportPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdActionsExportPostRaw(requestParameters, requestConfig);
}

/**
 * Refresh Binder Auto-Filing
 */
function objectsBindersBinderIdActionsPostRaw<T>(requestParameters: ObjectsBindersBinderIdActionsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdActionsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/actions`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Refresh Binder Auto-Filing
*/
export function objectsBindersBinderIdActionsPost<T>(requestParameters: ObjectsBindersBinderIdActionsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdActionsPostRaw(requestParameters, requestConfig);
}

/**
 * Update Binding Rule
 */
function objectsBindersBinderIdBindingRulePutRaw<T>(requestParameters: ObjectsBindersBinderIdBindingRulePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdBindingRulePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/binding_rule`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Binding Rule
*/
export function objectsBindersBinderIdBindingRulePut<T>(requestParameters: ObjectsBindersBinderIdBindingRulePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdBindingRulePutRaw(requestParameters, requestConfig);
}

/**
 * Delete Binder
 */
function objectsBindersBinderIdDeleteRaw<T>(requestParameters: ObjectsBindersBinderIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Binder
*/
export function objectsBindersBinderIdDelete<T>(requestParameters: ObjectsBindersBinderIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Update Binder Document Binding Rule
 */
function objectsBindersBinderIdDocumentsNodeIdBindingRulePutRaw<T>(requestParameters: ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdDocumentsNodeIdBindingRulePut.');
    }

    if (requestParameters.nodeId === null || requestParameters.nodeId === undefined) {
        throw new runtime.RequiredError('nodeId','Required parameter requestParameters.nodeId was null or undefined when calling objectsBindersBinderIdDocumentsNodeIdBindingRulePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/documents/{node_id}/binding_rule`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters.nodeId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Binder Document Binding Rule
*/
export function objectsBindersBinderIdDocumentsNodeIdBindingRulePut<T>(requestParameters: ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdDocumentsNodeIdBindingRulePutRaw(requestParameters, requestConfig);
}

/**
 * Add Document to Binder
 */
function objectsBindersBinderIdDocumentsPostRaw<T>(requestParameters: ObjectsBindersBinderIdDocumentsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdDocumentsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/documents`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Add Document to Binder
*/
export function objectsBindersBinderIdDocumentsPost<T>(requestParameters: ObjectsBindersBinderIdDocumentsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdDocumentsPostRaw(requestParameters, requestConfig);
}

/**
 * Remove Document from Binder
 */
function objectsBindersBinderIdDocumentsSectionIdDeleteRaw<T>(requestParameters: ObjectsBindersBinderIdDocumentsSectionIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdDocumentsSectionIdDelete.');
    }

    if (requestParameters.sectionId === null || requestParameters.sectionId === undefined) {
        throw new runtime.RequiredError('sectionId','Required parameter requestParameters.sectionId was null or undefined when calling objectsBindersBinderIdDocumentsSectionIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/documents/{section_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"section_id"}}`, encodeURIComponent(String(requestParameters.sectionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Remove Document from Binder
*/
export function objectsBindersBinderIdDocumentsSectionIdDelete<T>(requestParameters: ObjectsBindersBinderIdDocumentsSectionIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdDocumentsSectionIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Move Document in Binder
 */
function objectsBindersBinderIdDocumentsSectionIdPutRaw<T>(requestParameters: ObjectsBindersBinderIdDocumentsSectionIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdDocumentsSectionIdPut.');
    }

    if (requestParameters.sectionId === null || requestParameters.sectionId === undefined) {
        throw new runtime.RequiredError('sectionId','Required parameter requestParameters.sectionId was null or undefined when calling objectsBindersBinderIdDocumentsSectionIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/documents/{section_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"section_id"}}`, encodeURIComponent(String(requestParameters.sectionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Move Document in Binder
*/
export function objectsBindersBinderIdDocumentsSectionIdPut<T>(requestParameters: ObjectsBindersBinderIdDocumentsSectionIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdDocumentsSectionIdPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder
 */
function objectsBindersBinderIdGetRaw<T>(requestParameters: ObjectsBindersBinderIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.depth !== undefined) {
        queryParameters['depth'] = requestParameters.depth;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder
*/
export function objectsBindersBinderIdGet<T>(requestParameters: ObjectsBindersBinderIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdGetRaw(requestParameters, requestConfig);
}

/**
 * Create Binder Version
 */
function objectsBindersBinderIdPostRaw<T>(requestParameters: ObjectsBindersBinderIdPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Binder Version
*/
export function objectsBindersBinderIdPost<T>(requestParameters: ObjectsBindersBinderIdPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdPostRaw(requestParameters, requestConfig);
}

/**
 * Update Binder
 */
function objectsBindersBinderIdPutRaw<T>(requestParameters: ObjectsBindersBinderIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Binder
*/
export function objectsBindersBinderIdPut<T>(requestParameters: ObjectsBindersBinderIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdPutRaw(requestParameters, requestConfig);
}

/**
 * Remove Users & Groups from Roles on a Single Binder
 */
function objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRaw<T>(requestParameters: ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete.');
    }

    if (requestParameters.roleNameAndUserOrGroup === null || requestParameters.roleNameAndUserOrGroup === undefined) {
        throw new runtime.RequiredError('roleNameAndUserOrGroup','Required parameter requestParameters.roleNameAndUserOrGroup was null or undefined when calling objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete.');
    }

    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/roles/{role_name_and_user_or_group}/{id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"role_name_and_user_or_group"}}`, encodeURIComponent(String(requestParameters.roleNameAndUserOrGroup))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Remove Users & Groups from Roles on a Single Binder
*/
export function objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete<T>(requestParameters: ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Update Binder Section Binding Rule
 */
function objectsBindersBinderIdSectionsNodeIdBindingRulePutRaw<T>(requestParameters: ObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdSectionsNodeIdBindingRulePut.');
    }

    if (requestParameters.nodeId === null || requestParameters.nodeId === undefined) {
        throw new runtime.RequiredError('nodeId','Required parameter requestParameters.nodeId was null or undefined when calling objectsBindersBinderIdSectionsNodeIdBindingRulePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/sections/{node_id}/binding_rule`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters.nodeId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Binder Section Binding Rule
*/
export function objectsBindersBinderIdSectionsNodeIdBindingRulePut<T>(requestParameters: ObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdSectionsNodeIdBindingRulePutRaw(requestParameters, requestConfig);
}

/**
 * Update Binder Section
 */
function objectsBindersBinderIdSectionsNodeIdPutRaw<T>(requestParameters: ObjectsBindersBinderIdSectionsNodeIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdSectionsNodeIdPut.');
    }

    if (requestParameters.nodeId === null || requestParameters.nodeId === undefined) {
        throw new runtime.RequiredError('nodeId','Required parameter requestParameters.nodeId was null or undefined when calling objectsBindersBinderIdSectionsNodeIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/sections/{node_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"node_id"}}`, encodeURIComponent(String(requestParameters.nodeId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Binder Section
*/
export function objectsBindersBinderIdSectionsNodeIdPut<T>(requestParameters: ObjectsBindersBinderIdSectionsNodeIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdSectionsNodeIdPutRaw(requestParameters, requestConfig);
}

/**
 * Create Binder Section
 */
function objectsBindersBinderIdSectionsPostRaw<T>(requestParameters: ObjectsBindersBinderIdSectionsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdSectionsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/sections`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Binder Section
*/
export function objectsBindersBinderIdSectionsPost<T>(requestParameters: ObjectsBindersBinderIdSectionsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdSectionsPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Binder Section
 */
function objectsBindersBinderIdSectionsSectionIdDeleteRaw<T>(requestParameters: ObjectsBindersBinderIdSectionsSectionIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdSectionsSectionIdDelete.');
    }

    if (requestParameters.sectionId === null || requestParameters.sectionId === undefined) {
        throw new runtime.RequiredError('sectionId','Required parameter requestParameters.sectionId was null or undefined when calling objectsBindersBinderIdSectionsSectionIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/sections/{section_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"section_id"}}`, encodeURIComponent(String(requestParameters.sectionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Binder Section
*/
export function objectsBindersBinderIdSectionsSectionIdDelete<T>(requestParameters: ObjectsBindersBinderIdSectionsSectionIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdSectionsSectionIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Sections
 */
function objectsBindersBinderIdSectionsSectionIdGetRaw<T>(requestParameters: ObjectsBindersBinderIdSectionsSectionIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdSectionsSectionIdGet.');
    }

    if (requestParameters.sectionId === null || requestParameters.sectionId === undefined) {
        throw new runtime.RequiredError('sectionId','Required parameter requestParameters.sectionId was null or undefined when calling objectsBindersBinderIdSectionsSectionIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/sections/{section_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"section_id"}}`, encodeURIComponent(String(requestParameters.sectionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Sections
*/
export function objectsBindersBinderIdSectionsSectionIdGet<T>(requestParameters: ObjectsBindersBinderIdSectionsSectionIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdSectionsSectionIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Binder Versions
 */
function objectsBindersBinderIdVersionsGetRaw<T>(requestParameters: ObjectsBindersBinderIdVersionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdVersionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/versions`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Binder Versions
*/
export function objectsBindersBinderIdVersionsGet<T>(requestParameters: ObjectsBindersBinderIdVersionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdVersionsGetRaw(requestParameters, requestConfig);
}

/**
 * Export Binder (Specific Version)
 */
function objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRaw<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.source !== undefined) {
        queryParameters['source'] = requestParameters.source;
    }


    if (requestParameters.renditiontype !== undefined) {
        queryParameters['renditiontype'] = requestParameters.renditiontype;
    }


    if (requestParameters.docversion !== undefined) {
        queryParameters['docversion'] = requestParameters.docversion;
    }


    if (requestParameters.attachments !== undefined) {
        queryParameters['attachments'] = requestParameters.attachments;
    }


    if (requestParameters._export !== undefined) {
        queryParameters['export'] = requestParameters._export;
    }


    if (requestParameters.docfield !== undefined) {
        queryParameters['docfield'] = requestParameters.docfield;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Export Binder (Specific Version)
*/
export function objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Binder Version
 */
function objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRaw<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Binder Version
*/
export function objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Version
 */
function objectsBindersBinderIdVersionsMajorVersionMinorVersionGetRaw<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Version
*/
export function objectsBindersBinderIdVersionsMajorVersionMinorVersionGet<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdVersionsMajorVersionMinorVersionGetRaw(requestParameters, requestConfig);
}

/**
 * Update Binder Version
 */
function objectsBindersBinderIdVersionsMajorVersionMinorVersionPutRaw<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionPut.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionPut.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Binder Version
*/
export function objectsBindersBinderIdVersionsMajorVersionMinorVersionPut<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdVersionsMajorVersionMinorVersionPutRaw(requestParameters, requestConfig);
}

/**
 * Create Binder Relationship
 */
function objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRaw<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Binder Relationship
*/
export function objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Binder Relationship
 */
function objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRaw<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
    }

    if (requestParameters.relationshipId === null || requestParameters.relationshipId === undefined) {
        throw new runtime.RequiredError('relationshipId','Required parameter requestParameters.relationshipId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"relationship_id"}}`, encodeURIComponent(String(requestParameters.relationshipId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Binder Relationship
*/
export function objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Relationship
 */
function objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRaw<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
    }

    if (requestParameters.relationshipId === null || requestParameters.relationshipId === undefined) {
        throw new runtime.RequiredError('relationshipId','Required parameter requestParameters.relationshipId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"relationship_id"}}`, encodeURIComponent(String(requestParameters.relationshipId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Relationship
*/
export function objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Version Section
 */
function objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRaw<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.binderId === null || requestParameters.binderId === undefined) {
        throw new runtime.RequiredError('binderId','Required parameter requestParameters.binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet.');
    }

    if (requestParameters.sectionId === null || requestParameters.sectionId === undefined) {
        throw new runtime.RequiredError('sectionId','Required parameter requestParameters.sectionId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/sections/{section_id}`.replace(`{${"binder_id"}}`, encodeURIComponent(String(requestParameters.binderId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"section_id"}}`, encodeURIComponent(String(requestParameters.sectionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Version Section
*/
export function objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet<T>(requestParameters: ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Binder Roles
 */
function objectsBindersIdRolesGetRaw<T>(requestParameters: ObjectsBindersIdRolesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsBindersIdRolesGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{id}/roles`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Binder Roles
*/
export function objectsBindersIdRolesGet<T>(requestParameters: ObjectsBindersIdRolesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersIdRolesGetRaw(requestParameters, requestConfig);
}

/**
 * Assign Users & Groups to Roles on a Single Binder
 */
function objectsBindersIdRolesPostRaw<T>(requestParameters: ObjectsBindersIdRolesPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsBindersIdRolesPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{id}/roles`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Assign Users & Groups to Roles on a Single Binder
*/
export function objectsBindersIdRolesPost<T>(requestParameters: ObjectsBindersIdRolesPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersIdRolesPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Role
 */
function objectsBindersIdRolesRoleNameGetRaw<T>(requestParameters: ObjectsBindersIdRolesRoleNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsBindersIdRolesRoleNameGet.');
    }

    if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
        throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling objectsBindersIdRolesRoleNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{id}/roles/{role_name}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"role_name"}}`, encodeURIComponent(String(requestParameters.roleName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Role
*/
export function objectsBindersIdRolesRoleNameGet<T>(requestParameters: ObjectsBindersIdRolesRoleNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersIdRolesRoleNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder User Actions
 */
function objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRaw<T>(requestParameters: ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder User Actions
*/
export function objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet<T>(requestParameters: ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Entry Criteria
 */
function objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRaw<T>(requestParameters: ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
    }

    if (requestParameters.nameV === null || requestParameters.nameV === undefined) {
        throw new runtime.RequiredError('nameV','Required parameter requestParameters.nameV was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"name__v"}}`, encodeURIComponent(String(requestParameters.nameV))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Entry Criteria
*/
export function objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet<T>(requestParameters: ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRaw(requestParameters, requestConfig);
}

/**
 * Initiate Binder User Action
 */
function objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRaw<T>(requestParameters: ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
    }

    if (requestParameters.nameV === null || requestParameters.nameV === undefined) {
        throw new runtime.RequiredError('nameV','Required parameter requestParameters.nameV was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"name__v"}}`, encodeURIComponent(String(requestParameters.nameV))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Binder User Action
*/
export function objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut<T>(requestParameters: ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve User Actions on Multiple Binders
 */
function objectsBindersLifecycleActionsPostRaw<T>(requestParameters: ObjectsBindersLifecycleActionsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/lifecycle_actions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve User Actions on Multiple Binders
*/
export function objectsBindersLifecycleActionsPost<T>(requestParameters: ObjectsBindersLifecycleActionsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersLifecycleActionsPostRaw(requestParameters, requestConfig);
}

/**
 * Initiate Bulk Binder User Actions
 */
function objectsBindersLifecycleActionsUserActionNamePutRaw<T>(requestParameters: ObjectsBindersLifecycleActionsUserActionNamePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.userActionName === null || requestParameters.userActionName === undefined) {
        throw new runtime.RequiredError('userActionName','Required parameter requestParameters.userActionName was null or undefined when calling objectsBindersLifecycleActionsUserActionNamePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/lifecycle_actions/{user_action_name}`.replace(`{${"user_action_name"}}`, encodeURIComponent(String(requestParameters.userActionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Bulk Binder User Actions
*/
export function objectsBindersLifecycleActionsUserActionNamePut<T>(requestParameters: ObjectsBindersLifecycleActionsUserActionNamePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersLifecycleActionsUserActionNamePutRaw(requestParameters, requestConfig);
}

/**
 * Create Binder
 */
function objectsBindersPostRaw<T>(requestParameters: ObjectsBindersPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.async !== undefined) {
        queryParameters['async'] = requestParameters.async;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Binder
*/
export function objectsBindersPost<T>(requestParameters: ObjectsBindersPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Template Collection
 */
function objectsBindersTemplatesGetRaw<T>(requestParameters: ObjectsBindersTemplatesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/templates`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Template Collection
*/
export function objectsBindersTemplatesGet<T>(requestParameters: ObjectsBindersTemplatesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersTemplatesGetRaw(requestParameters, requestConfig);
}

/**
 * Create Binder Template
 */
function objectsBindersTemplatesPostRaw<T>(requestParameters: ObjectsBindersTemplatesPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/templates`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Binder Template
*/
export function objectsBindersTemplatesPost<T>(requestParameters: ObjectsBindersTemplatesPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersTemplatesPostRaw(requestParameters, requestConfig);
}

/**
 * Update Binder Template
 */
function objectsBindersTemplatesPutRaw<T>(requestParameters: ObjectsBindersTemplatesPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/templates`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Binder Template
*/
export function objectsBindersTemplatesPut<T>(requestParameters: ObjectsBindersTemplatesPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersTemplatesPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Template Node Attributes
 */
function objectsBindersTemplatesTemplateNameBindernodesGetRaw<T>(requestParameters: ObjectsBindersTemplatesTemplateNameBindernodesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
        throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling objectsBindersTemplatesTemplateNameBindernodesGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/templates/{template_name}/bindernodes`.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters.templateName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Template Node Attributes
*/
export function objectsBindersTemplatesTemplateNameBindernodesGet<T>(requestParameters: ObjectsBindersTemplatesTemplateNameBindernodesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersTemplatesTemplateNameBindernodesGetRaw(requestParameters, requestConfig);
}

/**
 * Create Binder Template Node
 */
function objectsBindersTemplatesTemplateNameBindernodesPostRaw<T>(requestParameters: ObjectsBindersTemplatesTemplateNameBindernodesPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
        throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling objectsBindersTemplatesTemplateNameBindernodesPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/templates/{template_name}/bindernodes`.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters.templateName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Binder Template Node
*/
export function objectsBindersTemplatesTemplateNameBindernodesPost<T>(requestParameters: ObjectsBindersTemplatesTemplateNameBindernodesPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersTemplatesTemplateNameBindernodesPostRaw(requestParameters, requestConfig);
}

/**
 * Replace Binder Template Nodes
 */
function objectsBindersTemplatesTemplateNameBindernodesPutRaw<T>(requestParameters: ObjectsBindersTemplatesTemplateNameBindernodesPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
        throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling objectsBindersTemplatesTemplateNameBindernodesPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/templates/{template_name}/bindernodes`.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters.templateName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Replace Binder Template Nodes
*/
export function objectsBindersTemplatesTemplateNameBindernodesPut<T>(requestParameters: ObjectsBindersTemplatesTemplateNameBindernodesPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersTemplatesTemplateNameBindernodesPutRaw(requestParameters, requestConfig);
}

/**
 * Delete Binder Template
 */
function objectsBindersTemplatesTemplateNameDeleteRaw<T>(requestParameters: ObjectsBindersTemplatesTemplateNameDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
        throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling objectsBindersTemplatesTemplateNameDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/templates/{template_name}`.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters.templateName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Binder Template
*/
export function objectsBindersTemplatesTemplateNameDelete<T>(requestParameters: ObjectsBindersTemplatesTemplateNameDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersTemplatesTemplateNameDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Binder Template Attributes
 */
function objectsBindersTemplatesTemplateNameGetRaw<T>(requestParameters: ObjectsBindersTemplatesTemplateNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
        throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling objectsBindersTemplatesTemplateNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/binders/templates/{template_name}`.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters.templateName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Binder Template Attributes
*/
export function objectsBindersTemplatesTemplateNameGet<T>(requestParameters: ObjectsBindersTemplatesTemplateNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsBindersTemplatesTemplateNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Deleted Document IDs
 */
function objectsDeletionsDocumentsGetRaw<T>(requestParameters: ObjectsDeletionsDocumentsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = requestParameters.startDate;
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = requestParameters.endDate;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/deletions/documents`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Deleted Document IDs
*/
export function objectsDeletionsDocumentsGet<T>(requestParameters: ObjectsDeletionsDocumentsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDeletionsDocumentsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Deleted Object Record ID
 */
function objectsDeletionsVobjectsObjectNameGetRaw<T>(requestParameters: ObjectsDeletionsVobjectsObjectNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling objectsDeletionsVobjectsObjectNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/deletions/vobjects/{object_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Deleted Object Record ID
*/
export function objectsDeletionsVobjectsObjectNameGet<T>(requestParameters: ObjectsDeletionsVobjectsObjectNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDeletionsVobjectsObjectNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Document Workflows
 */
function objectsDocumentsActionsGetRaw<T>(requestParameters: ObjectsDocumentsActionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/actions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Document Workflows
*/
export function objectsDocumentsActionsGet<T>(requestParameters: ObjectsDocumentsActionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsActionsGetRaw(requestParameters, requestConfig);
}

/**
 * Download Controlled Copy Job Results
 */
function objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRaw<T>(requestParameters: ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.lifecycleAndStateAndAction === null || requestParameters.lifecycleAndStateAndAction === undefined) {
        throw new runtime.RequiredError('lifecycleAndStateAndAction','Required parameter requestParameters.lifecycleAndStateAndAction was null or undefined when calling objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet.');
    }

    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/actions/{lifecycle_and_state_and_action}/{job_id}/results`.replace(`{${"lifecycle_and_state_and_action"}}`, encodeURIComponent(String(requestParameters.lifecycleAndStateAndAction))).replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Controlled Copy Job Results
*/
export function objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet<T>(requestParameters: ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Workflow Details
 */
function objectsDocumentsActionsWorkflowNameGetRaw<T>(requestParameters: ObjectsDocumentsActionsWorkflowNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.workflowName === null || requestParameters.workflowName === undefined) {
        throw new runtime.RequiredError('workflowName','Required parameter requestParameters.workflowName was null or undefined when calling objectsDocumentsActionsWorkflowNameGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/actions/{workflow_name}`.replace(`{${"workflow_name"}}`, encodeURIComponent(String(requestParameters.workflowName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Workflow Details
*/
export function objectsDocumentsActionsWorkflowNameGet<T>(requestParameters: ObjectsDocumentsActionsWorkflowNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsActionsWorkflowNameGetRaw(requestParameters, requestConfig);
}

/**
 * Initiate Document Workflow
 */
function objectsDocumentsActionsWorkflowNamePostRaw<T>(requestParameters: ObjectsDocumentsActionsWorkflowNamePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.workflowName === null || requestParameters.workflowName === undefined) {
        throw new runtime.RequiredError('workflowName','Required parameter requestParameters.workflowName was null or undefined when calling objectsDocumentsActionsWorkflowNamePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/actions/{workflow_name}`.replace(`{${"workflow_name"}}`, encodeURIComponent(String(requestParameters.workflowName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Document Workflow
*/
export function objectsDocumentsActionsWorkflowNamePost<T>(requestParameters: ObjectsDocumentsActionsWorkflowNamePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsActionsWorkflowNamePostRaw(requestParameters, requestConfig);
}

/**
 * Delete Annotations
 */
function objectsDocumentsAnnotationsBatchDeleteRaw<T>(requestParameters: ObjectsDocumentsAnnotationsBatchDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/annotations/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Annotations
*/
export function objectsDocumentsAnnotationsBatchDelete<T>(requestParameters: ObjectsDocumentsAnnotationsBatchDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsAnnotationsBatchDeleteRaw(requestParameters, requestConfig);
}

/**
 * Create Multiple Annotations
 */
function objectsDocumentsAnnotationsBatchPostRaw<T>(requestParameters: ObjectsDocumentsAnnotationsBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
        throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling objectsDocumentsAnnotationsBatchPost.');
    }

    if (requestParameters.contentType === null || requestParameters.contentType === undefined) {
        throw new runtime.RequiredError('contentType','Required parameter requestParameters.contentType was null or undefined when calling objectsDocumentsAnnotationsBatchPost.');
    }

    if (requestParameters.accept === null || requestParameters.accept === undefined) {
        throw new runtime.RequiredError('accept','Required parameter requestParameters.accept was null or undefined when calling objectsDocumentsAnnotationsBatchPost.');
    }

    if (requestParameters.xVaultAPIClientID === null || requestParameters.xVaultAPIClientID === undefined) {
        throw new runtime.RequiredError('xVaultAPIClientID','Required parameter requestParameters.xVaultAPIClientID was null or undefined when calling objectsDocumentsAnnotationsBatchPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/annotations/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Multiple Annotations
*/
export function objectsDocumentsAnnotationsBatchPost<T>(requestParameters: ObjectsDocumentsAnnotationsBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsAnnotationsBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Update Annotations
 */
function objectsDocumentsAnnotationsBatchPutRaw<T>(requestParameters: ObjectsDocumentsAnnotationsBatchPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/annotations/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Annotations
*/
export function objectsDocumentsAnnotationsBatchPut<T>(requestParameters: ObjectsDocumentsAnnotationsBatchPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsAnnotationsBatchPutRaw(requestParameters, requestConfig);
}

/**
 * Add Annotation Replies
 */
function objectsDocumentsAnnotationsRepliesBatchPostRaw<T>(requestParameters: ObjectsDocumentsAnnotationsRepliesBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/annotations/replies/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Add Annotation Replies
*/
export function objectsDocumentsAnnotationsRepliesBatchPost<T>(requestParameters: ObjectsDocumentsAnnotationsRepliesBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsAnnotationsRepliesBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Multiple Document Attachments
 */
function objectsDocumentsAttachmentsBatchDeleteRaw<T>(requestParameters: ObjectsDocumentsAttachmentsBatchDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/attachments/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Multiple Document Attachments
*/
export function objectsDocumentsAttachmentsBatchDelete<T>(requestParameters: ObjectsDocumentsAttachmentsBatchDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsAttachmentsBatchDeleteRaw(requestParameters, requestConfig);
}

/**
 * Create Multiple Document Attachments
 */
function objectsDocumentsAttachmentsBatchPostRaw<T>(requestParameters: ObjectsDocumentsAttachmentsBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/attachments/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Multiple Document Attachments
*/
export function objectsDocumentsAttachmentsBatchPost<T>(requestParameters: ObjectsDocumentsAttachmentsBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsAttachmentsBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Update Multiple Document Attachment Descriptions
 */
function objectsDocumentsAttachmentsBatchPutRaw<T>(requestParameters: ObjectsDocumentsAttachmentsBatchPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/attachments/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Multiple Document Attachment Descriptions
*/
export function objectsDocumentsAttachmentsBatchPut<T>(requestParameters: ObjectsDocumentsAttachmentsBatchPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsAttachmentsBatchPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Export Results
 */
function objectsDocumentsBatchActionsFileextractJobIdResultsGetRaw<T>(requestParameters: ObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling objectsDocumentsBatchActionsFileextractJobIdResultsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/batch/actions/fileextract/{job_id}/results`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Export Results
*/
export function objectsDocumentsBatchActionsFileextractJobIdResultsGet<T>(requestParameters: ObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsBatchActionsFileextractJobIdResultsGetRaw(requestParameters, requestConfig);
}

/**
 * Export Documents
 */
function objectsDocumentsBatchActionsFileextractPostRaw<T>(requestParameters: ObjectsDocumentsBatchActionsFileextractPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.source !== undefined) {
        queryParameters['source'] = requestParameters.source;
    }


    if (requestParameters.renditions !== undefined) {
        queryParameters['renditions'] = requestParameters.renditions;
    }


    if (requestParameters.allversions !== undefined) {
        queryParameters['allversions'] = requestParameters.allversions;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/batch/actions/fileextract`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Export Documents
*/
export function objectsDocumentsBatchActionsFileextractPost<T>(requestParameters: ObjectsDocumentsBatchActionsFileextractPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsBatchActionsFileextractPostRaw(requestParameters, requestConfig);
}

/**
 * Reclassify Multiple Documents
 */
function objectsDocumentsBatchActionsReclassifyPutRaw<T>(requestParameters: ObjectsDocumentsBatchActionsReclassifyPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/batch/actions/reclassify`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Reclassify Multiple Documents
*/
export function objectsDocumentsBatchActionsReclassifyPut<T>(requestParameters: ObjectsDocumentsBatchActionsReclassifyPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsBatchActionsReclassifyPutRaw(requestParameters, requestConfig);
}

/**
 * Update Multiple Document Renditions
 */
function objectsDocumentsBatchActionsRerenderPostRaw<T>(requestParameters: ObjectsDocumentsBatchActionsRerenderPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/batch/actions/rerender`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Multiple Document Renditions
*/
export function objectsDocumentsBatchActionsRerenderPost<T>(requestParameters: ObjectsDocumentsBatchActionsRerenderPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsBatchActionsRerenderPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Multiple Documents
 */
function objectsDocumentsBatchDeleteRaw<T>(requestParameters: ObjectsDocumentsBatchDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.idParam !== undefined) {
        queryParameters['idParam'] = requestParameters.idParam;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Multiple Documents
*/
export function objectsDocumentsBatchDelete<T>(requestParameters: ObjectsDocumentsBatchDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsBatchDeleteRaw(requestParameters, requestConfig);
}

/**
 * Undo Collaborative Authoring Checkout
 */
function objectsDocumentsBatchLockDeleteRaw<T>(requestParameters: ObjectsDocumentsBatchLockDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/batch/lock`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Undo Collaborative Authoring Checkout
*/
export function objectsDocumentsBatchLockDelete<T>(requestParameters: ObjectsDocumentsBatchLockDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsBatchLockDeleteRaw(requestParameters, requestConfig);
}

/**
 * Create Multiple Documents
 */
function objectsDocumentsBatchPostRaw<T>(requestParameters: ObjectsDocumentsBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Multiple Documents
*/
export function objectsDocumentsBatchPost<T>(requestParameters: ObjectsDocumentsBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Update Multiple Documents
 */
function objectsDocumentsBatchPutRaw<T>(requestParameters: ObjectsDocumentsBatchPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Multiple Documents
*/
export function objectsDocumentsBatchPut<T>(requestParameters: ObjectsDocumentsBatchPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsBatchPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Anchor IDs
 */
function objectsDocumentsDocIdAnchorsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAnchorsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAnchorsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/anchors`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Anchor IDs
*/
export function objectsDocumentsDocIdAnchorsGet<T>(requestParameters: ObjectsDocumentsDocIdAnchorsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAnchorsGetRaw(requestParameters, requestConfig);
}

/**
 * Export Document Annotations to PDF
 */
function objectsDocumentsDocIdAnnotationsFileGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAnnotationsFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAnnotationsFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/annotations/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Export Document Annotations to PDF
*/
export function objectsDocumentsDocIdAnnotationsFileGet<T>(requestParameters: ObjectsDocumentsDocIdAnnotationsFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAnnotationsFileGetRaw(requestParameters, requestConfig);
}

/**
 * Import Document Annotations from PDF
 */
function objectsDocumentsDocIdAnnotationsFilePostRaw<T>(requestParameters: ObjectsDocumentsDocIdAnnotationsFilePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAnnotationsFilePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/annotations/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Import Document Annotations from PDF
*/
export function objectsDocumentsDocIdAnnotationsFilePost<T>(requestParameters: ObjectsDocumentsDocIdAnnotationsFilePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAnnotationsFilePostRaw(requestParameters, requestConfig);
}

/**
 * Delete Single Document Attachment
 */
function objectsDocumentsDocIdAttachmentsAttachmentIdDeleteRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdDelete.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/{attachment_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Single Document Attachment
*/
export function objectsDocumentsDocIdAttachmentsAttachmentIdDelete<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsAttachmentIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Download Document Attachment
 */
function objectsDocumentsDocIdAttachmentsAttachmentIdFileGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdFileGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/{attachment_id}/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Document Attachment
*/
export function objectsDocumentsDocIdAttachmentsAttachmentIdFileGet<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsAttachmentIdFileGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Attachment Metadata
 */
function objectsDocumentsDocIdAttachmentsAttachmentIdGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/{attachment_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Attachment Metadata
*/
export function objectsDocumentsDocIdAttachmentsAttachmentIdGet<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsAttachmentIdGetRaw(requestParameters, requestConfig);
}

/**
 * Update Document Attachment Description
 */
function objectsDocumentsDocIdAttachmentsAttachmentIdPutRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdPut.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/{attachment_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Document Attachment Description
*/
export function objectsDocumentsDocIdAttachmentsAttachmentIdPut<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsAttachmentIdPutRaw(requestParameters, requestConfig);
}

/**
 * Delete Single Document Attachment Version
 */
function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Single Document Attachment Version
*/
export function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRaw(requestParameters, requestConfig);
}

/**
 * Download Document Attachment Version
 */
function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Document Attachment Version
*/
export function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Attachment Version Metadata
 */
function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Attachment Version Metadata
*/
export function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRaw(requestParameters, requestConfig);
}

/**
 * Restore Document Attachment Version
 */
function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.restore !== undefined) {
        queryParameters['restore'] = requestParameters.restore;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Restore Document Attachment Version
*/
export function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Attachment Versions
 */
function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/{attachment_id}/versions`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Attachment Versions
*/
export function objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRaw(requestParameters, requestConfig);
}

/**
 * Download All Document Attachments
 */
function objectsDocumentsDocIdAttachmentsFileGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download All Document Attachments
*/
export function objectsDocumentsDocIdAttachmentsFileGet<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsFileGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Attachments
 */
function objectsDocumentsDocIdAttachmentsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Attachments
*/
export function objectsDocumentsDocIdAttachmentsGet<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsGetRaw(requestParameters, requestConfig);
}

/**
 * Create Document Attachment
 */
function objectsDocumentsDocIdAttachmentsPostRaw<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAttachmentsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/attachments`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Document Attachment
*/
export function objectsDocumentsDocIdAttachmentsPost<T>(requestParameters: ObjectsDocumentsDocIdAttachmentsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAttachmentsPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Complete Audit History for a Single Document
 */
function objectsDocumentsDocIdAudittrailGetRaw<T>(requestParameters: ObjectsDocumentsDocIdAudittrailGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdAudittrailGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = requestParameters.startDate;
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = requestParameters.endDate;
    }


    if (requestParameters.formatResult !== undefined) {
        queryParameters['format_result'] = requestParameters.formatResult;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.events !== undefined) {
        queryParameters['events'] = requestParameters.events;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/audittrail`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Complete Audit History for a Single Document
*/
export function objectsDocumentsDocIdAudittrailGet<T>(requestParameters: ObjectsDocumentsDocIdAudittrailGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdAudittrailGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Single Document
 */
function objectsDocumentsDocIdDeleteRaw<T>(requestParameters: ObjectsDocumentsDocIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Single Document
*/
export function objectsDocumentsDocIdDelete<T>(requestParameters: ObjectsDocumentsDocIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Events
 */
function objectsDocumentsDocIdEventsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdEventsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdEventsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/events`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Events
*/
export function objectsDocumentsDocIdEventsGet<T>(requestParameters: ObjectsDocumentsDocIdEventsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdEventsGetRaw(requestParameters, requestConfig);
}

/**
 * Download Document File
 */
function objectsDocumentsDocIdFileGetRaw<T>(requestParameters: ObjectsDocumentsDocIdFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdFileGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.lockDocument !== undefined) {
        queryParameters['lockDocument'] = requestParameters.lockDocument;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Document File
*/
export function objectsDocumentsDocIdFileGet<T>(requestParameters: ObjectsDocumentsDocIdFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdFileGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document
 */
function objectsDocumentsDocIdGetRaw<T>(requestParameters: ObjectsDocumentsDocIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document
*/
export function objectsDocumentsDocIdGet<T>(requestParameters: ObjectsDocumentsDocIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Document Lock
 */
function objectsDocumentsDocIdLockDeleteRaw<T>(requestParameters: ObjectsDocumentsDocIdLockDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdLockDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/lock`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Document Lock
*/
export function objectsDocumentsDocIdLockDelete<T>(requestParameters: ObjectsDocumentsDocIdLockDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdLockDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Lock
 */
function objectsDocumentsDocIdLockGetRaw<T>(requestParameters: ObjectsDocumentsDocIdLockGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdLockGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/lock`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Lock
*/
export function objectsDocumentsDocIdLockGet<T>(requestParameters: ObjectsDocumentsDocIdLockGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdLockGetRaw(requestParameters, requestConfig);
}

/**
 * Create Document Lock
 */
function objectsDocumentsDocIdLockPostRaw<T>(requestParameters: ObjectsDocumentsDocIdLockPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdLockPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/lock`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Document Lock
*/
export function objectsDocumentsDocIdLockPost<T>(requestParameters: ObjectsDocumentsDocIdLockPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdLockPostRaw(requestParameters, requestConfig);
}

/**
 * Download All Document Version Attachments
 */
function objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRaw<T>(requestParameters: ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/{major_version}/{minor_version}/attachments/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download All Document Version Attachments
*/
export function objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet<T>(requestParameters: ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRaw(requestParameters, requestConfig);
}

/**
 * Create Single Document Version
 */
function objectsDocumentsDocIdPostRaw<T>(requestParameters: ObjectsDocumentsDocIdPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdPost.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.suppressRendition !== undefined) {
        queryParameters['suppressRendition'] = requestParameters.suppressRendition;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Single Document Version
*/
export function objectsDocumentsDocIdPost<T>(requestParameters: ObjectsDocumentsDocIdPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdPostRaw(requestParameters, requestConfig);
}

/**
 * Update Single Document
 */
function objectsDocumentsDocIdPutRaw<T>(requestParameters: ObjectsDocumentsDocIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Single Document
*/
export function objectsDocumentsDocIdPut<T>(requestParameters: ObjectsDocumentsDocIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Renditions
 */
function objectsDocumentsDocIdRenditionsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdRenditionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdRenditionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/renditions`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Renditions
*/
export function objectsDocumentsDocIdRenditionsGet<T>(requestParameters: ObjectsDocumentsDocIdRenditionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdRenditionsGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Single Document Rendition
 */
function objectsDocumentsDocIdRenditionsRenditionTypeDeleteRaw<T>(requestParameters: ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypeDelete.');
    }

    if (requestParameters.renditionType === null || requestParameters.renditionType === undefined) {
        throw new runtime.RequiredError('renditionType','Required parameter requestParameters.renditionType was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypeDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/renditions/{rendition_type}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"rendition_type"}}`, encodeURIComponent(String(requestParameters.renditionType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Single Document Rendition
*/
export function objectsDocumentsDocIdRenditionsRenditionTypeDelete<T>(requestParameters: ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdRenditionsRenditionTypeDeleteRaw(requestParameters, requestConfig);
}

/**
 * Download Document Rendition File
 */
function objectsDocumentsDocIdRenditionsRenditionTypeGetRaw<T>(requestParameters: ObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypeGet.');
    }

    if (requestParameters.renditionType === null || requestParameters.renditionType === undefined) {
        throw new runtime.RequiredError('renditionType','Required parameter requestParameters.renditionType was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypeGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.steadyState !== undefined) {
        queryParameters['steadyState'] = requestParameters.steadyState;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/renditions/{rendition_type}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"rendition_type"}}`, encodeURIComponent(String(requestParameters.renditionType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Document Rendition File
*/
export function objectsDocumentsDocIdRenditionsRenditionTypeGet<T>(requestParameters: ObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdRenditionsRenditionTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Add Single Document Rendition
 */
function objectsDocumentsDocIdRenditionsRenditionTypePostRaw<T>(requestParameters: ObjectsDocumentsDocIdRenditionsRenditionTypePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypePost.');
    }

    if (requestParameters.renditionType === null || requestParameters.renditionType === undefined) {
        throw new runtime.RequiredError('renditionType','Required parameter requestParameters.renditionType was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/renditions/{rendition_type}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"rendition_type"}}`, encodeURIComponent(String(requestParameters.renditionType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Add Single Document Rendition
*/
export function objectsDocumentsDocIdRenditionsRenditionTypePost<T>(requestParameters: ObjectsDocumentsDocIdRenditionsRenditionTypePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdRenditionsRenditionTypePostRaw(requestParameters, requestConfig);
}

/**
 * Replace Document Rendition
 */
function objectsDocumentsDocIdRenditionsRenditionTypePutRaw<T>(requestParameters: ObjectsDocumentsDocIdRenditionsRenditionTypePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypePut.');
    }

    if (requestParameters.renditionType === null || requestParameters.renditionType === undefined) {
        throw new runtime.RequiredError('renditionType','Required parameter requestParameters.renditionType was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/renditions/{rendition_type}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"rendition_type"}}`, encodeURIComponent(String(requestParameters.renditionType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Replace Document Rendition
*/
export function objectsDocumentsDocIdRenditionsRenditionTypePut<T>(requestParameters: ObjectsDocumentsDocIdRenditionsRenditionTypePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdRenditionsRenditionTypePutRaw(requestParameters, requestConfig);
}

/**
 * Remove Users & Groups from Roles on a Single Document
 */
function objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRaw<T>(requestParameters: ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete.');
    }

    if (requestParameters.roleNameAndUserOrGroup === null || requestParameters.roleNameAndUserOrGroup === undefined) {
        throw new runtime.RequiredError('roleNameAndUserOrGroup','Required parameter requestParameters.roleNameAndUserOrGroup was null or undefined when calling objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete.');
    }

    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/roles/{role_name_and_user_or_group}/{id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"role_name_and_user_or_group"}}`, encodeURIComponent(String(requestParameters.roleNameAndUserOrGroup))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Remove Users & Groups from Roles on a Single Document
*/
export function objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete<T>(requestParameters: ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Version Attachments
 */
function objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/version/{major_version}/{minor_version}/attachments`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Version Attachments
*/
export function objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet<T>(requestParameters: ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Versions
 */
function objectsDocumentsDocIdVersionsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Versions
*/
export function objectsDocumentsDocIdVersionsGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsGetRaw(requestParameters, requestConfig);
}

/**
 * Read Annotations by ID
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet.');
    }

    if (requestParameters.annotationId === null || requestParameters.annotationId === undefined) {
        throw new runtime.RequiredError('annotationId','Required parameter requestParameters.annotationId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters.annotationId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Read Annotations by ID
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRaw(requestParameters, requestConfig);
}

/**
 * Read Replies of Parent Annotation
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet.');
    }

    if (requestParameters.annotationId === null || requestParameters.annotationId === undefined) {
        throw new runtime.RequiredError('annotationId','Required parameter requestParameters.annotationId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}/replies`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters.annotationId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Read Replies of Parent Annotation
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRaw(requestParameters, requestConfig);
}

/**
 * Export Document Version Annotations to PDF
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Export Document Version Annotations to PDF
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRaw(requestParameters, requestConfig);
}

/**
 * Import Document Version Annotations from PDF
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Import Document Version Annotations from PDF
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRaw(requestParameters, requestConfig);
}

/**
 * Read Annotations by Document Version and Type
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.annotationTypes !== undefined) {
        queryParameters['annotation_types'] = requestParameters.annotationTypes;
    }


    if (requestParameters.paginationId !== undefined) {
        queryParameters['pagination_id'] = requestParameters.paginationId;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Read Annotations by Document Version and Type
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRaw(requestParameters, requestConfig);
}

/**
 * Download Document Version Attachment Version
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Document Version Attachment Version
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Version Attachment Versions
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Version Attachment Versions
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Single Document Version
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Single Document Version
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Version Notes as CSV
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/doc-export-annotations-to-csv`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Version Notes as CSV
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRaw(requestParameters, requestConfig);
}

/**
 * Create Document Event
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/events`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Document Event
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Video Annotations
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/export-video-annotations`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Video Annotations
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRaw(requestParameters, requestConfig);
}

/**
 * Download Document Version File
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/file`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Document Version File
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Version
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Version
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRaw(requestParameters, requestConfig);
}

/**
 * Update Document Version
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Document Version
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Relationships
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Relationships
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRaw(requestParameters, requestConfig);
}

/**
 * Create Single Document Relationship
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Single Document Relationship
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Single Document Relationship
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
    }

    if (requestParameters.relationshipId === null || requestParameters.relationshipId === undefined) {
        throw new runtime.RequiredError('relationshipId','Required parameter requestParameters.relationshipId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"relationship_id"}}`, encodeURIComponent(String(requestParameters.relationshipId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Single Document Relationship
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Relationship
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
    }

    if (requestParameters.relationshipId === null || requestParameters.relationshipId === undefined) {
        throw new runtime.RequiredError('relationshipId','Required parameter requestParameters.relationshipId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"relationship_id"}}`, encodeURIComponent(String(requestParameters.relationshipId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Relationship
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Version Renditions
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Version Renditions
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Document Version Rendition
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete.');
    }

    if (requestParameters.renditionType === null || requestParameters.renditionType === undefined) {
        throw new runtime.RequiredError('renditionType','Required parameter requestParameters.renditionType was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"rendition_type"}}`, encodeURIComponent(String(requestParameters.renditionType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Document Version Rendition
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRaw(requestParameters, requestConfig);
}

/**
 * Download Document Version Rendition File
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet.');
    }

    if (requestParameters.renditionType === null || requestParameters.renditionType === undefined) {
        throw new runtime.RequiredError('renditionType','Required parameter requestParameters.renditionType was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"rendition_type"}}`, encodeURIComponent(String(requestParameters.renditionType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Document Version Rendition File
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Upload Document Version Rendition
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost.');
    }

    if (requestParameters.renditionType === null || requestParameters.renditionType === undefined) {
        throw new runtime.RequiredError('renditionType','Required parameter requestParameters.renditionType was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"rendition_type"}}`, encodeURIComponent(String(requestParameters.renditionType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Upload Document Version Rendition
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRaw(requestParameters, requestConfig);
}

/**
 * Replace Document Version Rendition
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut.');
    }

    if (requestParameters.renditionType === null || requestParameters.renditionType === undefined) {
        throw new runtime.RequiredError('renditionType','Required parameter requestParameters.renditionType was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"rendition_type"}}`, encodeURIComponent(String(requestParameters.renditionType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Replace Document Version Rendition
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRaw(requestParameters, requestConfig);
}

/**
 * Download Document Version Thumbnail File
 */
function objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRaw<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.docId === null || requestParameters.docId === undefined) {
        throw new runtime.RequiredError('docId','Required parameter requestParameters.docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/thumbnail`.replace(`{${"doc_id"}}`, encodeURIComponent(String(requestParameters.docId))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Document Version Thumbnail File
*/
export function objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet<T>(requestParameters: ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Documents
 */
function objectsDocumentsGetRaw<T>(requestParameters: ObjectsDocumentsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.namedFilter !== undefined) {
        queryParameters['named_filter'] = requestParameters.namedFilter;
    }


    if (requestParameters.scope !== undefined) {
        queryParameters['scope'] = requestParameters.scope;
    }


    if (requestParameters.versionscope !== undefined) {
        queryParameters['versionscope'] = requestParameters.versionscope;
    }


    if (requestParameters.search !== undefined) {
        queryParameters['search'] = requestParameters.search;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.sort !== undefined) {
        queryParameters['sort'] = requestParameters.sort;
    }


    if (requestParameters.start !== undefined) {
        queryParameters['start'] = requestParameters.start;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Documents
*/
export function objectsDocumentsGet<T>(requestParameters: ObjectsDocumentsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Document Roles
 */
function objectsDocumentsIdRolesGetRaw<T>(requestParameters: ObjectsDocumentsIdRolesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsDocumentsIdRolesGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{id}/roles`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Document Roles
*/
export function objectsDocumentsIdRolesGet<T>(requestParameters: ObjectsDocumentsIdRolesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsIdRolesGetRaw(requestParameters, requestConfig);
}

/**
 * Assign Users & Groups to Roles on a Single Document
 */
function objectsDocumentsIdRolesPostRaw<T>(requestParameters: ObjectsDocumentsIdRolesPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsDocumentsIdRolesPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{id}/roles`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Assign Users & Groups to Roles on a Single Document
*/
export function objectsDocumentsIdRolesPost<T>(requestParameters: ObjectsDocumentsIdRolesPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsIdRolesPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Role
 */
function objectsDocumentsIdRolesRoleNameGetRaw<T>(requestParameters: ObjectsDocumentsIdRolesRoleNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsDocumentsIdRolesRoleNameGet.');
    }

    if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
        throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling objectsDocumentsIdRolesRoleNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{id}/roles/{role_name}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"role_name"}}`, encodeURIComponent(String(requestParameters.roleName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Role
*/
export function objectsDocumentsIdRolesRoleNameGet<T>(requestParameters: ObjectsDocumentsIdRolesRoleNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsIdRolesRoleNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document User Actions
 */
function objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRaw<T>(requestParameters: ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document User Actions
*/
export function objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet<T>(requestParameters: ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Entry Criteria
 */
function objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRaw<T>(requestParameters: ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
    }

    if (requestParameters.nameV === null || requestParameters.nameV === undefined) {
        throw new runtime.RequiredError('nameV','Required parameter requestParameters.nameV was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"name__v"}}`, encodeURIComponent(String(requestParameters.nameV))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Entry Criteria
*/
export function objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet<T>(requestParameters: ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRaw(requestParameters, requestConfig);
}

/**
 * Initiate Document User Action
 */
function objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRaw<T>(requestParameters: ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
    }

    if (requestParameters.majorVersion === null || requestParameters.majorVersion === undefined) {
        throw new runtime.RequiredError('majorVersion','Required parameter requestParameters.majorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
    }

    if (requestParameters.minorVersion === null || requestParameters.minorVersion === undefined) {
        throw new runtime.RequiredError('minorVersion','Required parameter requestParameters.minorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
    }

    if (requestParameters.nameV === null || requestParameters.nameV === undefined) {
        throw new runtime.RequiredError('nameV','Required parameter requestParameters.nameV was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"major_version"}}`, encodeURIComponent(String(requestParameters.majorVersion))).replace(`{${"minor_version"}}`, encodeURIComponent(String(requestParameters.minorVersion))).replace(`{${"name__v"}}`, encodeURIComponent(String(requestParameters.nameV))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Document User Action
*/
export function objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut<T>(requestParameters: ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve User Actions on Multiple Documents
 */
function objectsDocumentsLifecycleActionsPostRaw<T>(requestParameters: ObjectsDocumentsLifecycleActionsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/lifecycle_actions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve User Actions on Multiple Documents
*/
export function objectsDocumentsLifecycleActionsPost<T>(requestParameters: ObjectsDocumentsLifecycleActionsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsLifecycleActionsPostRaw(requestParameters, requestConfig);
}

/**
 * Initiate Bulk Document User Actions
 */
function objectsDocumentsLifecycleActionsUserActionNamePutRaw<T>(requestParameters: ObjectsDocumentsLifecycleActionsUserActionNamePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.userActionName === null || requestParameters.userActionName === undefined) {
        throw new runtime.RequiredError('userActionName','Required parameter requestParameters.userActionName was null or undefined when calling objectsDocumentsLifecycleActionsUserActionNamePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/lifecycle_actions/{user_action_name}`.replace(`{${"user_action_name"}}`, encodeURIComponent(String(requestParameters.userActionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Bulk Document User Actions
*/
export function objectsDocumentsLifecycleActionsUserActionNamePut<T>(requestParameters: ObjectsDocumentsLifecycleActionsUserActionNamePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsLifecycleActionsUserActionNamePutRaw(requestParameters, requestConfig);
}

/**
 * Create Single Document
 */
function objectsDocumentsPostRaw<T>(requestParameters: ObjectsDocumentsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Single Document
*/
export function objectsDocumentsPost<T>(requestParameters: ObjectsDocumentsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Multiple Document Relationships
 */
function objectsDocumentsRelationshipsBatchDeleteRaw<T>(requestParameters: ObjectsDocumentsRelationshipsBatchDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/relationships/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Multiple Document Relationships
*/
export function objectsDocumentsRelationshipsBatchDelete<T>(requestParameters: ObjectsDocumentsRelationshipsBatchDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsRelationshipsBatchDeleteRaw(requestParameters, requestConfig);
}

/**
 * Create Multiple Document Relationships
 */
function objectsDocumentsRelationshipsBatchPostRaw<T>(requestParameters: ObjectsDocumentsRelationshipsBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/relationships/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Multiple Document Relationships
*/
export function objectsDocumentsRelationshipsBatchPost<T>(requestParameters: ObjectsDocumentsRelationshipsBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsRelationshipsBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Multiple Document Renditions
 */
function objectsDocumentsRenditionsBatchDeleteRaw<T>(requestParameters: ObjectsDocumentsRenditionsBatchDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/renditions/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Multiple Document Renditions
*/
export function objectsDocumentsRenditionsBatchDelete<T>(requestParameters: ObjectsDocumentsRenditionsBatchDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsRenditionsBatchDeleteRaw(requestParameters, requestConfig);
}

/**
 * Add Multiple Document Renditions
 */
function objectsDocumentsRenditionsBatchPostRaw<T>(requestParameters: ObjectsDocumentsRenditionsBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.idParam !== undefined) {
        queryParameters['idParam'] = requestParameters.idParam;
    }


    if (requestParameters.largeSizeAsset !== undefined) {
        queryParameters['largeSizeAsset'] = requestParameters.largeSizeAsset;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/renditions/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Add Multiple Document Renditions
*/
export function objectsDocumentsRenditionsBatchPost<T>(requestParameters: ObjectsDocumentsRenditionsBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsRenditionsBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Remove Users and Groups from Roles on Multiple Documents & Binders
 */
function objectsDocumentsRolesBatchDeleteRaw<T>(requestParameters: ObjectsDocumentsRolesBatchDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/roles/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Remove Users and Groups from Roles on Multiple Documents & Binders
*/
export function objectsDocumentsRolesBatchDelete<T>(requestParameters: ObjectsDocumentsRolesBatchDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsRolesBatchDeleteRaw(requestParameters, requestConfig);
}

/**
 * Assign Users & Groups to Roles on Multiple Documents & Binders
 */
function objectsDocumentsRolesBatchPostRaw<T>(requestParameters: ObjectsDocumentsRolesBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/roles/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Assign Users & Groups to Roles on Multiple Documents & Binders
*/
export function objectsDocumentsRolesBatchPost<T>(requestParameters: ObjectsDocumentsRolesBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsRolesBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Template Collection
 */
function objectsDocumentsTemplatesGetRaw<T>(requestParameters: ObjectsDocumentsTemplatesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/templates`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Template Collection
*/
export function objectsDocumentsTemplatesGet<T>(requestParameters: ObjectsDocumentsTemplatesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsTemplatesGetRaw(requestParameters, requestConfig);
}

/**
 * Create Single Document Template
 */
function objectsDocumentsTemplatesPostRaw<T>(requestParameters: ObjectsDocumentsTemplatesPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/templates`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Single Document Template
*/
export function objectsDocumentsTemplatesPost<T>(requestParameters: ObjectsDocumentsTemplatesPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsTemplatesPostRaw(requestParameters, requestConfig);
}

/**
 * Update Multiple Document Templates
 */
function objectsDocumentsTemplatesPutRaw<T>(requestParameters: ObjectsDocumentsTemplatesPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/templates`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Multiple Document Templates
*/
export function objectsDocumentsTemplatesPut<T>(requestParameters: ObjectsDocumentsTemplatesPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsTemplatesPutRaw(requestParameters, requestConfig);
}

/**
 * Delete Basic Document Template
 */
function objectsDocumentsTemplatesTemplateNameDeleteRaw<T>(requestParameters: ObjectsDocumentsTemplatesTemplateNameDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
        throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling objectsDocumentsTemplatesTemplateNameDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/templates/{template_name}`.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters.templateName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Basic Document Template
*/
export function objectsDocumentsTemplatesTemplateNameDelete<T>(requestParameters: ObjectsDocumentsTemplatesTemplateNameDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsTemplatesTemplateNameDeleteRaw(requestParameters, requestConfig);
}

/**
 * Download Document Template File
 */
function objectsDocumentsTemplatesTemplateNameFileGetRaw<T>(requestParameters: ObjectsDocumentsTemplatesTemplateNameFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
        throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling objectsDocumentsTemplatesTemplateNameFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/templates/{template_name}/file`.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters.templateName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Document Template File
*/
export function objectsDocumentsTemplatesTemplateNameFileGet<T>(requestParameters: ObjectsDocumentsTemplatesTemplateNameFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsTemplatesTemplateNameFileGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Document Template Attributes
 */
function objectsDocumentsTemplatesTemplateNameGetRaw<T>(requestParameters: ObjectsDocumentsTemplatesTemplateNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
        throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling objectsDocumentsTemplatesTemplateNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/templates/{template_name}`.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters.templateName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Document Template Attributes
*/
export function objectsDocumentsTemplatesTemplateNameGet<T>(requestParameters: ObjectsDocumentsTemplatesTemplateNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsTemplatesTemplateNameGetRaw(requestParameters, requestConfig);
}

/**
 * Update Single Document Template
 */
function objectsDocumentsTemplatesTemplateNamePutRaw<T>(requestParameters: ObjectsDocumentsTemplatesTemplateNamePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.templateName === null || requestParameters.templateName === undefined) {
        throw new runtime.RequiredError('templateName','Required parameter requestParameters.templateName was null or undefined when calling objectsDocumentsTemplatesTemplateNamePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/templates/{template_name}`.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters.templateName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Single Document Template
*/
export function objectsDocumentsTemplatesTemplateNamePut<T>(requestParameters: ObjectsDocumentsTemplatesTemplateNamePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsTemplatesTemplateNamePutRaw(requestParameters, requestConfig);
}

/**
 * Document Tokens
 */
function objectsDocumentsTokensPostRaw<T>(requestParameters: ObjectsDocumentsTokensPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/tokens`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Document Tokens
*/
export function objectsDocumentsTokensPost<T>(requestParameters: ObjectsDocumentsTokensPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsTokensPostRaw(requestParameters, requestConfig);
}

/**
 * Export Document Versions
 */
function objectsDocumentsVersionsBatchActionsFileextractPostRaw<T>(requestParameters: ObjectsDocumentsVersionsBatchActionsFileextractPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.source !== undefined) {
        queryParameters['source'] = requestParameters.source;
    }


    if (requestParameters.renditions !== undefined) {
        queryParameters['renditions'] = requestParameters.renditions;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/versions/batch/actions/fileextract`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Export Document Versions
*/
export function objectsDocumentsVersionsBatchActionsFileextractPost<T>(requestParameters: ObjectsDocumentsVersionsBatchActionsFileextractPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsVersionsBatchActionsFileextractPostRaw(requestParameters, requestConfig);
}

/**
 * Delete Multiple Document Versions
 */
function objectsDocumentsVersionsBatchDeleteRaw<T>(requestParameters: ObjectsDocumentsVersionsBatchDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.idParam !== undefined) {
        queryParameters['idParam'] = requestParameters.idParam;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/versions/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Multiple Document Versions
*/
export function objectsDocumentsVersionsBatchDelete<T>(requestParameters: ObjectsDocumentsVersionsBatchDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsVersionsBatchDeleteRaw(requestParameters, requestConfig);
}

/**
 * Create Multiple Document Versions
 */
function objectsDocumentsVersionsBatchPostRaw<T>(requestParameters: ObjectsDocumentsVersionsBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.idParam !== undefined) {
        queryParameters['idParam'] = requestParameters.idParam;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/documents/versions/batch`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Multiple Document Versions
*/
export function objectsDocumentsVersionsBatchPost<T>(requestParameters: ObjectsDocumentsVersionsBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDocumentsVersionsBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Domain Information
 */
function objectsDomainGetRaw<T>(requestParameters: ObjectsDomainGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.includeApplication !== undefined) {
        queryParameters['include_application'] = requestParameters.includeApplication;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/domain`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Domain Information
*/
export function objectsDomainGet<T>(requestParameters: ObjectsDomainGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDomainGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Domains
 */
function objectsDomainsGetRaw<T>(requestParameters: ObjectsDomainsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/domains`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Domains
*/
export function objectsDomainsGet<T>(requestParameters: ObjectsDomainsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsDomainsGetRaw(requestParameters, requestConfig);
}

/**
 * Add EDL Matched Documents
 */
function objectsEdlMatchedDocumentsBatchActionsAddPostRaw<T>(requestParameters: ObjectsEdlMatchedDocumentsBatchActionsAddPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/edl_matched_documents/batch/actions/add`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Add EDL Matched Documents
*/
export function objectsEdlMatchedDocumentsBatchActionsAddPost<T>(requestParameters: ObjectsEdlMatchedDocumentsBatchActionsAddPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsEdlMatchedDocumentsBatchActionsAddPostRaw(requestParameters, requestConfig);
}

/**
 * Remove EDL Matched Documents
 */
function objectsEdlMatchedDocumentsBatchActionsRemovePostRaw<T>(requestParameters: ObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/edl_matched_documents/batch/actions/remove`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Remove EDL Matched Documents
*/
export function objectsEdlMatchedDocumentsBatchActionsRemovePost<T>(requestParameters: ObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsEdlMatchedDocumentsBatchActionsRemovePostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Auto Managed Groups
 */
function objectsGroupsAutoGetRaw<T>(requestParameters: ObjectsGroupsAutoGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/groups/auto`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Auto Managed Groups
*/
export function objectsGroupsAutoGet<T>(requestParameters: ObjectsGroupsAutoGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsGroupsAutoGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Groups
 */
function objectsGroupsGetRaw<T>(requestParameters: ObjectsGroupsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.includeImplied !== undefined) {
        queryParameters['includeImplied'] = requestParameters.includeImplied;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/groups`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Groups
*/
export function objectsGroupsGet<T>(requestParameters: ObjectsGroupsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsGroupsGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Group
 */
function objectsGroupsGroupIdDeleteRaw<T>(requestParameters: ObjectsGroupsGroupIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
        throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling objectsGroupsGroupIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/groups/{group_id}`.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters.groupId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Group
*/
export function objectsGroupsGroupIdDelete<T>(requestParameters: ObjectsGroupsGroupIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsGroupsGroupIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Group
 */
function objectsGroupsGroupIdGetRaw<T>(requestParameters: ObjectsGroupsGroupIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
        throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling objectsGroupsGroupIdGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.includeImplied !== undefined) {
        queryParameters['includeImplied'] = requestParameters.includeImplied;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/groups/{group_id}`.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters.groupId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Group
*/
export function objectsGroupsGroupIdGet<T>(requestParameters: ObjectsGroupsGroupIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsGroupsGroupIdGetRaw(requestParameters, requestConfig);
}

/**
 * Update Group
 */
function objectsGroupsGroupIdPutRaw<T>(requestParameters: ObjectsGroupsGroupIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.groupId === null || requestParameters.groupId === undefined) {
        throw new runtime.RequiredError('groupId','Required parameter requestParameters.groupId was null or undefined when calling objectsGroupsGroupIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/groups/{group_id}`.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters.groupId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Group
*/
export function objectsGroupsGroupIdPut<T>(requestParameters: ObjectsGroupsGroupIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsGroupsGroupIdPutRaw(requestParameters, requestConfig);
}

/**
 * Create Group 
 */
function objectsGroupsPostRaw<T>(requestParameters: ObjectsGroupsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/groups`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Group 
*/
export function objectsGroupsPost<T>(requestParameters: ObjectsGroupsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsGroupsPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Application License Usage
 */
function objectsLicensesGetRaw<T>(requestParameters: ObjectsLicensesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/licenses`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Application License Usage
*/
export function objectsLicensesGet<T>(requestParameters: ObjectsLicensesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsLicensesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Multi-Record Workflows
 */
function objectsObjectworkflowsActionsGetRaw<T>(requestParameters: ObjectsObjectworkflowsActionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/actions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Multi-Record Workflows
*/
export function objectsObjectworkflowsActionsGet<T>(requestParameters: ObjectsObjectworkflowsActionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsActionsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Multi-Record Workflow Details
 */
function objectsObjectworkflowsActionsWorkflowNameGetRaw<T>(requestParameters: ObjectsObjectworkflowsActionsWorkflowNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.workflowName === null || requestParameters.workflowName === undefined) {
        throw new runtime.RequiredError('workflowName','Required parameter requestParameters.workflowName was null or undefined when calling objectsObjectworkflowsActionsWorkflowNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/actions/{workflow_name}`.replace(`{${"workflow_name"}}`, encodeURIComponent(String(requestParameters.workflowName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Multi-Record Workflow Details
*/
export function objectsObjectworkflowsActionsWorkflowNameGet<T>(requestParameters: ObjectsObjectworkflowsActionsWorkflowNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsActionsWorkflowNameGetRaw(requestParameters, requestConfig);
}

/**
 * Initiate Multi-Record Workflow
 */
function objectsObjectworkflowsActionsWorkflowNamePostRaw<T>(requestParameters: ObjectsObjectworkflowsActionsWorkflowNamePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.workflowName === null || requestParameters.workflowName === undefined) {
        throw new runtime.RequiredError('workflowName','Required parameter requestParameters.workflowName was null or undefined when calling objectsObjectworkflowsActionsWorkflowNamePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/actions/{workflow_name}`.replace(`{${"workflow_name"}}`, encodeURIComponent(String(requestParameters.workflowName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Multi-Record Workflow
*/
export function objectsObjectworkflowsActionsWorkflowNamePost<T>(requestParameters: ObjectsObjectworkflowsActionsWorkflowNamePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsActionsWorkflowNamePostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Workflows
 */
function objectsObjectworkflowsGetRaw<T>(requestParameters: ObjectsObjectworkflowsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.objectV !== undefined) {
        queryParameters['object__v'] = requestParameters.objectV;
    }


    if (requestParameters.recordIdV !== undefined) {
        queryParameters['record_id__v'] = requestParameters.recordIdV;
    }


    if (requestParameters.participant !== undefined) {
        queryParameters['participant'] = requestParameters.participant;
    }


    if (requestParameters.statusV !== undefined) {
        queryParameters['status__v'] = requestParameters.statusV;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Workflows
*/
export function objectsObjectworkflowsGet<T>(requestParameters: ObjectsObjectworkflowsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Workflow Tasks
 */
function objectsObjectworkflowsTasksGetRaw<T>(requestParameters: ObjectsObjectworkflowsTasksGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.objectV !== undefined) {
        queryParameters['object__v'] = requestParameters.objectV;
    }


    if (requestParameters.recordIdV !== undefined) {
        queryParameters['record_id__v'] = requestParameters.recordIdV;
    }


    if (requestParameters.assigneeV !== undefined) {
        queryParameters['assignee__v'] = requestParameters.assigneeV;
    }


    if (requestParameters.statusV !== undefined) {
        queryParameters['status__v'] = requestParameters.statusV;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Workflow Tasks
*/
export function objectsObjectworkflowsTasksGet<T>(requestParameters: ObjectsObjectworkflowsTasksGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksGetRaw(requestParameters, requestConfig);
}

/**
 * Accept Single Record Workflow Task
 */
function objectsObjectworkflowsTasksTaskIdActionsAcceptPostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsAcceptPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/accept`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Accept Single Record Workflow Task
*/
export function objectsObjectworkflowsTasksTaskIdActionsAcceptPost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsAcceptPostRaw(requestParameters, requestConfig);
}

/**
 * Cancel Workflow Task
 */
function objectsObjectworkflowsTasksTaskIdActionsCancelPostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsCancelPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/cancel`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Cancel Workflow Task
*/
export function objectsObjectworkflowsTasksTaskIdActionsCancelPost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsCancelPostRaw(requestParameters, requestConfig);
}

/**
 * Complete Single Record Workflow Task
 */
function objectsObjectworkflowsTasksTaskIdActionsCompletePostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsCompletePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/complete`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Complete Single Record Workflow Task
*/
export function objectsObjectworkflowsTasksTaskIdActionsCompletePost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsCompletePostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Workflow Task Actions
 */
function objectsObjectworkflowsTasksTaskIdActionsGetRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Workflow Task Actions
*/
export function objectsObjectworkflowsTasksTaskIdActionsGet<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsGetRaw(requestParameters, requestConfig);
}

/**
 * Accept Multi-item Workflow Task
 */
function objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsMdwacceptPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/mdwaccept`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Accept Multi-item Workflow Task
*/
export function objectsObjectworkflowsTasksTaskIdActionsMdwacceptPost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRaw(requestParameters, requestConfig);
}

/**
 * Complete Multi-item Workflow Task
 */
function objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsMdwcompletePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/mdwcomplete`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Complete Multi-item Workflow Task
*/
export function objectsObjectworkflowsTasksTaskIdActionsMdwcompletePost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRaw(requestParameters, requestConfig);
}

/**
 * Manage Multi-Item Workflow Content
 */
function objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/mdwmanagecontent`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Manage Multi-Item Workflow Content
*/
export function objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRaw(requestParameters, requestConfig);
}

/**
 * Reassign Multi-item Workflow Task
 */
function objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsMdwreassignPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/mdwreassign`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Reassign Multi-item Workflow Task
*/
export function objectsObjectworkflowsTasksTaskIdActionsMdwreassignPost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRaw(requestParameters, requestConfig);
}

/**
 * Reassign Single Record Workflow Task
 */
function objectsObjectworkflowsTasksTaskIdActionsReassignPostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsReassignPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/reassign`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Reassign Single Record Workflow Task
*/
export function objectsObjectworkflowsTasksTaskIdActionsReassignPost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsReassignPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Workflow Task Action Details
 */
function objectsObjectworkflowsTasksTaskIdActionsTaskActionGetRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsTaskActionGet.');
    }

    if (requestParameters.taskAction === null || requestParameters.taskAction === undefined) {
        throw new runtime.RequiredError('taskAction','Required parameter requestParameters.taskAction was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsTaskActionGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/{task_action}`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))).replace(`{${"task_action"}}`, encodeURIComponent(String(requestParameters.taskAction))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Workflow Task Action Details
*/
export function objectsObjectworkflowsTasksTaskIdActionsTaskActionGet<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsTaskActionGetRaw(requestParameters, requestConfig);
}

/**
 * Undo Workflow Task Acceptance
 */
function objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsUndoacceptPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/undoaccept`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Undo Workflow Task Acceptance
*/
export function objectsObjectworkflowsTasksTaskIdActionsUndoacceptPost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRaw(requestParameters, requestConfig);
}

/**
 * Update Workflow Task Due Date
 */
function objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}/actions/updateduedate`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Workflow Task Due Date
*/
export function objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Workflow Task Details
 */
function objectsObjectworkflowsTasksTaskIdGetRaw<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/tasks/{task_id}`.replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Workflow Task Details
*/
export function objectsObjectworkflowsTasksTaskIdGet<T>(requestParameters: ObjectsObjectworkflowsTasksTaskIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsTasksTaskIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Workflow Actions
 */
function objectsObjectworkflowsWorkflowIdActionsGetRaw<T>(requestParameters: ObjectsObjectworkflowsWorkflowIdActionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
        throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/{workflow_id}/actions`.replace(`{${"workflow_id"}}`, encodeURIComponent(String(requestParameters.workflowId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Workflow Actions
*/
export function objectsObjectworkflowsWorkflowIdActionsGet<T>(requestParameters: ObjectsObjectworkflowsWorkflowIdActionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsWorkflowIdActionsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Workflow Action Details
 */
function objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRaw<T>(requestParameters: ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
        throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsWorkflowActionGet.');
    }

    if (requestParameters.workflowAction === null || requestParameters.workflowAction === undefined) {
        throw new runtime.RequiredError('workflowAction','Required parameter requestParameters.workflowAction was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsWorkflowActionGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/{workflow_id}/actions/{workflow_action}`.replace(`{${"workflow_id"}}`, encodeURIComponent(String(requestParameters.workflowId))).replace(`{${"workflow_action"}}`, encodeURIComponent(String(requestParameters.workflowAction))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Workflow Action Details
*/
export function objectsObjectworkflowsWorkflowIdActionsWorkflowActionGet<T>(requestParameters: ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRaw(requestParameters, requestConfig);
}

/**
 * Initiate Workflow Action
 */
function objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRaw<T>(requestParameters: ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
        throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsWorkflowActionPost.');
    }

    if (requestParameters.workflowAction === null || requestParameters.workflowAction === undefined) {
        throw new runtime.RequiredError('workflowAction','Required parameter requestParameters.workflowAction was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsWorkflowActionPost.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.documentsSys !== undefined) {
        queryParameters['documents__sys'] = requestParameters.documentsSys;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/{workflow_id}/actions/{workflow_action}`.replace(`{${"workflow_id"}}`, encodeURIComponent(String(requestParameters.workflowId))).replace(`{${"workflow_action"}}`, encodeURIComponent(String(requestParameters.workflowAction))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Workflow Action
*/
export function objectsObjectworkflowsWorkflowIdActionsWorkflowActionPost<T>(requestParameters: ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Workflow Details
 */
function objectsObjectworkflowsWorkflowIdGetRaw<T>(requestParameters: ObjectsObjectworkflowsWorkflowIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.workflowId === null || requestParameters.workflowId === undefined) {
        throw new runtime.RequiredError('workflowId','Required parameter requestParameters.workflowId was null or undefined when calling objectsObjectworkflowsWorkflowIdGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/objectworkflows/{workflow_id}`.replace(`{${"workflow_id"}}`, encodeURIComponent(String(requestParameters.workflowId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Workflow Details
*/
export function objectsObjectworkflowsWorkflowIdGet<T>(requestParameters: ObjectsObjectworkflowsWorkflowIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsObjectworkflowsWorkflowIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Picklists
 */
function objectsPicklistsGetRaw<T>(requestParameters: ObjectsPicklistsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/picklists`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Picklists
*/
export function objectsPicklistsGet<T>(requestParameters: ObjectsPicklistsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsPicklistsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Picklist Values
 */
function objectsPicklistsPicklistNameGetRaw<T>(requestParameters: ObjectsPicklistsPicklistNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.picklistName === null || requestParameters.picklistName === undefined) {
        throw new runtime.RequiredError('picklistName','Required parameter requestParameters.picklistName was null or undefined when calling objectsPicklistsPicklistNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/picklists/{picklist_name}`.replace(`{${"picklist_name"}}`, encodeURIComponent(String(requestParameters.picklistName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Picklist Values
*/
export function objectsPicklistsPicklistNameGet<T>(requestParameters: ObjectsPicklistsPicklistNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsPicklistsPicklistNameGetRaw(requestParameters, requestConfig);
}

/**
 * Inactivate Picklist Value
 */
function objectsPicklistsPicklistNamePicklistValueNameDeleteRaw<T>(requestParameters: ObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.picklistName === null || requestParameters.picklistName === undefined) {
        throw new runtime.RequiredError('picklistName','Required parameter requestParameters.picklistName was null or undefined when calling objectsPicklistsPicklistNamePicklistValueNameDelete.');
    }

    if (requestParameters.picklistValueName === null || requestParameters.picklistValueName === undefined) {
        throw new runtime.RequiredError('picklistValueName','Required parameter requestParameters.picklistValueName was null or undefined when calling objectsPicklistsPicklistNamePicklistValueNameDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/picklists/{picklist_name}/{picklist_value_name}`.replace(`{${"picklist_name"}}`, encodeURIComponent(String(requestParameters.picklistName))).replace(`{${"picklist_value_name"}}`, encodeURIComponent(String(requestParameters.picklistValueName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Inactivate Picklist Value
*/
export function objectsPicklistsPicklistNamePicklistValueNameDelete<T>(requestParameters: ObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsPicklistsPicklistNamePicklistValueNameDeleteRaw(requestParameters, requestConfig);
}

/**
 * Update Picklist Value
 */
function objectsPicklistsPicklistNamePicklistValueNamePutRaw<T>(requestParameters: ObjectsPicklistsPicklistNamePicklistValueNamePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.picklistName === null || requestParameters.picklistName === undefined) {
        throw new runtime.RequiredError('picklistName','Required parameter requestParameters.picklistName was null or undefined when calling objectsPicklistsPicklistNamePicklistValueNamePut.');
    }

    if (requestParameters.picklistValueName === null || requestParameters.picklistValueName === undefined) {
        throw new runtime.RequiredError('picklistValueName','Required parameter requestParameters.picklistValueName was null or undefined when calling objectsPicklistsPicklistNamePicklistValueNamePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/picklists/{picklist_name}/{picklist_value_name}`.replace(`{${"picklist_name"}}`, encodeURIComponent(String(requestParameters.picklistName))).replace(`{${"picklist_value_name"}}`, encodeURIComponent(String(requestParameters.picklistValueName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Picklist Value
*/
export function objectsPicklistsPicklistNamePicklistValueNamePut<T>(requestParameters: ObjectsPicklistsPicklistNamePicklistValueNamePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsPicklistsPicklistNamePicklistValueNamePutRaw(requestParameters, requestConfig);
}

/**
 * Create Picklist Values
 */
function objectsPicklistsPicklistNamePostRaw<T>(requestParameters: ObjectsPicklistsPicklistNamePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.picklistName === null || requestParameters.picklistName === undefined) {
        throw new runtime.RequiredError('picklistName','Required parameter requestParameters.picklistName was null or undefined when calling objectsPicklistsPicklistNamePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/picklists/{picklist_name}`.replace(`{${"picklist_name"}}`, encodeURIComponent(String(requestParameters.picklistName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Picklist Values
*/
export function objectsPicklistsPicklistNamePost<T>(requestParameters: ObjectsPicklistsPicklistNamePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsPicklistsPicklistNamePostRaw(requestParameters, requestConfig);
}

/**
 * Update Picklist Value Label
 */
function objectsPicklistsPicklistNamePutRaw<T>(requestParameters: ObjectsPicklistsPicklistNamePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.picklistName === null || requestParameters.picklistName === undefined) {
        throw new runtime.RequiredError('picklistName','Required parameter requestParameters.picklistName was null or undefined when calling objectsPicklistsPicklistNamePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/picklists/{picklist_name}`.replace(`{${"picklist_name"}}`, encodeURIComponent(String(requestParameters.picklistName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Picklist Value Label
*/
export function objectsPicklistsPicklistNamePut<T>(requestParameters: ObjectsPicklistsPicklistNamePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsPicklistsPicklistNamePutRaw(requestParameters, requestConfig);
}

/**
 * Build Production Vault
 */
function objectsSandboxActionsBuildproductionPostRaw<T>(requestParameters: ObjectsSandboxActionsBuildproductionPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/actions/buildproduction`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Build Production Vault
*/
export function objectsSandboxActionsBuildproductionPost<T>(requestParameters: ObjectsSandboxActionsBuildproductionPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxActionsBuildproductionPostRaw(requestParameters, requestConfig);
}

/**
 * Promote to Production
 */
function objectsSandboxActionsPromoteproductionPostRaw<T>(requestParameters: ObjectsSandboxActionsPromoteproductionPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/actions/promoteproduction`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Promote to Production
*/
export function objectsSandboxActionsPromoteproductionPost<T>(requestParameters: ObjectsSandboxActionsPromoteproductionPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxActionsPromoteproductionPostRaw(requestParameters, requestConfig);
}

/**
 * Recheck Sandbox Usage Limit
 */
function objectsSandboxActionsRecheckusagePostRaw<T>(requestParameters: ObjectsSandboxActionsRecheckusagePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/actions/recheckusage`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Recheck Sandbox Usage Limit
*/
export function objectsSandboxActionsRecheckusagePost<T>(requestParameters: ObjectsSandboxActionsRecheckusagePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxActionsRecheckusagePostRaw(requestParameters, requestConfig);
}

/**
 * Change Sandbox Size
 */
function objectsSandboxBatchChangesizePostRaw<T>(requestParameters: ObjectsSandboxBatchChangesizePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/batch/changesize`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Change Sandbox Size
*/
export function objectsSandboxBatchChangesizePost<T>(requestParameters: ObjectsSandboxBatchChangesizePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxBatchChangesizePostRaw(requestParameters, requestConfig);
}

/**
 * Set Sandbox Entitlements
 */
function objectsSandboxEntitlementsSetPostRaw<T>(requestParameters: ObjectsSandboxEntitlementsSetPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/entitlements/set`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Set Sandbox Entitlements
*/
export function objectsSandboxEntitlementsSetPost<T>(requestParameters: ObjectsSandboxEntitlementsSetPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxEntitlementsSetPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Sandboxes
 */
function objectsSandboxGetRaw<T>(requestParameters: ObjectsSandboxGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Sandboxes
*/
export function objectsSandboxGet<T>(requestParameters: ObjectsSandboxGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Sandbox
 */
function objectsSandboxNameDeleteRaw<T>(requestParameters: ObjectsSandboxNameDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
        throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling objectsSandboxNameDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Sandbox
*/
export function objectsSandboxNameDelete<T>(requestParameters: ObjectsSandboxNameDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxNameDeleteRaw(requestParameters, requestConfig);
}

/**
 * Create or Refresh Sandbox
 */
function objectsSandboxPostRaw<T>(requestParameters: ObjectsSandboxPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create or Refresh Sandbox
*/
export function objectsSandboxPost<T>(requestParameters: ObjectsSandboxPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxPostRaw(requestParameters, requestConfig);
}

/**
 * Update Sandbox Snapshot
 */
function objectsSandboxSnapshotApiNameActionsUpdatePostRaw<T>(requestParameters: ObjectsSandboxSnapshotApiNameActionsUpdatePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.apiName === null || requestParameters.apiName === undefined) {
        throw new runtime.RequiredError('apiName','Required parameter requestParameters.apiName was null or undefined when calling objectsSandboxSnapshotApiNameActionsUpdatePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/snapshot/{api_name}/actions/update`.replace(`{${"api_name"}}`, encodeURIComponent(String(requestParameters.apiName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Sandbox Snapshot
*/
export function objectsSandboxSnapshotApiNameActionsUpdatePost<T>(requestParameters: ObjectsSandboxSnapshotApiNameActionsUpdatePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxSnapshotApiNameActionsUpdatePostRaw(requestParameters, requestConfig);
}

/**
 * Upgrade Sandbox Snapshot
 */
function objectsSandboxSnapshotApiNameActionsUpgradePostRaw<T>(requestParameters: ObjectsSandboxSnapshotApiNameActionsUpgradePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.apiName === null || requestParameters.apiName === undefined) {
        throw new runtime.RequiredError('apiName','Required parameter requestParameters.apiName was null or undefined when calling objectsSandboxSnapshotApiNameActionsUpgradePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/snapshot/{api_name}/actions/upgrade`.replace(`{${"api_name"}}`, encodeURIComponent(String(requestParameters.apiName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Upgrade Sandbox Snapshot
*/
export function objectsSandboxSnapshotApiNameActionsUpgradePost<T>(requestParameters: ObjectsSandboxSnapshotApiNameActionsUpgradePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxSnapshotApiNameActionsUpgradePostRaw(requestParameters, requestConfig);
}

/**
 * Delete Sandbox Snapshot
 */
function objectsSandboxSnapshotApiNameDeleteRaw<T>(requestParameters: ObjectsSandboxSnapshotApiNameDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.apiName === null || requestParameters.apiName === undefined) {
        throw new runtime.RequiredError('apiName','Required parameter requestParameters.apiName was null or undefined when calling objectsSandboxSnapshotApiNameDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/snapshot/{api_name}`.replace(`{${"api_name"}}`, encodeURIComponent(String(requestParameters.apiName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Sandbox Snapshot
*/
export function objectsSandboxSnapshotApiNameDelete<T>(requestParameters: ObjectsSandboxSnapshotApiNameDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxSnapshotApiNameDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Sandbox Snapshots
 */
function objectsSandboxSnapshotGetRaw<T>(requestParameters: ObjectsSandboxSnapshotGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/snapshot`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Sandbox Snapshots
*/
export function objectsSandboxSnapshotGet<T>(requestParameters: ObjectsSandboxSnapshotGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxSnapshotGetRaw(requestParameters, requestConfig);
}

/**
 * Create Sandbox Snapshot
 */
function objectsSandboxSnapshotPostRaw<T>(requestParameters: ObjectsSandboxSnapshotPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/snapshot`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Sandbox Snapshot
*/
export function objectsSandboxSnapshotPost<T>(requestParameters: ObjectsSandboxSnapshotPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxSnapshotPostRaw(requestParameters, requestConfig);
}

/**
 * Refresh Sandbox from Snapshot
 */
function objectsSandboxVaultIdActionsRefreshPostRaw<T>(requestParameters: ObjectsSandboxVaultIdActionsRefreshPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.vaultId === null || requestParameters.vaultId === undefined) {
        throw new runtime.RequiredError('vaultId','Required parameter requestParameters.vaultId was null or undefined when calling objectsSandboxVaultIdActionsRefreshPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/{vault_id}/actions/refresh`.replace(`{${"vault_id"}}`, encodeURIComponent(String(requestParameters.vaultId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Refresh Sandbox from Snapshot
*/
export function objectsSandboxVaultIdActionsRefreshPost<T>(requestParameters: ObjectsSandboxVaultIdActionsRefreshPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxVaultIdActionsRefreshPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Sandbox Details by ID
 */
function objectsSandboxVaultIdGetRaw<T>(requestParameters: ObjectsSandboxVaultIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.vaultId === null || requestParameters.vaultId === undefined) {
        throw new runtime.RequiredError('vaultId','Required parameter requestParameters.vaultId was null or undefined when calling objectsSandboxVaultIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/sandbox/{vault_id}`.replace(`{${"vault_id"}}`, encodeURIComponent(String(requestParameters.vaultId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Sandbox Details by ID
*/
export function objectsSandboxVaultIdGet<T>(requestParameters: ObjectsSandboxVaultIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSandboxVaultIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Security Policies
 */
function objectsSecuritypoliciesGetRaw<T>(requestParameters: ObjectsSecuritypoliciesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/securitypolicies`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Security Policies
*/
export function objectsSecuritypoliciesGet<T>(requestParameters: ObjectsSecuritypoliciesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSecuritypoliciesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Security Policy
 */
function objectsSecuritypoliciesSecurityPolicyNameGetRaw<T>(requestParameters: ObjectsSecuritypoliciesSecurityPolicyNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.securityPolicyName === null || requestParameters.securityPolicyName === undefined) {
        throw new runtime.RequiredError('securityPolicyName','Required parameter requestParameters.securityPolicyName was null or undefined when calling objectsSecuritypoliciesSecurityPolicyNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/securitypolicies/{security_policy_name}`.replace(`{${"security_policy_name"}}`, encodeURIComponent(String(requestParameters.securityPolicyName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Security Policy
*/
export function objectsSecuritypoliciesSecurityPolicyNameGet<T>(requestParameters: ObjectsSecuritypoliciesSecurityPolicyNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsSecuritypoliciesSecurityPolicyNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Users
 */
function objectsUsersGetRaw<T>(requestParameters: ObjectsUsersGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.vaults !== undefined) {
        queryParameters['vaults'] = requestParameters.vaults;
    }


    if (requestParameters.excludeVaultMembership !== undefined) {
        queryParameters['exclude_vault_membership'] = requestParameters.excludeVaultMembership;
    }


    if (requestParameters.excludeAppLicensing !== undefined) {
        queryParameters['exclude_app_licensing'] = requestParameters.excludeAppLicensing;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Users
*/
export function objectsUsersGet<T>(requestParameters: ObjectsUsersGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve User
 */
function objectsUsersIdGetRaw<T>(requestParameters: ObjectsUsersIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsUsersIdGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.excludeVaultMembership !== undefined) {
        queryParameters['exclude_vault_membership'] = requestParameters.excludeVaultMembership;
    }


    if (requestParameters.excludeAppLicensing !== undefined) {
        queryParameters['exclude_app_licensing'] = requestParameters.excludeAppLicensing;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve User
*/
export function objectsUsersIdGet<T>(requestParameters: ObjectsUsersIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve User Permissions
 */
function objectsUsersIdPermissionsGetRaw<T>(requestParameters: ObjectsUsersIdPermissionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsUsersIdPermissionsGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.filter !== undefined) {
        queryParameters['filter'] = requestParameters.filter;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/{id}/permissions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve User Permissions
*/
export function objectsUsersIdPermissionsGet<T>(requestParameters: ObjectsUsersIdPermissionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersIdPermissionsGetRaw(requestParameters, requestConfig);
}

/**
 * Update Single User
 */
function objectsUsersIdPutRaw<T>(requestParameters: ObjectsUsersIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling objectsUsersIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Single User
*/
export function objectsUsersIdPut<T>(requestParameters: ObjectsUsersIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersIdPutRaw(requestParameters, requestConfig);
}

/**
 * Validate Session User
 */
function objectsUsersMeGetRaw<T>(requestParameters: ObjectsUsersMeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.excludeVaultMembership !== undefined) {
        queryParameters['exclude_vault_membership'] = requestParameters.excludeVaultMembership;
    }


    if (requestParameters.excludeAppLicensing !== undefined) {
        queryParameters['exclude_app_licensing'] = requestParameters.excludeAppLicensing;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/me`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Validate Session User
*/
export function objectsUsersMeGet<T>(requestParameters: ObjectsUsersMeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersMeGetRaw(requestParameters, requestConfig);
}

/**
 * Change My Password
 */
function objectsUsersMePasswordPostRaw<T>(requestParameters: ObjectsUsersMePasswordPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/me/password`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Change My Password
*/
export function objectsUsersMePasswordPost<T>(requestParameters: ObjectsUsersMePasswordPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersMePasswordPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve My User Permissions
 */
function objectsUsersMePermissionsGetRaw<T>(requestParameters: ObjectsUsersMePermissionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.filter !== undefined) {
        queryParameters['filter'] = requestParameters.filter;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/me/permissions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve My User Permissions
*/
export function objectsUsersMePermissionsGet<T>(requestParameters: ObjectsUsersMePermissionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersMePermissionsGetRaw(requestParameters, requestConfig);
}

/**
 * Update My User
 */
function objectsUsersMePutRaw<T>(requestParameters: ObjectsUsersMePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/me`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update My User
*/
export function objectsUsersMePut<T>(requestParameters: ObjectsUsersMePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersMePutRaw(requestParameters, requestConfig);
}

/**
 * Create Single User
 */
function objectsUsersPostRaw<T>(requestParameters: ObjectsUsersPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Single User
*/
export function objectsUsersPost<T>(requestParameters: ObjectsUsersPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersPostRaw(requestParameters, requestConfig);
}

/**
 * Update Multiple Users
 */
function objectsUsersPutRaw<T>(requestParameters: ObjectsUsersPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Multiple Users
*/
export function objectsUsersPut<T>(requestParameters: ObjectsUsersPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersPutRaw(requestParameters, requestConfig);
}

/**
 * Disable User
 */
function objectsUsersUserIdDeleteRaw<T>(requestParameters: ObjectsUsersUserIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling objectsUsersUserIdDelete.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.domain !== undefined) {
        queryParameters['domain'] = requestParameters.domain;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/{user_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Disable User
*/
export function objectsUsersUserIdDelete<T>(requestParameters: ObjectsUsersUserIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersUserIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Update Vault Membership
 */
function objectsUsersUserIdVaultMembershipVaultIdPutRaw<T>(requestParameters: ObjectsUsersUserIdVaultMembershipVaultIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.userId === null || requestParameters.userId === undefined) {
        throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling objectsUsersUserIdVaultMembershipVaultIdPut.');
    }

    if (requestParameters.vaultId === null || requestParameters.vaultId === undefined) {
        throw new runtime.RequiredError('vaultId','Required parameter requestParameters.vaultId was null or undefined when calling objectsUsersUserIdVaultMembershipVaultIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/users/{user_id}/vault_membership/{vault_id}`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))).replace(`{${"vault_id"}}`, encodeURIComponent(String(requestParameters.vaultId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Vault Membership
*/
export function objectsUsersUserIdVaultMembershipVaultIdPut<T>(requestParameters: ObjectsUsersUserIdVaultMembershipVaultIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsUsersUserIdVaultMembershipVaultIdPutRaw(requestParameters, requestConfig);
}

/**
 * Vault Compare
 */
function objectsVaultActionsComparePostRaw<T>(requestParameters: ObjectsVaultActionsComparePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/vault/actions/compare`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Vault Compare
*/
export function objectsVaultActionsComparePost<T>(requestParameters: ObjectsVaultActionsComparePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsVaultActionsComparePostRaw(requestParameters, requestConfig);
}

/**
 * Vault Configuration Report
 */
function objectsVaultActionsConfigreportPostRaw<T>(requestParameters: ObjectsVaultActionsConfigreportPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/objects/vault/actions/configreport`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Vault Configuration Report
*/
export function objectsVaultActionsConfigreportPost<T>(requestParameters: ObjectsVaultActionsConfigreportPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return objectsVaultActionsConfigreportPostRaw(requestParameters, requestConfig);
}

/**
 * Component Definition Query
 */
function queryComponentsPostRaw<T>(requestParameters: QueryComponentsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/query/components`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Component Definition Query
*/
export function queryComponentsPost<T>(requestParameters: QueryComponentsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return queryComponentsPostRaw(requestParameters, requestConfig);
}

/**
 * Next Page URL
 */
function queryNextPagePostRaw<T>(requestParameters: QueryNextPagePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.nextPage === null || requestParameters.nextPage === undefined) {
        throw new runtime.RequiredError('nextPage','Required parameter requestParameters.nextPage was null or undefined when calling queryNextPagePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIDescribeQuery !== undefined && requestParameters.xVaultAPIDescribeQuery !== null) {
        headerParameters['X-VaultAPI-DescribeQuery'] = String(requestParameters.xVaultAPIDescribeQuery);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/query/{next_page}`.replace(`{${"next_page"}}`, encodeURIComponent(String(requestParameters.nextPage))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Next Page URL
*/
export function queryNextPagePost<T>(requestParameters: QueryNextPagePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return queryNextPagePostRaw(requestParameters, requestConfig);
}

/**
 * Submitting a Query
 */
function queryPostRaw<T>(requestParameters: QueryPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIDescribeQuery !== undefined && requestParameters.xVaultAPIDescribeQuery !== null) {
        headerParameters['X-VaultAPI-DescribeQuery'] = String(requestParameters.xVaultAPIDescribeQuery);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/query`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Submitting a Query
*/
export function queryPost<T>(requestParameters: QueryPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return queryPostRaw(requestParameters, requestConfig);
}

/**
 * Previous Page URL
 */
function queryPreviousPagePostRaw<T>(requestParameters: QueryPreviousPagePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.previousPage === null || requestParameters.previousPage === undefined) {
        throw new runtime.RequiredError('previousPage','Required parameter requestParameters.previousPage was null or undefined when calling queryPreviousPagePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIDescribeQuery !== undefined && requestParameters.xVaultAPIDescribeQuery !== null) {
        headerParameters['X-VaultAPI-DescribeQuery'] = String(requestParameters.xVaultAPIDescribeQuery);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/query/{previous_page}`.replace(`{${"previous_page"}}`, encodeURIComponent(String(requestParameters.previousPage))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Previous Page URL
*/
export function queryPreviousPagePost<T>(requestParameters: QueryPreviousPagePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return queryPreviousPagePostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Current User with SCIM
 */
function scimV2MeGetRaw<T>(requestParameters: ScimV2MeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.attributes !== undefined) {
        queryParameters['attributes'] = requestParameters.attributes;
    }


    if (requestParameters.excludedAttributes !== undefined) {
        queryParameters['excludedAttributes'] = requestParameters.excludedAttributes;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/Me`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Current User with SCIM
*/
export function scimV2MeGet<T>(requestParameters: ScimV2MeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2MeGetRaw(requestParameters, requestConfig);
}

/**
 * Update Current User with SCIM
 */
function scimV2MePutRaw<T>(requestParameters: ScimV2MePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.attributes !== undefined) {
        queryParameters['attributes'] = requestParameters.attributes;
    }


    if (requestParameters.excludedAttributes !== undefined) {
        queryParameters['excludedAttributes'] = requestParameters.excludedAttributes;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/Me`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Current User with SCIM
*/
export function scimV2MePut<T>(requestParameters: ScimV2MePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2MePutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All SCIM Resource Types
 */
function scimV2ResourceTypesGetRaw<T>(requestParameters: ScimV2ResourceTypesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/ResourceTypes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All SCIM Resource Types
*/
export function scimV2ResourceTypesGet<T>(requestParameters: ScimV2ResourceTypesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2ResourceTypesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Single SCIM Resource Type
 */
function scimV2ResourceTypesTypeGetRaw<T>(requestParameters: ScimV2ResourceTypesTypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.type === null || requestParameters.type === undefined) {
        throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling scimV2ResourceTypesTypeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/ResourceTypes/{type}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Single SCIM Resource Type
*/
export function scimV2ResourceTypesTypeGet<T>(requestParameters: ScimV2ResourceTypesTypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2ResourceTypesTypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All SCIM Schema Information
 */
function scimV2SchemasGetRaw<T>(requestParameters: ScimV2SchemasGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/Schemas`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All SCIM Schema Information
*/
export function scimV2SchemasGet<T>(requestParameters: ScimV2SchemasGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2SchemasGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Single SCIM Schema Information
 */
function scimV2SchemasIdGetRaw<T>(requestParameters: ScimV2SchemasIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling scimV2SchemasIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/Schemas/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Single SCIM Schema Information
*/
export function scimV2SchemasIdGet<T>(requestParameters: ScimV2SchemasIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2SchemasIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve SCIM Provider
 */
function scimV2ServiceProviderConfigGetRaw<T>(requestParameters: ScimV2ServiceProviderConfigGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/ServiceProviderConfig`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve SCIM Provider
*/
export function scimV2ServiceProviderConfigGet<T>(requestParameters: ScimV2ServiceProviderConfigGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2ServiceProviderConfigGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve SCIM Resources
 */
function scimV2TypeGetRaw<T>(requestParameters: ScimV2TypeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.type === null || requestParameters.type === undefined) {
        throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling scimV2TypeGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.filter !== undefined) {
        queryParameters['filter'] = requestParameters.filter;
    }


    if (requestParameters.attributes !== undefined) {
        queryParameters['attributes'] = requestParameters.attributes;
    }


    if (requestParameters.excludedAttributes !== undefined) {
        queryParameters['excludedAttributes'] = requestParameters.excludedAttributes;
    }


    if (requestParameters.sortBy !== undefined) {
        queryParameters['sortBy'] = requestParameters.sortBy;
    }


    if (requestParameters.sortOrder !== undefined) {
        queryParameters['sortOrder'] = requestParameters.sortOrder;
    }


    if (requestParameters.startIndex !== undefined) {
        queryParameters['startIndex'] = requestParameters.startIndex;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/{type}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve SCIM Resources
*/
export function scimV2TypeGet<T>(requestParameters: ScimV2TypeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2TypeGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Single SCIM Resource
 */
function scimV2TypeIdGetRaw<T>(requestParameters: ScimV2TypeIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.type === null || requestParameters.type === undefined) {
        throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling scimV2TypeIdGet.');
    }

    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling scimV2TypeIdGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.attributes !== undefined) {
        queryParameters['attributes'] = requestParameters.attributes;
    }


    if (requestParameters.excludedAttributes !== undefined) {
        queryParameters['excludedAttributes'] = requestParameters.excludedAttributes;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/{type}/{id}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Single SCIM Resource
*/
export function scimV2TypeIdGet<T>(requestParameters: ScimV2TypeIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2TypeIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Users with SCIM
 */
function scimV2UsersGetRaw<T>(requestParameters: ScimV2UsersGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.filter !== undefined) {
        queryParameters['filter'] = requestParameters.filter;
    }


    if (requestParameters.attributes !== undefined) {
        queryParameters['attributes'] = requestParameters.attributes;
    }


    if (requestParameters.excludedAttributes !== undefined) {
        queryParameters['excludedAttributes'] = requestParameters.excludedAttributes;
    }


    if (requestParameters.sortBy !== undefined) {
        queryParameters['sortBy'] = requestParameters.sortBy;
    }


    if (requestParameters.sortOrder !== undefined) {
        queryParameters['sortOrder'] = requestParameters.sortOrder;
    }


    if (requestParameters.count !== undefined) {
        queryParameters['count'] = requestParameters.count;
    }


    if (requestParameters.startIndex !== undefined) {
        queryParameters['startIndex'] = requestParameters.startIndex;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/Users`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Users with SCIM
*/
export function scimV2UsersGet<T>(requestParameters: ScimV2UsersGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2UsersGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Single User with SCIM
 */
function scimV2UsersIdGetRaw<T>(requestParameters: ScimV2UsersIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling scimV2UsersIdGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.filter !== undefined) {
        queryParameters['filter'] = requestParameters.filter;
    }


    if (requestParameters.attributes !== undefined) {
        queryParameters['attributes'] = requestParameters.attributes;
    }


    if (requestParameters.excludedAttributes !== undefined) {
        queryParameters['excludedAttributes'] = requestParameters.excludedAttributes;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/Users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Single User with SCIM
*/
export function scimV2UsersIdGet<T>(requestParameters: ScimV2UsersIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2UsersIdGetRaw(requestParameters, requestConfig);
}

/**
 * Update User with SCIM
 */
function scimV2UsersIdPutRaw<T>(requestParameters: ScimV2UsersIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling scimV2UsersIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/Users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update User with SCIM
*/
export function scimV2UsersIdPut<T>(requestParameters: ScimV2UsersIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2UsersIdPutRaw(requestParameters, requestConfig);
}

/**
 * Create User with SCIM
 */
function scimV2UsersPostRaw<T>(requestParameters: ScimV2UsersPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/scim/v2/Users`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create User with SCIM
*/
export function scimV2UsersPost<T>(requestParameters: ScimV2UsersPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return scimV2UsersPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Signing Certificate
 */
function servicesCertificateCertIdGetRaw<T>(requestParameters: ServicesCertificateCertIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.certId === null || requestParameters.certId === undefined) {
        throw new runtime.RequiredError('certId','Required parameter requestParameters.certId was null or undefined when calling servicesCertificateCertIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/certificate/{cert_id}`.replace(`{${"cert_id"}}`, encodeURIComponent(String(requestParameters.certId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Signing Certificate
*/
export function servicesCertificateCertIdGet<T>(requestParameters: ServicesCertificateCertIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesCertificateCertIdGetRaw(requestParameters, requestConfig);
}

/**
 * Disable Configuration Mode
 */
function servicesConfigurationModeActionsDisablePostRaw<T>(requestParameters: ServicesConfigurationModeActionsDisablePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/configuration_mode/actions/disable`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Disable Configuration Mode
*/
export function servicesConfigurationModeActionsDisablePost<T>(requestParameters: ServicesConfigurationModeActionsDisablePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesConfigurationModeActionsDisablePostRaw(requestParameters, requestConfig);
}

/**
 * Enable Configuration Mode
 */
function servicesConfigurationModeActionsEnablePostRaw<T>(requestParameters: ServicesConfigurationModeActionsEnablePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/configuration_mode/actions/enable`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Enable Configuration Mode
*/
export function servicesConfigurationModeActionsEnablePost<T>(requestParameters: ServicesConfigurationModeActionsEnablePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesConfigurationModeActionsEnablePostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Available Direct Data Files
 */
function servicesDirectdataFilesGetRaw<T>(requestParameters: ServicesDirectdataFilesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.extractType !== undefined) {
        queryParameters['extract_type'] = requestParameters.extractType;
    }


    if (requestParameters.startTime !== undefined) {
        queryParameters['start_time'] = requestParameters.startTime;
    }


    if (requestParameters.stopTime !== undefined) {
        queryParameters['stop_time'] = requestParameters.stopTime;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/directdata/files`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Available Direct Data Files
*/
export function servicesDirectdataFilesGet<T>(requestParameters: ServicesDirectdataFilesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesDirectdataFilesGetRaw(requestParameters, requestConfig);
}

/**
 * Download Direct Data File
 */
function servicesDirectdataFilesNameGetRaw<T>(requestParameters: ServicesDirectdataFilesNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.name === null || requestParameters.name === undefined) {
        throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling servicesDirectdataFilesNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/directdata/files/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Direct Data File
*/
export function servicesDirectdataFilesNameGet<T>(requestParameters: ServicesDirectdataFilesNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesDirectdataFilesNameGetRaw(requestParameters, requestConfig);
}

/**
 * Download Item Content
 */
function servicesFileStagingItemsContentItemGetRaw<T>(requestParameters: ServicesFileStagingItemsContentItemGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.item === null || requestParameters.item === undefined) {
        throw new runtime.RequiredError('item','Required parameter requestParameters.item was null or undefined when calling servicesFileStagingItemsContentItemGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.range !== undefined && requestParameters.range !== null) {
        headerParameters['Range'] = String(requestParameters.range);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/items/content/{item}`.replace(`{${"item"}}`, encodeURIComponent(String(requestParameters.item))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Item Content
*/
export function servicesFileStagingItemsContentItemGet<T>(requestParameters: ServicesFileStagingItemsContentItemGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingItemsContentItemGetRaw(requestParameters, requestConfig);
}

/**
 * Delete File or Folder
 */
function servicesFileStagingItemsItemDeleteRaw<T>(requestParameters: ServicesFileStagingItemsItemDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.item === null || requestParameters.item === undefined) {
        throw new runtime.RequiredError('item','Required parameter requestParameters.item was null or undefined when calling servicesFileStagingItemsItemDelete.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.recursive !== undefined) {
        queryParameters['recursive'] = requestParameters.recursive;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/items/{item}`.replace(`{${"item"}}`, encodeURIComponent(String(requestParameters.item))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete File or Folder
*/
export function servicesFileStagingItemsItemDelete<T>(requestParameters: ServicesFileStagingItemsItemDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingItemsItemDeleteRaw(requestParameters, requestConfig);
}

/**
 * List Items at a Path
 */
function servicesFileStagingItemsItemGetRaw<T>(requestParameters: ServicesFileStagingItemsItemGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.item === null || requestParameters.item === undefined) {
        throw new runtime.RequiredError('item','Required parameter requestParameters.item was null or undefined when calling servicesFileStagingItemsItemGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.recursive !== undefined) {
        queryParameters['recursive'] = requestParameters.recursive;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.formatResult !== undefined) {
        queryParameters['format_result'] = requestParameters.formatResult;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/items/{item}`.replace(`{${"item"}}`, encodeURIComponent(String(requestParameters.item))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* List Items at a Path
*/
export function servicesFileStagingItemsItemGet<T>(requestParameters: ServicesFileStagingItemsItemGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingItemsItemGetRaw(requestParameters, requestConfig);
}

/**
 * Update Folder or File
 */
function servicesFileStagingItemsItemPutRaw<T>(requestParameters: ServicesFileStagingItemsItemPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.item === null || requestParameters.item === undefined) {
        throw new runtime.RequiredError('item','Required parameter requestParameters.item was null or undefined when calling servicesFileStagingItemsItemPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/items/{item}`.replace(`{${"item"}}`, encodeURIComponent(String(requestParameters.item))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Folder or File
*/
export function servicesFileStagingItemsItemPut<T>(requestParameters: ServicesFileStagingItemsItemPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingItemsItemPutRaw(requestParameters, requestConfig);
}

/**
 * Create Folder or File
 */
function servicesFileStagingItemsPostRaw<T>(requestParameters: ServicesFileStagingItemsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentMD5 !== undefined && requestParameters.contentMD5 !== null) {
        headerParameters['Content-MD5'] = String(requestParameters.contentMD5);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/items`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Folder or File
*/
export function servicesFileStagingItemsPost<T>(requestParameters: ServicesFileStagingItemsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingItemsPostRaw(requestParameters, requestConfig);
}

/**
 * List Upload Sessions
 */
function servicesFileStagingUploadGetRaw<T>(requestParameters: ServicesFileStagingUploadGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/upload/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* List Upload Sessions
*/
export function servicesFileStagingUploadGet<T>(requestParameters: ServicesFileStagingUploadGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingUploadGetRaw(requestParameters, requestConfig);
}

/**
 * Create Resumable Upload Session
 */
function servicesFileStagingUploadPostRaw<T>(requestParameters: ServicesFileStagingUploadPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/upload`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Resumable Upload Session
*/
export function servicesFileStagingUploadPost<T>(requestParameters: ServicesFileStagingUploadPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingUploadPostRaw(requestParameters, requestConfig);
}

/**
 * Abort Upload Session
 */
function servicesFileStagingUploadUploadSessionIdDeleteRaw<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.uploadSessionId === null || requestParameters.uploadSessionId === undefined) {
        throw new runtime.RequiredError('uploadSessionId','Required parameter requestParameters.uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/upload/{upload_session_id}`.replace(`{${"upload_session_id"}}`, encodeURIComponent(String(requestParameters.uploadSessionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Abort Upload Session
*/
export function servicesFileStagingUploadUploadSessionIdDelete<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingUploadUploadSessionIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Get Upload Session Details
 */
function servicesFileStagingUploadUploadSessionIdGetRaw<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.uploadSessionId === null || requestParameters.uploadSessionId === undefined) {
        throw new runtime.RequiredError('uploadSessionId','Required parameter requestParameters.uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/upload/{upload_session_id}`.replace(`{${"upload_session_id"}}`, encodeURIComponent(String(requestParameters.uploadSessionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Get Upload Session Details
*/
export function servicesFileStagingUploadUploadSessionIdGet<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingUploadUploadSessionIdGetRaw(requestParameters, requestConfig);
}

/**
 * List File Parts Uploaded to Session
 */
function servicesFileStagingUploadUploadSessionIdPartsGetRaw<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdPartsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.uploadSessionId === null || requestParameters.uploadSessionId === undefined) {
        throw new runtime.RequiredError('uploadSessionId','Required parameter requestParameters.uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdPartsGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/upload/{upload_session_id}/parts`.replace(`{${"upload_session_id"}}`, encodeURIComponent(String(requestParameters.uploadSessionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* List File Parts Uploaded to Session
*/
export function servicesFileStagingUploadUploadSessionIdPartsGet<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdPartsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingUploadUploadSessionIdPartsGetRaw(requestParameters, requestConfig);
}

/**
 * Commit Upload Session
 */
function servicesFileStagingUploadUploadSessionIdPostRaw<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.uploadSessionId === null || requestParameters.uploadSessionId === undefined) {
        throw new runtime.RequiredError('uploadSessionId','Required parameter requestParameters.uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/upload/{upload_session_id}`.replace(`{${"upload_session_id"}}`, encodeURIComponent(String(requestParameters.uploadSessionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Commit Upload Session
*/
export function servicesFileStagingUploadUploadSessionIdPost<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingUploadUploadSessionIdPostRaw(requestParameters, requestConfig);
}

/**
 * Upload to a Session
 */
function servicesFileStagingUploadUploadSessionIdPutRaw<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.uploadSessionId === null || requestParameters.uploadSessionId === undefined) {
        throw new runtime.RequiredError('uploadSessionId','Required parameter requestParameters.uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIFilePartNumber !== undefined && requestParameters.xVaultAPIFilePartNumber !== null) {
        headerParameters['X-VaultAPI-FilePartNumber'] = String(requestParameters.xVaultAPIFilePartNumber);
    }

    if (requestParameters.contentMD5 !== undefined && requestParameters.contentMD5 !== null) {
        headerParameters['Content-MD5'] = String(requestParameters.contentMD5);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/file_staging/upload/{upload_session_id}`.replace(`{${"upload_session_id"}}`, encodeURIComponent(String(requestParameters.uploadSessionId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Upload to a Session
*/
export function servicesFileStagingUploadUploadSessionIdPut<T>(requestParameters: ServicesFileStagingUploadUploadSessionIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesFileStagingUploadUploadSessionIdPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Job Histories
 */
function servicesJobsHistoriesGetRaw<T>(requestParameters: ServicesJobsHistoriesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = requestParameters.startDate;
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = requestParameters.endDate;
    }


    if (requestParameters.status !== undefined) {
        queryParameters['status'] = requestParameters.status;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/jobs/histories`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Job Histories
*/
export function servicesJobsHistoriesGet<T>(requestParameters: ServicesJobsHistoriesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesJobsHistoriesGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Import Bulk Translation File Job Errors
 */
function servicesJobsJobIdErrorsGetRaw<T>(requestParameters: ServicesJobsJobIdErrorsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling servicesJobsJobIdErrorsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/jobs/{job_id}/errors`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Import Bulk Translation File Job Errors
*/
export function servicesJobsJobIdErrorsGet<T>(requestParameters: ServicesJobsJobIdErrorsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesJobsJobIdErrorsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Job Status
 */
function servicesJobsJobIdGetRaw<T>(requestParameters: ServicesJobsJobIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling servicesJobsJobIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/jobs/{job_id}`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Job Status
*/
export function servicesJobsJobIdGet<T>(requestParameters: ServicesJobsJobIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesJobsJobIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Import Bulk Translation File Job Summary
 */
function servicesJobsJobIdSummaryGetRaw<T>(requestParameters: ServicesJobsJobIdSummaryGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling servicesJobsJobIdSummaryGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/jobs/{job_id}/summary`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Import Bulk Translation File Job Summary
*/
export function servicesJobsJobIdSummaryGet<T>(requestParameters: ServicesJobsJobIdSummaryGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesJobsJobIdSummaryGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve SDK Job Tasks
 */
function servicesJobsJobIdTasksGetRaw<T>(requestParameters: ServicesJobsJobIdTasksGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling servicesJobsJobIdTasksGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/jobs/{job_id}/tasks`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve SDK Job Tasks
*/
export function servicesJobsJobIdTasksGet<T>(requestParameters: ServicesJobsJobIdTasksGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesJobsJobIdTasksGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Job Monitors
 */
function servicesJobsMonitorsGetRaw<T>(requestParameters: ServicesJobsMonitorsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = requestParameters.startDate;
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = requestParameters.endDate;
    }


    if (requestParameters.status !== undefined) {
        queryParameters['status'] = requestParameters.status;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/jobs/monitors`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Job Monitors
*/
export function servicesJobsMonitorsGet<T>(requestParameters: ServicesJobsMonitorsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesJobsMonitorsGetRaw(requestParameters, requestConfig);
}

/**
 * Start Job
 */
function servicesJobsStartNowJobIdPostRaw<T>(requestParameters: ServicesJobsStartNowJobIdPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling servicesJobsStartNowJobIdPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/jobs/start_now/{job_id}`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Start Job
*/
export function servicesJobsStartNowJobIdPost<T>(requestParameters: ServicesJobsStartNowJobIdPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesJobsStartNowJobIdPostRaw(requestParameters, requestConfig);
}

/**
 * Extract Data Files
 */
function servicesLoaderExtractPostRaw<T>(requestParameters: ServicesLoaderExtractPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/loader/extract`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Extract Data Files
*/
export function servicesLoaderExtractPost<T>(requestParameters: ServicesLoaderExtractPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesLoaderExtractPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Load Failure Log Results
 */
function servicesLoaderJobIdTasksTaskIdFailurelogGetRaw<T>(requestParameters: ServicesLoaderJobIdTasksTaskIdFailurelogGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling servicesLoaderJobIdTasksTaskIdFailurelogGet.');
    }

    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling servicesLoaderJobIdTasksTaskIdFailurelogGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/loader/{job_id}/tasks/{task_id}/failurelog`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))).replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Load Failure Log Results
*/
export function servicesLoaderJobIdTasksTaskIdFailurelogGet<T>(requestParameters: ServicesLoaderJobIdTasksTaskIdFailurelogGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesLoaderJobIdTasksTaskIdFailurelogGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Loader Extract Results
 */
function servicesLoaderJobIdTasksTaskIdResultsGetRaw<T>(requestParameters: ServicesLoaderJobIdTasksTaskIdResultsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling servicesLoaderJobIdTasksTaskIdResultsGet.');
    }

    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling servicesLoaderJobIdTasksTaskIdResultsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/loader/{job_id}/tasks/{task_id}/results`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))).replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Loader Extract Results
*/
export function servicesLoaderJobIdTasksTaskIdResultsGet<T>(requestParameters: ServicesLoaderJobIdTasksTaskIdResultsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesLoaderJobIdTasksTaskIdResultsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Loader Extract Renditions Results
 */
function servicesLoaderJobIdTasksTaskIdResultsRenditionsGetRaw<T>(requestParameters: ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling servicesLoaderJobIdTasksTaskIdResultsRenditionsGet.');
    }

    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling servicesLoaderJobIdTasksTaskIdResultsRenditionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/loader/{job_id}/tasks/{task_id}/results/renditions`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))).replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Loader Extract Renditions Results
*/
export function servicesLoaderJobIdTasksTaskIdResultsRenditionsGet<T>(requestParameters: ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesLoaderJobIdTasksTaskIdResultsRenditionsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Load Success Log Results
 */
function servicesLoaderJobIdTasksTaskIdSuccesslogGetRaw<T>(requestParameters: ServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling servicesLoaderJobIdTasksTaskIdSuccesslogGet.');
    }

    if (requestParameters.taskId === null || requestParameters.taskId === undefined) {
        throw new runtime.RequiredError('taskId','Required parameter requestParameters.taskId was null or undefined when calling servicesLoaderJobIdTasksTaskIdSuccesslogGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/loader/{job_id}/tasks/{task_id}/successlog`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))).replace(`{${"task_id"}}`, encodeURIComponent(String(requestParameters.taskId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Load Success Log Results
*/
export function servicesLoaderJobIdTasksTaskIdSuccesslogGet<T>(requestParameters: ServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesLoaderJobIdTasksTaskIdSuccesslogGetRaw(requestParameters, requestConfig);
}

/**
 * Load Data Objects
 */
function servicesLoaderLoadPostRaw<T>(requestParameters: ServicesLoaderLoadPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/loader/load`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Load Data Objects
*/
export function servicesLoaderLoadPost<T>(requestParameters: ServicesLoaderLoadPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesLoaderLoadPostRaw(requestParameters, requestConfig);
}

/**
 * Validate Package
 */
function servicesPackageActionsValidatePostRaw<T>(requestParameters: ServicesPackageActionsValidatePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/package/actions/validate`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Validate Package
*/
export function servicesPackageActionsValidatePost<T>(requestParameters: ServicesPackageActionsValidatePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesPackageActionsValidatePostRaw(requestParameters, requestConfig);
}

/**
 * Export Package
 */
function servicesPackagePostRaw<T>(requestParameters: ServicesPackagePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/package`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Export Package
*/
export function servicesPackagePost<T>(requestParameters: ServicesPackagePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesPackagePostRaw(requestParameters, requestConfig);
}

/**
 * Import Package
 */
function servicesPackagePutRaw<T>(requestParameters: ServicesPackagePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/package`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Import Package
*/
export function servicesPackagePut<T>(requestParameters: ServicesPackagePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesPackagePutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Queues
 */
function servicesQueuesGetRaw<T>(requestParameters: ServicesQueuesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/queues`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Queues
*/
export function servicesQueuesGet<T>(requestParameters: ServicesQueuesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesQueuesGetRaw(requestParameters, requestConfig);
}

/**
 * Disable Delivery
 */
function servicesQueuesQueueNameActionsDisableDeliveryPutRaw<T>(requestParameters: ServicesQueuesQueueNameActionsDisableDeliveryPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.queueName === null || requestParameters.queueName === undefined) {
        throw new runtime.RequiredError('queueName','Required parameter requestParameters.queueName was null or undefined when calling servicesQueuesQueueNameActionsDisableDeliveryPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/queues/{queue_name}/actions/disable_delivery`.replace(`{${"queue_name"}}`, encodeURIComponent(String(requestParameters.queueName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Disable Delivery
*/
export function servicesQueuesQueueNameActionsDisableDeliveryPut<T>(requestParameters: ServicesQueuesQueueNameActionsDisableDeliveryPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesQueuesQueueNameActionsDisableDeliveryPutRaw(requestParameters, requestConfig);
}

/**
 * Enable Delivery
 */
function servicesQueuesQueueNameActionsEnableDeliveryPutRaw<T>(requestParameters: ServicesQueuesQueueNameActionsEnableDeliveryPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.queueName === null || requestParameters.queueName === undefined) {
        throw new runtime.RequiredError('queueName','Required parameter requestParameters.queueName was null or undefined when calling servicesQueuesQueueNameActionsEnableDeliveryPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/queues/{queue_name}/actions/enable_delivery`.replace(`{${"queue_name"}}`, encodeURIComponent(String(requestParameters.queueName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Enable Delivery
*/
export function servicesQueuesQueueNameActionsEnableDeliveryPut<T>(requestParameters: ServicesQueuesQueueNameActionsEnableDeliveryPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesQueuesQueueNameActionsEnableDeliveryPutRaw(requestParameters, requestConfig);
}

/**
 * Reset Queue
 */
function servicesQueuesQueueNameActionsResetPutRaw<T>(requestParameters: ServicesQueuesQueueNameActionsResetPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.queueName === null || requestParameters.queueName === undefined) {
        throw new runtime.RequiredError('queueName','Required parameter requestParameters.queueName was null or undefined when calling servicesQueuesQueueNameActionsResetPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/queues/{queue_name}/actions/reset`.replace(`{${"queue_name"}}`, encodeURIComponent(String(requestParameters.queueName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Reset Queue
*/
export function servicesQueuesQueueNameActionsResetPut<T>(requestParameters: ServicesQueuesQueueNameActionsResetPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesQueuesQueueNameActionsResetPutRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Queue Status
 */
function servicesQueuesQueueNameGetRaw<T>(requestParameters: ServicesQueuesQueueNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.queueName === null || requestParameters.queueName === undefined) {
        throw new runtime.RequiredError('queueName','Required parameter requestParameters.queueName was null or undefined when calling servicesQueuesQueueNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/queues/{queue_name}`.replace(`{${"queue_name"}}`, encodeURIComponent(String(requestParameters.queueName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Queue Status
*/
export function servicesQueuesQueueNameGet<T>(requestParameters: ServicesQueuesQueueNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesQueuesQueueNameGetRaw(requestParameters, requestConfig);
}

/**
 * Validate Imported Package
 */
function servicesVobjectVaultPackageVPackageIdActionsValidatePostRaw<T>(requestParameters: ServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.packageId === null || requestParameters.packageId === undefined) {
        throw new runtime.RequiredError('packageId','Required parameter requestParameters.packageId was null or undefined when calling servicesVobjectVaultPackageVPackageIdActionsValidatePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/services/vobject/vault_package__v/{package_id}/actions/validate`.replace(`{${"package_id"}}`, encodeURIComponent(String(requestParameters.packageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Validate Imported Package
*/
export function servicesVobjectVaultPackageVPackageIdActionsValidatePost<T>(requestParameters: ServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return servicesVobjectVaultPackageVPackageIdActionsValidatePostRaw(requestParameters, requestConfig);
}

/**
 * End Session
 */
function sessionDeleteRaw<T>(requestParameters: SessionDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/session`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* End Session
*/
export function sessionDelete<T>(requestParameters: SessionDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return sessionDeleteRaw(requestParameters, requestConfig);
}

/**
 * Download Single Client Code Distribution
 */
function uicodeDistributionsDistributionNameCodeGetRaw<T>(requestParameters: UicodeDistributionsDistributionNameCodeGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.distributionName === null || requestParameters.distributionName === undefined) {
        throw new runtime.RequiredError('distributionName','Required parameter requestParameters.distributionName was null or undefined when calling uicodeDistributionsDistributionNameCodeGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/uicode/distributions/{distribution_name}/code`.replace(`{${"distribution_name"}}`, encodeURIComponent(String(requestParameters.distributionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Single Client Code Distribution
*/
export function uicodeDistributionsDistributionNameCodeGet<T>(requestParameters: UicodeDistributionsDistributionNameCodeGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return uicodeDistributionsDistributionNameCodeGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Single Client Code Distribution
 */
function uicodeDistributionsDistributionNameDeleteRaw<T>(requestParameters: UicodeDistributionsDistributionNameDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.distributionName === null || requestParameters.distributionName === undefined) {
        throw new runtime.RequiredError('distributionName','Required parameter requestParameters.distributionName was null or undefined when calling uicodeDistributionsDistributionNameDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/uicode/distributions/{distribution_name}`.replace(`{${"distribution_name"}}`, encodeURIComponent(String(requestParameters.distributionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Single Client Code Distribution
*/
export function uicodeDistributionsDistributionNameDelete<T>(requestParameters: UicodeDistributionsDistributionNameDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return uicodeDistributionsDistributionNameDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Single Client Code Distribution Metadata
 */
function uicodeDistributionsDistributionNameGetRaw<T>(requestParameters: UicodeDistributionsDistributionNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.distributionName === null || requestParameters.distributionName === undefined) {
        throw new runtime.RequiredError('distributionName','Required parameter requestParameters.distributionName was null or undefined when calling uicodeDistributionsDistributionNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/uicode/distributions/{distribution_name}`.replace(`{${"distribution_name"}}`, encodeURIComponent(String(requestParameters.distributionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Single Client Code Distribution Metadata
*/
export function uicodeDistributionsDistributionNameGet<T>(requestParameters: UicodeDistributionsDistributionNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return uicodeDistributionsDistributionNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve All Client Code Distribution Metadata
 */
function uicodeDistributionsGetRaw<T>(requestParameters: UicodeDistributionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/uicode/distributions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve All Client Code Distribution Metadata
*/
export function uicodeDistributionsGet<T>(requestParameters: UicodeDistributionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return uicodeDistributionsGetRaw(requestParameters, requestConfig);
}

/**
 * Add or Replace Single Client Code Distribution
 */
function uicodeDistributionsPostRaw<T>(requestParameters: UicodeDistributionsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/uicode/distributions`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Add or Replace Single Client Code Distribution
*/
export function uicodeDistributionsPost<T>(requestParameters: UicodeDistributionsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return uicodeDistributionsPostRaw(requestParameters, requestConfig);
}

/**
 * Deploy Package
 */
function vobjectVaultPackageVPackageIdActionsDeployPostRaw<T>(requestParameters: VobjectVaultPackageVPackageIdActionsDeployPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.packageId === null || requestParameters.packageId === undefined) {
        throw new runtime.RequiredError('packageId','Required parameter requestParameters.packageId was null or undefined when calling vobjectVaultPackageVPackageIdActionsDeployPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobject/vault_package__v/{package_id}/actions/deploy`.replace(`{${"package_id"}}`, encodeURIComponent(String(requestParameters.packageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Deploy Package
*/
export function vobjectVaultPackageVPackageIdActionsDeployPost<T>(requestParameters: VobjectVaultPackageVPackageIdActionsDeployPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectVaultPackageVPackageIdActionsDeployPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Package Deploy Results
 */
function vobjectVaultPackageVPackageIdActionsDeployResultsGetRaw<T>(requestParameters: VobjectVaultPackageVPackageIdActionsDeployResultsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.packageId === null || requestParameters.packageId === undefined) {
        throw new runtime.RequiredError('packageId','Required parameter requestParameters.packageId was null or undefined when calling vobjectVaultPackageVPackageIdActionsDeployResultsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobject/vault_package__v/{package_id}/actions/deploy/results`.replace(`{${"package_id"}}`, encodeURIComponent(String(requestParameters.packageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Package Deploy Results
*/
export function vobjectVaultPackageVPackageIdActionsDeployResultsGet<T>(requestParameters: VobjectVaultPackageVPackageIdActionsDeployResultsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectVaultPackageVPackageIdActionsDeployResultsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Results of Cascade Delete Job
 */
function vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRaw<T>(requestParameters: VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet.');
    }

    if (requestParameters.jobStatus === null || requestParameters.jobStatus === undefined) {
        throw new runtime.RequiredError('jobStatus','Required parameter requestParameters.jobStatus was null or undefined when calling vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet.');
    }

    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/cascadedelete/results/{object_name}/{job_status}/{job_id}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"job_status"}}`, encodeURIComponent(String(requestParameters.jobStatus))).replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Results of Cascade Delete Job
*/
export function vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet<T>(requestParameters: VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Results of Deep Copy Job
 */
function vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRaw<T>(requestParameters: VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet.');
    }

    if (requestParameters.jobStatus === null || requestParameters.jobStatus === undefined) {
        throw new runtime.RequiredError('jobStatus','Required parameter requestParameters.jobStatus was null or undefined when calling vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet.');
    }

    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/deepcopy/results/{object_name}/{job_status}/{job_id}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"job_status"}}`, encodeURIComponent(String(requestParameters.jobStatus))).replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Results of Deep Copy Job
*/
export function vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet<T>(requestParameters: VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRaw(requestParameters, requestConfig);
}

/**
 * Create a Placeholder from an EDL Item
 */
function vobjectsEdlItemVActionsCreateplaceholderPostRaw<T>(requestParameters: VobjectsEdlItemVActionsCreateplaceholderPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/edl_item__v/actions/createplaceholder`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create a Placeholder from an EDL Item
*/
export function vobjectsEdlItemVActionsCreateplaceholderPost<T>(requestParameters: VobjectsEdlItemVActionsCreateplaceholderPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsEdlItemVActionsCreateplaceholderPostRaw(requestParameters, requestConfig);
}

/**
 * Download Merge Records Job Log
 */
function vobjectsMergesJobIdLogGetRaw<T>(requestParameters: VobjectsMergesJobIdLogGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling vobjectsMergesJobIdLogGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/merges/{job_id}/log`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Merge Records Job Log
*/
export function vobjectsMergesJobIdLogGet<T>(requestParameters: VobjectsMergesJobIdLogGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsMergesJobIdLogGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Record Merge Results
 */
function vobjectsMergesJobIdResultsGetRaw<T>(requestParameters: VobjectsMergesJobIdResultsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling vobjectsMergesJobIdResultsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/merges/{job_id}/results`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Record Merge Results
*/
export function vobjectsMergesJobIdResultsGet<T>(requestParameters: VobjectsMergesJobIdResultsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsMergesJobIdResultsGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Record Merge Status
 */
function vobjectsMergesJobIdStatusGetRaw<T>(requestParameters: VobjectsMergesJobIdStatusGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
        throw new runtime.RequiredError('jobId','Required parameter requestParameters.jobId was null or undefined when calling vobjectsMergesJobIdStatusGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/merges/{job_id}/status`.replace(`{${"job_id"}}`, encodeURIComponent(String(requestParameters.jobId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Record Merge Status
*/
export function vobjectsMergesJobIdStatusGet<T>(requestParameters: VobjectsMergesJobIdStatusGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsMergesJobIdStatusGetRaw(requestParameters, requestConfig);
}

/**
 * Initiate Object Action on Multiple Records
 */
function vobjectsObjectNameActionsActionNamePostRaw<T>(requestParameters: VobjectsObjectNameActionsActionNamePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameActionsActionNamePost.');
    }

    if (requestParameters.actionName === null || requestParameters.actionName === undefined) {
        throw new runtime.RequiredError('actionName','Required parameter requestParameters.actionName was null or undefined when calling vobjectsObjectNameActionsActionNamePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/actions/{action_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"action_name"}}`, encodeURIComponent(String(requestParameters.actionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Object Action on Multiple Records
*/
export function vobjectsObjectNameActionsActionNamePost<T>(requestParameters: VobjectsObjectNameActionsActionNamePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameActionsActionNamePostRaw(requestParameters, requestConfig);
}

/**
 * Change Object Type
 */
function vobjectsObjectNameActionsChangetypePostRaw<T>(requestParameters: VobjectsObjectNameActionsChangetypePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameActionsChangetypePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/actions/changetype`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Change Object Type
*/
export function vobjectsObjectNameActionsChangetypePost<T>(requestParameters: VobjectsObjectNameActionsChangetypePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameActionsChangetypePostRaw(requestParameters, requestConfig);
}

/**
 * Initiate Record Merge
 */
function vobjectsObjectNameActionsMergePostRaw<T>(requestParameters: VobjectsObjectNameActionsMergePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameActionsMergePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/actions/merge`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || requestParameters.vobjectsObjectNameActionsMergePostRequestInner?.map(VobjectsObjectNameActionsMergePostRequestInnerToJSON),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Record Merge
*/
export function vobjectsObjectNameActionsMergePost<T>(requestParameters: VobjectsObjectNameActionsMergePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameActionsMergePostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Roll-up Field Recalculation Status
 */
function vobjectsObjectNameActionsRecalculaterollupsGetRaw<T>(requestParameters: VobjectsObjectNameActionsRecalculaterollupsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameActionsRecalculaterollupsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/actions/recalculaterollups`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Roll-up Field Recalculation Status
*/
export function vobjectsObjectNameActionsRecalculaterollupsGet<T>(requestParameters: VobjectsObjectNameActionsRecalculaterollupsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameActionsRecalculaterollupsGetRaw(requestParameters, requestConfig);
}

/**
 * Recalculate Roll-up Fields
 */
function vobjectsObjectNameActionsRecalculaterollupsPostRaw<T>(requestParameters: VobjectsObjectNameActionsRecalculaterollupsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameActionsRecalculaterollupsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/actions/recalculaterollups`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Recalculate Roll-up Fields
*/
export function vobjectsObjectNameActionsRecalculaterollupsPost<T>(requestParameters: VobjectsObjectNameActionsRecalculaterollupsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameActionsRecalculaterollupsPostRaw(requestParameters, requestConfig);
}

/**
 * Update Corporate Currency Fields
 */
function vobjectsObjectNameActionsUpdatecorporatecurrencyPutRaw<T>(requestParameters: VobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameActionsUpdatecorporatecurrencyPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/actions/updatecorporatecurrency`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Corporate Currency Fields
*/
export function vobjectsObjectNameActionsUpdatecorporatecurrencyPut<T>(requestParameters: VobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameActionsUpdatecorporatecurrencyPutRaw(requestParameters, requestConfig);
}

/**
 * Delete Multiple Object Record Attachments
 */
function vobjectsObjectNameAttachmentsBatchDeleteRaw<T>(requestParameters: VobjectsObjectNameAttachmentsBatchDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameAttachmentsBatchDelete.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.idParam !== undefined) {
        queryParameters['idParam'] = requestParameters.idParam;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/attachments/batch`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Multiple Object Record Attachments
*/
export function vobjectsObjectNameAttachmentsBatchDelete<T>(requestParameters: VobjectsObjectNameAttachmentsBatchDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameAttachmentsBatchDeleteRaw(requestParameters, requestConfig);
}

/**
 * Create Multiple Object Record Attachments
 */
function vobjectsObjectNameAttachmentsBatchPostRaw<T>(requestParameters: VobjectsObjectNameAttachmentsBatchPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameAttachmentsBatchPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/attachments/batch`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Multiple Object Record Attachments
*/
export function vobjectsObjectNameAttachmentsBatchPost<T>(requestParameters: VobjectsObjectNameAttachmentsBatchPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameAttachmentsBatchPostRaw(requestParameters, requestConfig);
}

/**
 * Update Multiple Object Record Attachment Descriptions
 */
function vobjectsObjectNameAttachmentsBatchPutRaw<T>(requestParameters: VobjectsObjectNameAttachmentsBatchPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameAttachmentsBatchPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/attachments/batch`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Multiple Object Record Attachment Descriptions
*/
export function vobjectsObjectNameAttachmentsBatchPut<T>(requestParameters: VobjectsObjectNameAttachmentsBatchPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameAttachmentsBatchPutRaw(requestParameters, requestConfig);
}

/**
 * Delete Object Records
 */
function vobjectsObjectNameDeleteRaw<T>(requestParameters: VobjectsObjectNameDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Object Records
*/
export function vobjectsObjectNameDelete<T>(requestParameters: VobjectsObjectNameDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Record Roles
 */
function vobjectsObjectNameIdRolesRoleNameGetRaw<T>(requestParameters: VobjectsObjectNameIdRolesRoleNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameIdRolesRoleNameGet.');
    }

    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling vobjectsObjectNameIdRolesRoleNameGet.');
    }

    if (requestParameters.roleName === null || requestParameters.roleName === undefined) {
        throw new runtime.RequiredError('roleName','Required parameter requestParameters.roleName was null or undefined when calling vobjectsObjectNameIdRolesRoleNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{id}/roles/{role_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"role_name"}}`, encodeURIComponent(String(requestParameters.roleName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Record Roles
*/
export function vobjectsObjectNameIdRolesRoleNameGet<T>(requestParameters: VobjectsObjectNameIdRolesRoleNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameIdRolesRoleNameGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object User Actions Details
 */
function vobjectsObjectNameObjectRecordIdActionsActionNameGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsActionNameGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNameGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNameGet.');
    }

    if (requestParameters.actionName === null || requestParameters.actionName === undefined) {
        throw new runtime.RequiredError('actionName','Required parameter requestParameters.actionName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNameGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/actions/{action_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"action_name"}}`, encodeURIComponent(String(requestParameters.actionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object User Actions Details
*/
export function vobjectsObjectNameObjectRecordIdActionsActionNameGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsActionNameGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdActionsActionNameGetRaw(requestParameters, requestConfig);
}

/**
 * Initiate Object Action on a Single Record
 */
function vobjectsObjectNameObjectRecordIdActionsActionNamePostRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsActionNamePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNamePost.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNamePost.');
    }

    if (requestParameters.actionName === null || requestParameters.actionName === undefined) {
        throw new runtime.RequiredError('actionName','Required parameter requestParameters.actionName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNamePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/actions/{action_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"action_name"}}`, encodeURIComponent(String(requestParameters.actionName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Initiate Object Action on a Single Record
*/
export function vobjectsObjectNameObjectRecordIdActionsActionNamePost<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsActionNamePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdActionsActionNamePostRaw(requestParameters, requestConfig);
}

/**
 * Cascade Delete Object Record
 */
function vobjectsObjectNameObjectRecordIdActionsCascadedeletePostRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsCascadedeletePost.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsCascadedeletePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/actions/cascadedelete`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Cascade Delete Object Record
*/
export function vobjectsObjectNameObjectRecordIdActionsCascadedeletePost<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdActionsCascadedeletePostRaw(requestParameters, requestConfig);
}

/**
 * Deep Copy Object Record
 */
function vobjectsObjectNameObjectRecordIdActionsDeepcopyPostRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsDeepcopyPost.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsDeepcopyPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/actions/deepcopy`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Deep Copy Object Record
*/
export function vobjectsObjectNameObjectRecordIdActionsDeepcopyPost<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdActionsDeepcopyPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Record User Actions
 */
function vobjectsObjectNameObjectRecordIdActionsGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.loc !== undefined) {
        queryParameters['loc'] = requestParameters.loc;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/actions`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Record User Actions
*/
export function vobjectsObjectNameObjectRecordIdActionsGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdActionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdActionsGetRaw(requestParameters, requestConfig);
}

/**
 * Download Attachment Field File
 */
function vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet.');
    }

    if (requestParameters.attachmentFieldName === null || requestParameters.attachmentFieldName === undefined) {
        throw new runtime.RequiredError('attachmentFieldName','Required parameter requestParameters.attachmentFieldName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_field_name"}}`, encodeURIComponent(String(requestParameters.attachmentFieldName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Attachment Field File
*/
export function vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRaw(requestParameters, requestConfig);
}

/**
 * Update Attachment Field File
 */
function vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost.');
    }

    if (requestParameters.attachmentFieldName === null || requestParameters.attachmentFieldName === undefined) {
        throw new runtime.RequiredError('attachmentFieldName','Required parameter requestParameters.attachmentFieldName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_field_name"}}`, encodeURIComponent(String(requestParameters.attachmentFieldName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Attachment Field File
*/
export function vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRaw(requestParameters, requestConfig);
}

/**
 * Download All Attachment Field Files
 */
function vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachment_fields/file`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download All Attachment Field Files
*/
export function vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRaw(requestParameters, requestConfig);
}

/**
 * Delete Object Record Attachment
 */
function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Object Record Attachment
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Record Attachment Metadata
 */
function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Record Attachment Metadata
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRaw(requestParameters, requestConfig);
}

/**
 * Update Object Record Attachment Description
 */
function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Object Record Attachment Description
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRaw(requestParameters, requestConfig);
}

/**
 * Delete Object Record Attachment Version
 */
function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Delete Object Record Attachment Version
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRaw(requestParameters, requestConfig);
}

/**
 * Download Object Record Attachment File
 */
function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}/file`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download Object Record Attachment File
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Record Attachment Version Metadata
 */
function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Record Attachment Version Metadata
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRaw(requestParameters, requestConfig);
}

/**
 * Restore Object Record Attachment Version
 */
function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
    }

    if (requestParameters.attachmentVersion === null || requestParameters.attachmentVersion === undefined) {
        throw new runtime.RequiredError('attachmentVersion','Required parameter requestParameters.attachmentVersion was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.restore !== undefined) {
        queryParameters['restore'] = requestParameters.restore;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))).replace(`{${"attachment_version"}}`, encodeURIComponent(String(requestParameters.attachmentVersion))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Restore Object Record Attachment Version
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Record Attachment Versions
 */
function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet.');
    }

    if (requestParameters.attachmentId === null || requestParameters.attachmentId === undefined) {
        throw new runtime.RequiredError('attachmentId','Required parameter requestParameters.attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))).replace(`{${"attachment_id"}}`, encodeURIComponent(String(requestParameters.attachmentId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Record Attachment Versions
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRaw(requestParameters, requestConfig);
}

/**
 * Download All Object Record Attachment Files
 */
function vobjectsObjectNameObjectRecordIdAttachmentsFileGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsFileGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsFileGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments/file`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Download All Object Record Attachment Files
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsFileGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsFileGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Record Attachments
 */
function vobjectsObjectNameObjectRecordIdAttachmentsGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Record Attachments
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsGetRaw(requestParameters, requestConfig);
}

/**
 * Create Object Record Attachment
 */
function vobjectsObjectNameObjectRecordIdAttachmentsPostRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsPost.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/attachments`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create Object Record Attachment
*/
export function vobjectsObjectNameObjectRecordIdAttachmentsPost<T>(requestParameters: VobjectsObjectNameObjectRecordIdAttachmentsPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAttachmentsPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Complete Audit History for a Single Object Record
 */
function vobjectsObjectNameObjectRecordIdAudittrailGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdAudittrailGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAudittrailGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAudittrailGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = requestParameters.startDate;
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = requestParameters.endDate;
    }


    if (requestParameters.formatResult !== undefined) {
        queryParameters['format_result'] = requestParameters.formatResult;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.events !== undefined) {
        queryParameters['events'] = requestParameters.events;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}/audittrail`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Complete Audit History for a Single Object Record
*/
export function vobjectsObjectNameObjectRecordIdAudittrailGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdAudittrailGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdAudittrailGetRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Object Record
 */
function vobjectsObjectNameObjectRecordIdGetRaw<T>(requestParameters: VobjectsObjectNameObjectRecordIdGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdGet.');
    }

    if (requestParameters.objectRecordId === null || requestParameters.objectRecordId === undefined) {
        throw new runtime.RequiredError('objectRecordId','Required parameter requestParameters.objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/{object_record_id}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))).replace(`{${"object_record_id"}}`, encodeURIComponent(String(requestParameters.objectRecordId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Object Record
*/
export function vobjectsObjectNameObjectRecordIdGet<T>(requestParameters: VobjectsObjectNameObjectRecordIdGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameObjectRecordIdGetRaw(requestParameters, requestConfig);
}

/**
 * Create & Upsert Object Records
 */
function vobjectsObjectNamePostRaw<T>(requestParameters: VobjectsObjectNamePostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNamePost.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.idParam !== undefined) {
        queryParameters['idParam'] = requestParameters.idParam;
    }

    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPINoTriggers !== undefined && requestParameters.xVaultAPINoTriggers !== null) {
        headerParameters['X-VaultAPI-NoTriggers'] = String(requestParameters.xVaultAPINoTriggers);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Create & Upsert Object Records
*/
export function vobjectsObjectNamePost<T>(requestParameters: VobjectsObjectNamePostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNamePostRaw(requestParameters, requestConfig);
}

/**
 * Update Object Records
 */
function vobjectsObjectNamePutRaw<T>(requestParameters: VobjectsObjectNamePutRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNamePut.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIMigrationMode !== undefined && requestParameters.xVaultAPIMigrationMode !== null) {
        headerParameters['X-VaultAPI-MigrationMode'] = String(requestParameters.xVaultAPIMigrationMode);
    }

    if (requestParameters.xVaultAPINoTriggers !== undefined && requestParameters.xVaultAPINoTriggers !== null) {
        headerParameters['X-VaultAPI-NoTriggers'] = String(requestParameters.xVaultAPINoTriggers);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PUT',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Update Object Records
*/
export function vobjectsObjectNamePut<T>(requestParameters: VobjectsObjectNamePutRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNamePutRaw(requestParameters, requestConfig);
}

/**
 * Remove Users & Groups from Roles on Object Records
 */
function vobjectsObjectNameRolesDeleteRaw<T>(requestParameters: VobjectsObjectNameRolesDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameRolesDelete.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/roles`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Remove Users & Groups from Roles on Object Records
*/
export function vobjectsObjectNameRolesDelete<T>(requestParameters: VobjectsObjectNameRolesDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameRolesDeleteRaw(requestParameters, requestConfig);
}

/**
 * Assign Users & Groups to Roles on Object Records
 */
function vobjectsObjectNameRolesPostRaw<T>(requestParameters: VobjectsObjectNameRolesPostRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.objectName === null || requestParameters.objectName === undefined) {
        throw new runtime.RequiredError('objectName','Required parameter requestParameters.objectName was null or undefined when calling vobjectsObjectNameRolesPost.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.contentType !== undefined && requestParameters.contentType !== null) {
        headerParameters['Content-Type'] = String(requestParameters.contentType);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/{object_name}/roles`.replace(`{${"object_name"}}`, encodeURIComponent(String(requestParameters.objectName))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Assign Users & Groups to Roles on Object Records
*/
export function vobjectsObjectNameRolesPost<T>(requestParameters: VobjectsObjectNameRolesPostRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsObjectNameRolesPostRaw(requestParameters, requestConfig);
}

/**
 * Retrieve Outbound Package Dependencies
 */
function vobjectsOutboundPackageVPackageIdDependenciesGetRaw<T>(requestParameters: VobjectsOutboundPackageVPackageIdDependenciesGetRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.packageId === null || requestParameters.packageId === undefined) {
        throw new runtime.RequiredError('packageId','Required parameter requestParameters.packageId was null or undefined when calling vobjectsOutboundPackageVPackageIdDependenciesGet.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
        headerParameters['Authorization'] = String(requestParameters.authorization);
    }

    if (requestParameters.accept !== undefined && requestParameters.accept !== null) {
        headerParameters['Accept'] = String(requestParameters.accept);
    }

    if (requestParameters.xVaultAPIClientID !== undefined && requestParameters.xVaultAPIClientID !== null) {
        headerParameters['X-VaultAPI-ClientID'] = String(requestParameters.xVaultAPIClientID);
    }


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/vobjects/outbound_package__v/{package_id}/dependencies`.replace(`{${"package_id"}}`, encodeURIComponent(String(requestParameters.packageId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Retrieve Outbound Package Dependencies
*/
export function vobjectsOutboundPackageVPackageIdDependenciesGet<T>(requestParameters: VobjectsOutboundPackageVPackageIdDependenciesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return vobjectsOutboundPackageVPackageIdDependenciesGetRaw(requestParameters, requestConfig);
}

