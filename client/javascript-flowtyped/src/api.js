// @flow
/* eslint-disable no-use-before-define */
/**
 * Veeva Vault API v25.1
 * The latest GA version of the Vault REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "http://}/api/v25.1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type VobjectsObjectNameActionsMergePostRequestInner = {
    /**
     * 
     * @type {string}
     * @memberof VobjectsObjectNameActionsMergePostRequestInner
     */
    duplicate_record_id?: string;
    /**
     * 
     * @type {string}
     * @memberof VobjectsObjectNameActionsMergePostRequestInner
     */
    main_record_id?: string;
}



/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve API Versions
         * @throws {RequiredError}
         */
        apiGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Content File
         * @throws {RequiredError}
         */
        apiMdlComponentsComponentTypeAndRecordNameFilesGet(componentTypeAndRecordName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'componentTypeAndRecordName' is not null or undefined
            if (componentTypeAndRecordName === null || componentTypeAndRecordName === undefined) {
                throw new RequiredError('componentTypeAndRecordName','Required parameter componentTypeAndRecordName was null or undefined when calling apiMdlComponentsComponentTypeAndRecordNameFilesGet.');
            }
            const localVarPath = `/api/mdl/components/{component_type_and_record_name}/files`
                .replace(`{${"component_type_and_record_name"}}`, encodeURIComponent(String(componentTypeAndRecordName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Component Record (MDL)
         * @throws {RequiredError}
         */
        apiMdlComponentsComponentTypeAndRecordNameGet(componentTypeAndRecordName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'componentTypeAndRecordName' is not null or undefined
            if (componentTypeAndRecordName === null || componentTypeAndRecordName === undefined) {
                throw new RequiredError('componentTypeAndRecordName','Required parameter componentTypeAndRecordName was null or undefined when calling apiMdlComponentsComponentTypeAndRecordNameGet.');
            }
            const localVarPath = `/api/mdl/components/{component_type_and_record_name}`
                .replace(`{${"component_type_and_record_name"}}`, encodeURIComponent(String(componentTypeAndRecordName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Asynchronous MDL Script Results
         * @throws {RequiredError}
         */
        apiMdlExecuteAsyncJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling apiMdlExecuteAsyncJobIdResultsGet.');
            }
            const localVarPath = `/api/mdl/execute_async/{job_id}/results`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute MDL Script Asynchronously
         * @throws {RequiredError}
         */
        apiMdlExecuteAsyncPost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/mdl/execute_async`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute MDL Script
         * @throws {RequiredError}
         */
        apiMdlExecutePost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/mdl/execute`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Content File
         * @throws {RequiredError}
         */
        apiMdlFilesPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/mdl/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Audit Details
         * @throws {RequiredError}
         */
        audittrailAuditTrailTypeGet(auditTrailType: string, startDate?: string, endDate?: string, allDates?: string, formatResult?: string, limit?: string, offset?: string, objects?: string, events?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'auditTrailType' is not null or undefined
            if (auditTrailType === null || auditTrailType === undefined) {
                throw new RequiredError('auditTrailType','Required parameter auditTrailType was null or undefined when calling audittrailAuditTrailTypeGet.');
            }
            const localVarPath = `/audittrail/{audit_trail_type}`
                .replace(`{${"audit_trail_type"}}`, encodeURIComponent(String(auditTrailType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = ((startDate:any):string);
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = ((endDate:any):string);
            }

            if (allDates !== undefined) {
                localVarQueryParameter['all_dates'] = ((allDates:any):string);
            }

            if (formatResult !== undefined) {
                localVarQueryParameter['format_result'] = ((formatResult:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (objects !== undefined) {
                localVarQueryParameter['objects'] = ((objects:any):string);
            }

            if (events !== undefined) {
                localVarQueryParameter['events'] = ((events:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Authentication Type Discovery
         * @throws {RequiredError}
         */
        authDiscoveryPost(accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/auth/discovery`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary OAuth 2.0 / OpenID Connect
         * @throws {RequiredError}
         */
        authOauthSessionOathOidcProfileIdPost(oathOidcProfileId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'oathOidcProfileId' is not null or undefined
            if (oathOidcProfileId === null || oathOidcProfileId === undefined) {
                throw new RequiredError('oathOidcProfileId','Required parameter oathOidcProfileId was null or undefined when calling authOauthSessionOathOidcProfileIdPost.');
            }
            const localVarPath = `/auth/oauth/session/{oath_oidc_profile_id}`
                .replace(`{${"oath_oidc_profile_id"}}`, encodeURIComponent(String(oathOidcProfileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Name and Password
         * @throws {RequiredError}
         */
        authPost(contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Single Source Code File
         * @throws {RequiredError}
         */
        codeClassNameDelete(className: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'className' is not null or undefined
            if (className === null || className === undefined) {
                throw new RequiredError('className','Required parameter className was null or undefined when calling codeClassNameDelete.');
            }
            const localVarPath = `/code/{class_name}`
                .replace(`{${"class_name"}}`, encodeURIComponent(String(className)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable Vault Extension
         * @throws {RequiredError}
         */
        codeClassNameDisablePut(className: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'className' is not null or undefined
            if (className === null || className === undefined) {
                throw new RequiredError('className','Required parameter className was null or undefined when calling codeClassNameDisablePut.');
            }
            const localVarPath = `/code/{class_name}/disable`
                .replace(`{${"class_name"}}`, encodeURIComponent(String(className)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable Vault Extension
         * @throws {RequiredError}
         */
        codeClassNameEnablePut(className: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'className' is not null or undefined
            if (className === null || className === undefined) {
                throw new RequiredError('className','Required parameter className was null or undefined when calling codeClassNameEnablePut.');
            }
            const localVarPath = `/code/{class_name}/enable`
                .replace(`{${"class_name"}}`, encodeURIComponent(String(className)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Single Source Code File
         * @throws {RequiredError}
         */
        codeClassNameGet(className: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'className' is not null or undefined
            if (className === null || className === undefined) {
                throw new RequiredError('className','Required parameter className was null or undefined when calling codeClassNameGet.');
            }
            const localVarPath = `/code/{class_name}`
                .replace(`{${"class_name"}}`, encodeURIComponent(String(className)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Profiling Sessions
         * @throws {RequiredError}
         */
        codeProfilerGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/code/profiler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Profiling Session
         * @throws {RequiredError}
         */
        codeProfilerPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/code/profiler`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary End Profiling Session
         * @throws {RequiredError}
         */
        codeProfilerSessionNameActionsEndPost(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'sessionName' is not null or undefined
            if (sessionName === null || sessionName === undefined) {
                throw new RequiredError('sessionName','Required parameter sessionName was null or undefined when calling codeProfilerSessionNameActionsEndPost.');
            }
            const localVarPath = `/code/profiler/{session_name}/actions/end`
                .replace(`{${"session_name"}}`, encodeURIComponent(String(sessionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Profiling Session
         * @throws {RequiredError}
         */
        codeProfilerSessionNameDelete(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'sessionName' is not null or undefined
            if (sessionName === null || sessionName === undefined) {
                throw new RequiredError('sessionName','Required parameter sessionName was null or undefined when calling codeProfilerSessionNameDelete.');
            }
            const localVarPath = `/code/profiler/{session_name}`
                .replace(`{${"session_name"}}`, encodeURIComponent(String(sessionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Profiling Session
         * @throws {RequiredError}
         */
        codeProfilerSessionNameGet(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'sessionName' is not null or undefined
            if (sessionName === null || sessionName === undefined) {
                throw new RequiredError('sessionName','Required parameter sessionName was null or undefined when calling codeProfilerSessionNameGet.');
            }
            const localVarPath = `/code/profiler/{session_name}`
                .replace(`{${"session_name"}}`, encodeURIComponent(String(sessionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Profiling Session Results
         * @throws {RequiredError}
         */
        codeProfilerSessionNameResultsGet(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'sessionName' is not null or undefined
            if (sessionName === null || sessionName === undefined) {
                throw new RequiredError('sessionName','Required parameter sessionName was null or undefined when calling codeProfilerSessionNameResultsGet.');
            }
            const localVarPath = `/code/profiler/{session_name}/results`
                .replace(`{${"session_name"}}`, encodeURIComponent(String(sessionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add or Replace Single Source Code File
         * @throws {RequiredError}
         */
        codePut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/code`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Specific Root Nodes
         * @throws {RequiredError}
         */
        compositesTreesEdlHierarchyOrTemplateActionsListnodesPost(edlHierarchyOrTemplate: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'edlHierarchyOrTemplate' is not null or undefined
            if (edlHierarchyOrTemplate === null || edlHierarchyOrTemplate === undefined) {
                throw new RequiredError('edlHierarchyOrTemplate','Required parameter edlHierarchyOrTemplate was null or undefined when calling compositesTreesEdlHierarchyOrTemplateActionsListnodesPost.');
            }
            const localVarPath = `/composites/trees/{edl_hierarchy_or_template}/actions/listnodes`
                .replace(`{${"edl_hierarchy_or_template"}}`, encodeURIComponent(String(edlHierarchyOrTemplate)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Root Nodes
         * @throws {RequiredError}
         */
        compositesTreesEdlHierarchyOrTemplateGet(edlHierarchyOrTemplate: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'edlHierarchyOrTemplate' is not null or undefined
            if (edlHierarchyOrTemplate === null || edlHierarchyOrTemplate === undefined) {
                throw new RequiredError('edlHierarchyOrTemplate','Required parameter edlHierarchyOrTemplate was null or undefined when calling compositesTreesEdlHierarchyOrTemplateGet.');
            }
            const localVarPath = `/composites/trees/{edl_hierarchy_or_template}`
                .replace(`{${"edl_hierarchy_or_template"}}`, encodeURIComponent(String(edlHierarchyOrTemplate)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Node\'s Children
         * @throws {RequiredError}
         */
        compositesTreesEdlHierarchyVParentNodeIdChildrenGet(parentNodeId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'parentNodeId' is not null or undefined
            if (parentNodeId === null || parentNodeId === undefined) {
                throw new RequiredError('parentNodeId','Required parameter parentNodeId was null or undefined when calling compositesTreesEdlHierarchyVParentNodeIdChildrenGet.');
            }
            const localVarPath = `/composites/trees/edl_hierarchy__v/{parent_node_id}/children`
                .replace(`{${"parent_node_id"}}`, encodeURIComponent(String(parentNodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Node Order
         * @throws {RequiredError}
         */
        compositesTreesEdlHierarchyVParentNodeIdChildrenPut(parentNodeId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'parentNodeId' is not null or undefined
            if (parentNodeId === null || parentNodeId === undefined) {
                throw new RequiredError('parentNodeId','Required parameter parentNodeId was null or undefined when calling compositesTreesEdlHierarchyVParentNodeIdChildrenPut.');
            }
            const localVarPath = `/composites/trees/edl_hierarchy__v/{parent_node_id}/children`
                .replace(`{${"parent_node_id"}}`, encodeURIComponent(String(parentNodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Component Record (XML/JSON)
         * @throws {RequiredError}
         */
        configurationComponentTypeAndRecordNameGet(componentTypeAndRecordName: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'componentTypeAndRecordName' is not null or undefined
            if (componentTypeAndRecordName === null || componentTypeAndRecordName === undefined) {
                throw new RequiredError('componentTypeAndRecordName','Required parameter componentTypeAndRecordName was null or undefined when calling configurationComponentTypeAndRecordNameGet.');
            }
            const localVarPath = `/configuration/{component_type_and_record_name}`
                .replace(`{${"component_type_and_record_name"}}`, encodeURIComponent(String(componentTypeAndRecordName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Component Record Collection
         * @throws {RequiredError}
         */
        configurationComponentTypeGet(componentType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'componentType' is not null or undefined
            if (componentType === null || componentType === undefined) {
                throw new RequiredError('componentType','Required parameter componentType was null or undefined when calling configurationComponentTypeGet.');
            }
            const localVarPath = `/configuration/{component_type}`
                .replace(`{${"component_type"}}`, encodeURIComponent(String(componentType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Details from a Specific Object
         * @throws {RequiredError}
         */
        configurationObjectNameAndObjectTypeGet(objectNameAndObjectType: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectNameAndObjectType' is not null or undefined
            if (objectNameAndObjectType === null || objectNameAndObjectType === undefined) {
                throw new RequiredError('objectNameAndObjectType','Required parameter objectNameAndObjectType was null or undefined when calling configurationObjectNameAndObjectTypeGet.');
            }
            const localVarPath = `/configuration/{object_name_and_object_type}`
                .replace(`{${"object_name_and_object_type"}}`, encodeURIComponent(String(objectNameAndObjectType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Details from All Object Types
         * @throws {RequiredError}
         */
        configurationObjecttypeGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/configuration/Objecttype`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Lifecycle Role Assignment Override Rules
         * @throws {RequiredError}
         */
        configurationRoleAssignmentRuleDelete(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/configuration/role_assignment_rule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Lifecycle Role Assignment Rules (Default & Override)
         * @throws {RequiredError}
         */
        configurationRoleAssignmentRuleGet(lifecycleV?: string, roleV?: string, productV?: string, countryV?: string, studyV?: string, studyCountryV?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/configuration/role_assignment_rule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (lifecycleV !== undefined) {
                localVarQueryParameter['lifecycle__v'] = ((lifecycleV:any):string);
            }

            if (roleV !== undefined) {
                localVarQueryParameter['role__v'] = ((roleV:any):string);
            }

            if (productV !== undefined) {
                localVarQueryParameter['product__v'] = ((productV:any):string);
            }

            if (countryV !== undefined) {
                localVarQueryParameter['country__v'] = ((countryV:any):string);
            }

            if (studyV !== undefined) {
                localVarQueryParameter['study__v'] = ((studyV:any):string);
            }

            if (studyCountryV !== undefined) {
                localVarQueryParameter['study_country__v'] = ((studyCountryV:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Lifecycle Role Assignment Override Rules
         * @throws {RequiredError}
         */
        configurationRoleAssignmentRulePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/configuration/role_assignment_rule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Lifecycle Role Assignment Rules (Default & Override)
         * @throws {RequiredError}
         */
        configurationRoleAssignmentRulePut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/configuration/role_assignment_rule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Delegated Session
         * @throws {RequiredError}
         */
        delegationLoginPost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/delegation/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Delegations
         * @throws {RequiredError}
         */
        delegationVaultsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/delegation/vaults`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Session Keep Alive
         * @throws {RequiredError}
         */
        keepAlivePost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/keep-alive`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Limits on Objects
         * @throws {RequiredError}
         */
        limitsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/limits`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Daily API Usage
         * @throws {RequiredError}
         */
        logsApiUsageGet(_date?: string, logFormat?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/logs/api_usage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):string);
            }

            if (logFormat !== undefined) {
                localVarQueryParameter['log_format'] = ((logFormat:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Debug Logs
         * @throws {RequiredError}
         */
        logsCodeDebugGet(userId?: string, includeInactive?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/logs/code/debug`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = ((userId:any):string);
            }

            if (includeInactive !== undefined) {
                localVarQueryParameter['include_inactive'] = ((includeInactive:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Debug Log
         * @throws {RequiredError}
         */
        logsCodeDebugIdActionsResetDelete(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling logsCodeDebugIdActionsResetDelete.');
            }
            const localVarPath = `/logs/code/debug/{id}/actions/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Debug Log
         * @throws {RequiredError}
         */
        logsCodeDebugIdActionsResetPost(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling logsCodeDebugIdActionsResetPost.');
            }
            const localVarPath = `/logs/code/debug/{id}/actions/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Debug Log Files
         * @throws {RequiredError}
         */
        logsCodeDebugIdFilesGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling logsCodeDebugIdFilesGet.');
            }
            const localVarPath = `/logs/code/debug/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Single Debug Log
         * @throws {RequiredError}
         */
        logsCodeDebugIdGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling logsCodeDebugIdGet.');
            }
            const localVarPath = `/logs/code/debug/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Debug Log
         * @throws {RequiredError}
         */
        logsCodeDebugPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/logs/code/debug`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download SDK Runtime Log
         * @throws {RequiredError}
         */
        logsCodeRuntimeGet(_date?: string, logFormat?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/logs/code/runtime`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (_date !== undefined) {
                localVarQueryParameter['date'] = ((_date:any):string);
            }

            if (logFormat !== undefined) {
                localVarQueryParameter['log_format'] = ((logFormat:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Bulk Translation File
         * @throws {RequiredError}
         */
        messagesMessageTypeActionsImportPost(messageType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'messageType' is not null or undefined
            if (messageType === null || messageType === undefined) {
                throw new RequiredError('messageType','Required parameter messageType was null or undefined when calling messagesMessageTypeActionsImportPost.');
            }
            const localVarPath = `/messages/{message_type}/actions/import`
                .replace(`{${"message_type"}}`, encodeURIComponent(String(messageType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Bulk Translation File
         * @throws {RequiredError}
         */
        messagesMessageTypeLanguageLangActionsExportPost(messageType: string, lang: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'messageType' is not null or undefined
            if (messageType === null || messageType === undefined) {
                throw new RequiredError('messageType','Required parameter messageType was null or undefined when calling messagesMessageTypeLanguageLangActionsExportPost.');
            }
            // verify required parameter 'lang' is not null or undefined
            if (lang === null || lang === undefined) {
                throw new RequiredError('lang','Required parameter lang was null or undefined when calling messagesMessageTypeLanguageLangActionsExportPost.');
            }
            const localVarPath = `/messages/{message_type}/language/{lang}/actions/export`
                .replace(`{${"message_type"}}`, encodeURIComponent(String(messageType)))
                .replace(`{${"lang"}}`, encodeURIComponent(String(lang)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Audit Metadata
         * @throws {RequiredError}
         */
        metadataAudittrailAuditTrailTypeGet(auditTrailType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'auditTrailType' is not null or undefined
            if (auditTrailType === null || auditTrailType === undefined) {
                throw new RequiredError('auditTrailType','Required parameter auditTrailType was null or undefined when calling metadataAudittrailAuditTrailTypeGet.');
            }
            const localVarPath = `/metadata/audittrail/{audit_trail_type}`
                .replace(`{${"audit_trail_type"}}`, encodeURIComponent(String(auditTrailType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Audit Types
         * @throws {RequiredError}
         */
        metadataAudittrailGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/audittrail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Component Type Metadata
         * @throws {RequiredError}
         */
        metadataComponentsComponentTypeGet(componentType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'componentType' is not null or undefined
            if (componentType === null || componentType === undefined) {
                throw new RequiredError('componentType','Required parameter componentType was null or undefined when calling metadataComponentsComponentTypeGet.');
            }
            const localVarPath = `/metadata/components/{component_type}`
                .replace(`{${"component_type"}}`, encodeURIComponent(String(componentType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Component Metadata
         * @throws {RequiredError}
         */
        metadataComponentsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/components`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Template Node Metadata
         * @throws {RequiredError}
         */
        metadataObjectsBindersTemplatesBindernodesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/binders/templates/bindernodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Template Metadata
         * @throws {RequiredError}
         */
        metadataObjectsBindersTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/binders/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Annotation Placemark Type Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet(placemarkType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'placemarkType' is not null or undefined
            if (placemarkType === null || placemarkType === undefined) {
                throw new RequiredError('placemarkType','Required parameter placemarkType was null or undefined when calling metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet.');
            }
            const localVarPath = `/metadata/objects/documents/annotations/placemarks/types/{placemark_type}`
                .replace(`{${"placemark_type"}}`, encodeURIComponent(String(placemarkType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Annotation Reference Type Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet(referenceType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'referenceType' is not null or undefined
            if (referenceType === null || referenceType === undefined) {
                throw new RequiredError('referenceType','Required parameter referenceType was null or undefined when calling metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet.');
            }
            const localVarPath = `/metadata/objects/documents/annotations/references/types/{reference_type}`
                .replace(`{${"reference_type"}}`, encodeURIComponent(String(referenceType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Annotation Type Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet(annotationType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'annotationType' is not null or undefined
            if (annotationType === null || annotationType === undefined) {
                throw new RequiredError('annotationType','Required parameter annotationType was null or undefined when calling metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet.');
            }
            const localVarPath = `/metadata/objects/documents/annotations/types/{annotation_type}`
                .replace(`{${"annotation_type"}}`, encodeURIComponent(String(annotationType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Event SubType Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet(eventType: string, eventSubtype: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'eventType' is not null or undefined
            if (eventType === null || eventType === undefined) {
                throw new RequiredError('eventType','Required parameter eventType was null or undefined when calling metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet.');
            }
            // verify required parameter 'eventSubtype' is not null or undefined
            if (eventSubtype === null || eventSubtype === undefined) {
                throw new RequiredError('eventSubtype','Required parameter eventSubtype was null or undefined when calling metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet.');
            }
            const localVarPath = `/metadata/objects/documents/events/{event_type}/types/{event_subtype}`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"event_subtype"}}`, encodeURIComponent(String(eventSubtype)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Event Types and Subtypes
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsEventsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/documents/events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Lock Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsLockGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/documents/lock`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Common Document Fields
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsPropertiesFindCommonPost(contentType?: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/documents/properties/find_common`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Document Fields
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsPropertiesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/documents/properties`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Template Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/documents/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Document Types
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/documents/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Type
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesTypeGet(type: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling metadataObjectsDocumentsTypesTypeGet.');
            }
            const localVarPath = `/metadata/objects/documents/types/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Type Relationships
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesTypeRelationshipsGet(type: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling metadataObjectsDocumentsTypesTypeRelationshipsGet.');
            }
            const localVarPath = `/metadata/objects/documents/types/{type}/relationships`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Classification
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet(type: string, subtype: string, classification: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet.');
            }
            // verify required parameter 'subtype' is not null or undefined
            if (subtype === null || subtype === undefined) {
                throw new RequiredError('subtype','Required parameter subtype was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet.');
            }
            // verify required parameter 'classification' is not null or undefined
            if (classification === null || classification === undefined) {
                throw new RequiredError('classification','Required parameter classification was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet.');
            }
            const localVarPath = `/metadata/objects/documents/types/{type}/subtypes/{subtype}/classifications/{classification}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"subtype"}}`, encodeURIComponent(String(subtype)))
                .replace(`{${"classification"}}`, encodeURIComponent(String(classification)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Subtype
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesTypeSubtypesSubtypeGet(type: string, subtype: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeGet.');
            }
            // verify required parameter 'subtype' is not null or undefined
            if (subtype === null || subtype === undefined) {
                throw new RequiredError('subtype','Required parameter subtype was null or undefined when calling metadataObjectsDocumentsTypesTypeSubtypesSubtypeGet.');
            }
            const localVarPath = `/metadata/objects/documents/types/{type}/subtypes/{subtype}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"subtype"}}`, encodeURIComponent(String(subtype)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Group Metadata
         * @throws {RequiredError}
         */
        metadataObjectsGroupsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Security Policy Metadata
         * @throws {RequiredError}
         */
        metadataObjectsSecuritypoliciesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/securitypolicies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve User Metadata
         * @throws {RequiredError}
         */
        metadataObjectsUsersGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/objects/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Archived Document Signature Metadata
         * @throws {RequiredError}
         */
        metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/query/archived_documents/relationships/document_signature__sysr`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Signature Metadata
         * @throws {RequiredError}
         */
        metadataQueryDocumentsRelationshipsDocumentSignatureSysrGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/query/documents/relationships/document_signature__sysr`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Collection
         * @throws {RequiredError}
         */
        metadataVobjectsGet(loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/metadata/vobjects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel Raw Object Deployment
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNameActionsCanceldeploymentPost(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling metadataVobjectsObjectNameActionsCanceldeploymentPost.');
            }
            const localVarPath = `/metadata/vobjects/{object_name}/actions/canceldeployment`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Field Metadata
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNameFieldsObjectFieldNameGet(objectName: string, objectFieldName: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling metadataVobjectsObjectNameFieldsObjectFieldNameGet.');
            }
            // verify required parameter 'objectFieldName' is not null or undefined
            if (objectFieldName === null || objectFieldName === undefined) {
                throw new RequiredError('objectFieldName','Required parameter objectFieldName was null or undefined when calling metadataVobjectsObjectNameFieldsObjectFieldNameGet.');
            }
            const localVarPath = `/metadata/vobjects/{object_name}/fields/{object_field_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_field_name"}}`, encodeURIComponent(String(objectFieldName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Metadata
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNameGet(objectName: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling metadataVobjectsObjectNameGet.');
            }
            const localVarPath = `/metadata/vobjects/{object_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Page Layouts
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNamePageLayoutsGet(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling metadataVobjectsObjectNamePageLayoutsGet.');
            }
            const localVarPath = `/metadata/vobjects/{object_name}/page_layouts`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Page Layout Metadata
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNamePageLayoutsLayoutNameGet(objectName: string, layoutName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling metadataVobjectsObjectNamePageLayoutsLayoutNameGet.');
            }
            // verify required parameter 'layoutName' is not null or undefined
            if (layoutName === null || layoutName === undefined) {
                throw new RequiredError('layoutName','Required parameter layoutName was null or undefined when calling metadataVobjectsObjectNamePageLayoutsLayoutNameGet.');
            }
            const localVarPath = `/metadata/vobjects/{object_name}/page_layouts/{layout_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"layout_name"}}`, encodeURIComponent(String(layoutName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Email Notification Histories
         * @throws {RequiredError}
         */
        notificationsHistoriesGet(startDate?: string, endDate?: string, allDates?: boolean, formatResult?: string, limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/notifications/histories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = ((startDate:any):string);
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = ((endDate:any):string);
            }

            if (allDates !== undefined) {
                localVarQueryParameter['all_dates'] = ((allDates:any):string);
            }

            if (formatResult !== undefined) {
                localVarQueryParameter['format_result'] = ((formatResult:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Bulk Workflow Action Details
         * @throws {RequiredError}
         */
        objectWorkflowActionsActionGet(action: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling objectWorkflowActionsActionGet.');
            }
            const localVarPath = `/object/workflow/actions/{action}`
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Workflow Actions on Multiple Workflows
         * @throws {RequiredError}
         */
        objectWorkflowActionsActionPost(action: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'action' is not null or undefined
            if (action === null || action === undefined) {
                throw new RequiredError('action','Required parameter action was null or undefined when calling objectWorkflowActionsActionPost.');
            }
            const localVarPath = `/object/workflow/actions/{action}`
                .replace(`{${"action"}}`, encodeURIComponent(String(action)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel Workflow Tasks
         * @throws {RequiredError}
         */
        objectWorkflowActionsCanceltasksPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/object/workflow/actions/canceltasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel Workflows
         * @throws {RequiredError}
         */
        objectWorkflowActionsCancelworkflowsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/object/workflow/actions/cancelworkflows`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Bulk Workflow Actions
         * @throws {RequiredError}
         */
        objectWorkflowActionsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/object/workflow/actions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reassign Workflow Tasks
         * @throws {RequiredError}
         */
        objectWorkflowActionsReassigntasksPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/object/workflow/actions/reassigntasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace Workflow Owner
         * @throws {RequiredError}
         */
        objectWorkflowActionsReplaceworkflowownerPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/object/workflow/actions/replaceworkflowowner`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Export Results
         * @throws {RequiredError}
         */
        objectsBindersActionsExportJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling objectsBindersActionsExportJobIdResultsGet.');
            }
            const localVarPath = `/objects/binders/actions/export/{job_id}/results`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Binder (Latest Version)
         * @throws {RequiredError}
         */
        objectsBindersBinderIdActionsExportPost(binderId: string, source?: boolean, renditiontype?: string, docversion?: string, attachments?: string, _export?: string, docfield?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdActionsExportPost.');
            }
            const localVarPath = `/objects/binders/{binder_id}/actions/export`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (source !== undefined) {
                localVarQueryParameter['source'] = ((source:any):string);
            }

            if (renditiontype !== undefined) {
                localVarQueryParameter['renditiontype'] = ((renditiontype:any):string);
            }

            if (docversion !== undefined) {
                localVarQueryParameter['docversion'] = ((docversion:any):string);
            }

            if (attachments !== undefined) {
                localVarQueryParameter['attachments'] = ((attachments:any):string);
            }

            if (_export !== undefined) {
                localVarQueryParameter['export'] = ((_export:any):string);
            }

            if (docfield !== undefined) {
                localVarQueryParameter['docfield'] = ((docfield:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Binder Auto-Filing
         * @throws {RequiredError}
         */
        objectsBindersBinderIdActionsPost(binderId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdActionsPost.');
            }
            const localVarPath = `/objects/binders/{binder_id}/actions`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Binding Rule
         * @throws {RequiredError}
         */
        objectsBindersBinderIdBindingRulePut(binderId: string, contentType?: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdBindingRulePut.');
            }
            const localVarPath = `/objects/binders/{binder_id}/binding_rule`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDelete(binderId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdDelete.');
            }
            const localVarPath = `/objects/binders/{binder_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Binder Document Binding Rule
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDocumentsNodeIdBindingRulePut(binderId: string, nodeId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdDocumentsNodeIdBindingRulePut.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling objectsBindersBinderIdDocumentsNodeIdBindingRulePut.');
            }
            const localVarPath = `/objects/binders/{binder_id}/documents/{node_id}/binding_rule`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Document to Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDocumentsPost(binderId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdDocumentsPost.');
            }
            const localVarPath = `/objects/binders/{binder_id}/documents`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Document from Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDocumentsSectionIdDelete(binderId: string, sectionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdDocumentsSectionIdDelete.');
            }
            // verify required parameter 'sectionId' is not null or undefined
            if (sectionId === null || sectionId === undefined) {
                throw new RequiredError('sectionId','Required parameter sectionId was null or undefined when calling objectsBindersBinderIdDocumentsSectionIdDelete.');
            }
            const localVarPath = `/objects/binders/{binder_id}/documents/{section_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"section_id"}}`, encodeURIComponent(String(sectionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move Document in Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDocumentsSectionIdPut(binderId: string, sectionId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdDocumentsSectionIdPut.');
            }
            // verify required parameter 'sectionId' is not null or undefined
            if (sectionId === null || sectionId === undefined) {
                throw new RequiredError('sectionId','Required parameter sectionId was null or undefined when calling objectsBindersBinderIdDocumentsSectionIdPut.');
            }
            const localVarPath = `/objects/binders/{binder_id}/documents/{section_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"section_id"}}`, encodeURIComponent(String(sectionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdGet(binderId: string, depth?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdGet.');
            }
            const localVarPath = `/objects/binders/{binder_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = ((depth:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Binder Version
         * @throws {RequiredError}
         */
        objectsBindersBinderIdPost(binderId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdPost.');
            }
            const localVarPath = `/objects/binders/{binder_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdPut(binderId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdPut.');
            }
            const localVarPath = `/objects/binders/{binder_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Users & Groups from Roles on a Single Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete(binderId: string, roleNameAndUserOrGroup: string, id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete.');
            }
            // verify required parameter 'roleNameAndUserOrGroup' is not null or undefined
            if (roleNameAndUserOrGroup === null || roleNameAndUserOrGroup === undefined) {
                throw new RequiredError('roleNameAndUserOrGroup','Required parameter roleNameAndUserOrGroup was null or undefined when calling objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete.');
            }
            const localVarPath = `/objects/binders/{binder_id}/roles/{role_name_and_user_or_group}/{id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"role_name_and_user_or_group"}}`, encodeURIComponent(String(roleNameAndUserOrGroup)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Binder Section Binding Rule
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsNodeIdBindingRulePut(binderId: string, nodeId: string, contentType?: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdSectionsNodeIdBindingRulePut.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling objectsBindersBinderIdSectionsNodeIdBindingRulePut.');
            }
            const localVarPath = `/objects/binders/{binder_id}/sections/{node_id}/binding_rule`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Binder Section
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsNodeIdPut(binderId: string, nodeId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdSectionsNodeIdPut.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling objectsBindersBinderIdSectionsNodeIdPut.');
            }
            const localVarPath = `/objects/binders/{binder_id}/sections/{node_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Binder Section
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsPost(binderId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdSectionsPost.');
            }
            const localVarPath = `/objects/binders/{binder_id}/sections`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Binder Section
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsSectionIdDelete(binderId: string, sectionId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdSectionsSectionIdDelete.');
            }
            // verify required parameter 'sectionId' is not null or undefined
            if (sectionId === null || sectionId === undefined) {
                throw new RequiredError('sectionId','Required parameter sectionId was null or undefined when calling objectsBindersBinderIdSectionsSectionIdDelete.');
            }
            const localVarPath = `/objects/binders/{binder_id}/sections/{section_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"section_id"}}`, encodeURIComponent(String(sectionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Sections
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsSectionIdGet(binderId: string, sectionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdSectionsSectionIdGet.');
            }
            // verify required parameter 'sectionId' is not null or undefined
            if (sectionId === null || sectionId === undefined) {
                throw new RequiredError('sectionId','Required parameter sectionId was null or undefined when calling objectsBindersBinderIdSectionsSectionIdGet.');
            }
            const localVarPath = `/objects/binders/{binder_id}/sections/{section_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"section_id"}}`, encodeURIComponent(String(sectionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Binder Versions
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsGet(binderId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdVersionsGet.');
            }
            const localVarPath = `/objects/binders/{binder_id}/versions`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Binder (Specific Version)
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost(binderId: string, majorVersion: string, minorVersion: string, source?: boolean, renditiontype?: string, docversion?: string, attachments?: string, _export?: string, docfield?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost.');
            }
            const localVarPath = `/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (source !== undefined) {
                localVarQueryParameter['source'] = ((source:any):string);
            }

            if (renditiontype !== undefined) {
                localVarQueryParameter['renditiontype'] = ((renditiontype:any):string);
            }

            if (docversion !== undefined) {
                localVarQueryParameter['docversion'] = ((docversion:any):string);
            }

            if (attachments !== undefined) {
                localVarQueryParameter['attachments'] = ((attachments:any):string);
            }

            if (_export !== undefined) {
                localVarQueryParameter['export'] = ((_export:any):string);
            }

            if (docfield !== undefined) {
                localVarQueryParameter['docfield'] = ((docfield:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Binder Version
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete.');
            }
            const localVarPath = `/objects/binders/{binder_id}/versions/{major_version}/{minor_version}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Version
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionGet(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionGet.');
            }
            const localVarPath = `/objects/binders/{binder_id}/versions/{major_version}/{minor_version}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Binder Version
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionPut(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionPut.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionPut.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionPut.');
            }
            const localVarPath = `/objects/binders/{binder_id}/versions/{major_version}/{minor_version}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Binder Relationship
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost.');
            }
            const localVarPath = `/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Binder Relationship
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(binderId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
            }
            // verify required parameter 'relationshipId' is not null or undefined
            if (relationshipId === null || relationshipId === undefined) {
                throw new RequiredError('relationshipId','Required parameter relationshipId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
            }
            const localVarPath = `/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Relationship
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(binderId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
            }
            // verify required parameter 'relationshipId' is not null or undefined
            if (relationshipId === null || relationshipId === undefined) {
                throw new RequiredError('relationshipId','Required parameter relationshipId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
            }
            const localVarPath = `/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Version Section
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet(binderId: string, majorVersion: string, minorVersion: string, sectionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'binderId' is not null or undefined
            if (binderId === null || binderId === undefined) {
                throw new RequiredError('binderId','Required parameter binderId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet.');
            }
            // verify required parameter 'sectionId' is not null or undefined
            if (sectionId === null || sectionId === undefined) {
                throw new RequiredError('sectionId','Required parameter sectionId was null or undefined when calling objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet.');
            }
            const localVarPath = `/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/sections/{section_id}`
                .replace(`{${"binder_id"}}`, encodeURIComponent(String(binderId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"section_id"}}`, encodeURIComponent(String(sectionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Binder Roles
         * @throws {RequiredError}
         */
        objectsBindersIdRolesGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsBindersIdRolesGet.');
            }
            const localVarPath = `/objects/binders/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign Users & Groups to Roles on a Single Binder
         * @throws {RequiredError}
         */
        objectsBindersIdRolesPost(id: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsBindersIdRolesPost.');
            }
            const localVarPath = `/objects/binders/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Role
         * @throws {RequiredError}
         */
        objectsBindersIdRolesRoleNameGet(id: string, roleName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsBindersIdRolesRoleNameGet.');
            }
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling objectsBindersIdRolesRoleNameGet.');
            }
            const localVarPath = `/objects/binders/{id}/roles/{role_name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"role_name"}}`, encodeURIComponent(String(roleName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder User Actions
         * @throws {RequiredError}
         */
        objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet(id: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
            }
            const localVarPath = `/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Entry Criteria
         * @throws {RequiredError}
         */
        objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
            }
            // verify required parameter 'nameV' is not null or undefined
            if (nameV === null || nameV === undefined) {
                throw new RequiredError('nameV','Required parameter nameV was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
            }
            const localVarPath = `/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"name__v"}}`, encodeURIComponent(String(nameV)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Binder User Action
         * @throws {RequiredError}
         */
        objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
            }
            // verify required parameter 'nameV' is not null or undefined
            if (nameV === null || nameV === undefined) {
                throw new RequiredError('nameV','Required parameter nameV was null or undefined when calling objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
            }
            const localVarPath = `/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"name__v"}}`, encodeURIComponent(String(nameV)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve User Actions on Multiple Binders
         * @throws {RequiredError}
         */
        objectsBindersLifecycleActionsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/binders/lifecycle_actions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Bulk Binder User Actions
         * @throws {RequiredError}
         */
        objectsBindersLifecycleActionsUserActionNamePut(userActionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userActionName' is not null or undefined
            if (userActionName === null || userActionName === undefined) {
                throw new RequiredError('userActionName','Required parameter userActionName was null or undefined when calling objectsBindersLifecycleActionsUserActionNamePut.');
            }
            const localVarPath = `/objects/binders/lifecycle_actions/{user_action_name}`
                .replace(`{${"user_action_name"}}`, encodeURIComponent(String(userActionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Binder
         * @throws {RequiredError}
         */
        objectsBindersPost(async?: boolean, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/binders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (async !== undefined) {
                localVarQueryParameter['async'] = ((async:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Template Collection
         * @throws {RequiredError}
         */
        objectsBindersTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/binders/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Binder Template
         * @throws {RequiredError}
         */
        objectsBindersTemplatesPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/binders/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Binder Template
         * @throws {RequiredError}
         */
        objectsBindersTemplatesPut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/binders/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Template Node Attributes
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameBindernodesGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling objectsBindersTemplatesTemplateNameBindernodesGet.');
            }
            const localVarPath = `/objects/binders/templates/{template_name}/bindernodes`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Binder Template Node
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameBindernodesPost(templateName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling objectsBindersTemplatesTemplateNameBindernodesPost.');
            }
            const localVarPath = `/objects/binders/templates/{template_name}/bindernodes`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace Binder Template Nodes
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameBindernodesPut(templateName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling objectsBindersTemplatesTemplateNameBindernodesPut.');
            }
            const localVarPath = `/objects/binders/templates/{template_name}/bindernodes`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Binder Template
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameDelete(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling objectsBindersTemplatesTemplateNameDelete.');
            }
            const localVarPath = `/objects/binders/templates/{template_name}`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Binder Template Attributes
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling objectsBindersTemplatesTemplateNameGet.');
            }
            const localVarPath = `/objects/binders/templates/{template_name}`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Deleted Document IDs
         * @throws {RequiredError}
         */
        objectsDeletionsDocumentsGet(startDate?: string, endDate?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/deletions/documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = ((startDate:any):string);
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = ((endDate:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Deleted Object Record ID
         * @throws {RequiredError}
         */
        objectsDeletionsVobjectsObjectNameGet(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling objectsDeletionsVobjectsObjectNameGet.');
            }
            const localVarPath = `/objects/deletions/vobjects/{object_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Document Workflows
         * @throws {RequiredError}
         */
        objectsDocumentsActionsGet(loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/actions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Controlled Copy Job Results
         * @throws {RequiredError}
         */
        objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet(lifecycleAndStateAndAction: string, jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'lifecycleAndStateAndAction' is not null or undefined
            if (lifecycleAndStateAndAction === null || lifecycleAndStateAndAction === undefined) {
                throw new RequiredError('lifecycleAndStateAndAction','Required parameter lifecycleAndStateAndAction was null or undefined when calling objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet.');
            }
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet.');
            }
            const localVarPath = `/objects/documents/actions/{lifecycle_and_state_and_action}/{job_id}/results`
                .replace(`{${"lifecycle_and_state_and_action"}}`, encodeURIComponent(String(lifecycleAndStateAndAction)))
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Workflow Details
         * @throws {RequiredError}
         */
        objectsDocumentsActionsWorkflowNameGet(workflowName: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'workflowName' is not null or undefined
            if (workflowName === null || workflowName === undefined) {
                throw new RequiredError('workflowName','Required parameter workflowName was null or undefined when calling objectsDocumentsActionsWorkflowNameGet.');
            }
            const localVarPath = `/objects/documents/actions/{workflow_name}`
                .replace(`{${"workflow_name"}}`, encodeURIComponent(String(workflowName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Document Workflow
         * @throws {RequiredError}
         */
        objectsDocumentsActionsWorkflowNamePost(workflowName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'workflowName' is not null or undefined
            if (workflowName === null || workflowName === undefined) {
                throw new RequiredError('workflowName','Required parameter workflowName was null or undefined when calling objectsDocumentsActionsWorkflowNamePost.');
            }
            const localVarPath = `/objects/documents/actions/{workflow_name}`
                .replace(`{${"workflow_name"}}`, encodeURIComponent(String(workflowName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Annotations
         * @throws {RequiredError}
         */
        objectsDocumentsAnnotationsBatchDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/annotations/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Multiple Annotations
         * @throws {RequiredError}
         */
        objectsDocumentsAnnotationsBatchPost(authorization: string, contentType: string, accept: string, xVaultAPIClientID: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'authorization' is not null or undefined
            if (authorization === null || authorization === undefined) {
                throw new RequiredError('authorization','Required parameter authorization was null or undefined when calling objectsDocumentsAnnotationsBatchPost.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling objectsDocumentsAnnotationsBatchPost.');
            }
            // verify required parameter 'accept' is not null or undefined
            if (accept === null || accept === undefined) {
                throw new RequiredError('accept','Required parameter accept was null or undefined when calling objectsDocumentsAnnotationsBatchPost.');
            }
            // verify required parameter 'xVaultAPIClientID' is not null or undefined
            if (xVaultAPIClientID === null || xVaultAPIClientID === undefined) {
                throw new RequiredError('xVaultAPIClientID','Required parameter xVaultAPIClientID was null or undefined when calling objectsDocumentsAnnotationsBatchPost.');
            }
            const localVarPath = `/objects/documents/annotations/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Annotations
         * @throws {RequiredError}
         */
        objectsDocumentsAnnotationsBatchPut(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/annotations/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Annotation Replies
         * @throws {RequiredError}
         */
        objectsDocumentsAnnotationsRepliesBatchPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/annotations/replies/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Multiple Document Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsAttachmentsBatchDelete(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/attachments/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Multiple Document Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsAttachmentsBatchPost(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/attachments/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Multiple Document Attachment Descriptions
         * @throws {RequiredError}
         */
        objectsDocumentsAttachmentsBatchPut(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/attachments/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Export Results
         * @throws {RequiredError}
         */
        objectsDocumentsBatchActionsFileextractJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling objectsDocumentsBatchActionsFileextractJobIdResultsGet.');
            }
            const localVarPath = `/objects/documents/batch/actions/fileextract/{job_id}/results`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchActionsFileextractPost(source?: boolean, renditions?: boolean, allversions?: boolean, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/batch/actions/fileextract`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (source !== undefined) {
                localVarQueryParameter['source'] = ((source:any):string);
            }

            if (renditions !== undefined) {
                localVarQueryParameter['renditions'] = ((renditions:any):string);
            }

            if (allversions !== undefined) {
                localVarQueryParameter['allversions'] = ((allversions:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reclassify Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchActionsReclassifyPut(authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/batch/actions/reclassify`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Multiple Document Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsBatchActionsRerenderPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/batch/actions/rerender`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchDelete(idParam?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (idParam !== undefined) {
                localVarQueryParameter['idParam'] = ((idParam:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undo Collaborative Authoring Checkout
         * @throws {RequiredError}
         */
        objectsDocumentsBatchLockDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/batch/lock`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchPut(authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Anchor IDs
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAnchorsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAnchorsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/anchors`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Document Annotations to PDF
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAnnotationsFileGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAnnotationsFileGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/annotations/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Document Annotations from PDF
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAnnotationsFilePost(docId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAnnotationsFilePost.');
            }
            const localVarPath = `/objects/documents/{doc_id}/annotations/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Single Document Attachment
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdDelete(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdDelete.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdDelete.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/{attachment_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Document Attachment
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdFileGet(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdFileGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdFileGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/{attachment_id}/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Attachment Metadata
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdGet(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/{attachment_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Document Attachment Description
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdPut(docId: string, attachmentId: string, accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdPut.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdPut.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/{attachment_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Single Document Attachment Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(docId: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Document Attachment Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(docId: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Attachment Version Metadata
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(docId: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore Document Attachment Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(docId: string, attachmentId: string, attachmentVersion: string, restore?: boolean, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (restore !== undefined) {
                localVarQueryParameter['restore'] = ((restore:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Attachment Versions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/{attachment_id}/versions`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download All Document Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsFileGet(docId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsFileGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsGet(docId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Document Attachment
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsPost(docId: string, accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAttachmentsPost.');
            }
            const localVarPath = `/objects/documents/{doc_id}/attachments`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Complete Audit History for a Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAudittrailGet(docId: string, startDate?: string, endDate?: string, formatResult?: string, limit?: string, offset?: string, events?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdAudittrailGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/audittrail`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = ((startDate:any):string);
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = ((endDate:any):string);
            }

            if (formatResult !== undefined) {
                localVarQueryParameter['format_result'] = ((formatResult:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (events !== undefined) {
                localVarQueryParameter['events'] = ((events:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdDelete(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdDelete.');
            }
            const localVarPath = `/objects/documents/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Events
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdEventsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdEventsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/events`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Document File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdFileGet(docId: string, lockDocument?: boolean, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdFileGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (lockDocument !== undefined) {
                localVarQueryParameter['lockDocument'] = ((lockDocument:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Document Lock
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdLockDelete(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdLockDelete.');
            }
            const localVarPath = `/objects/documents/{doc_id}/lock`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Lock
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdLockGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdLockGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/lock`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Document Lock
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdLockPost(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdLockPost.');
            }
            const localVarPath = `/objects/documents/{doc_id}/lock`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download All Document Version Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/{major_version}/{minor_version}/attachments/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Single Document Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdPost(docId: string, suppressRendition?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdPost.');
            }
            const localVarPath = `/objects/documents/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (suppressRendition !== undefined) {
                localVarQueryParameter['suppressRendition'] = ((suppressRendition:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdPut(docId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdPut.');
            }
            const localVarPath = `/objects/documents/{doc_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdRenditionsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/renditions`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Single Document Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsRenditionTypeDelete(docId: string, renditionType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypeDelete.');
            }
            // verify required parameter 'renditionType' is not null or undefined
            if (renditionType === null || renditionType === undefined) {
                throw new RequiredError('renditionType','Required parameter renditionType was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypeDelete.');
            }
            const localVarPath = `/objects/documents/{doc_id}/renditions/{rendition_type}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"rendition_type"}}`, encodeURIComponent(String(renditionType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Document Rendition File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsRenditionTypeGet(docId: string, renditionType: string, steadyState?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypeGet.');
            }
            // verify required parameter 'renditionType' is not null or undefined
            if (renditionType === null || renditionType === undefined) {
                throw new RequiredError('renditionType','Required parameter renditionType was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypeGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/renditions/{rendition_type}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"rendition_type"}}`, encodeURIComponent(String(renditionType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (steadyState !== undefined) {
                localVarQueryParameter['steadyState'] = ((steadyState:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Single Document Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsRenditionTypePost(docId: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypePost.');
            }
            // verify required parameter 'renditionType' is not null or undefined
            if (renditionType === null || renditionType === undefined) {
                throw new RequiredError('renditionType','Required parameter renditionType was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypePost.');
            }
            const localVarPath = `/objects/documents/{doc_id}/renditions/{rendition_type}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"rendition_type"}}`, encodeURIComponent(String(renditionType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace Document Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsRenditionTypePut(docId: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypePut.');
            }
            // verify required parameter 'renditionType' is not null or undefined
            if (renditionType === null || renditionType === undefined) {
                throw new RequiredError('renditionType','Required parameter renditionType was null or undefined when calling objectsDocumentsDocIdRenditionsRenditionTypePut.');
            }
            const localVarPath = `/objects/documents/{doc_id}/renditions/{rendition_type}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"rendition_type"}}`, encodeURIComponent(String(renditionType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Users & Groups from Roles on a Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete(docId: string, roleNameAndUserOrGroup: string, id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete.');
            }
            // verify required parameter 'roleNameAndUserOrGroup' is not null or undefined
            if (roleNameAndUserOrGroup === null || roleNameAndUserOrGroup === undefined) {
                throw new RequiredError('roleNameAndUserOrGroup','Required parameter roleNameAndUserOrGroup was null or undefined when calling objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete.');
            }
            const localVarPath = `/objects/documents/{doc_id}/roles/{role_name_and_user_or_group}/{id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"role_name_and_user_or_group"}}`, encodeURIComponent(String(roleNameAndUserOrGroup)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Version Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/version/{major_version}/{minor_version}/attachments`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Versions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Annotations by ID
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet(docId: string, majorVersion: string, minorVersion: string, annotationId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet.');
            }
            // verify required parameter 'annotationId' is not null or undefined
            if (annotationId === null || annotationId === undefined) {
                throw new RequiredError('annotationId','Required parameter annotationId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Replies of Parent Annotation
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet(docId: string, majorVersion: string, minorVersion: string, annotationId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet.');
            }
            // verify required parameter 'annotationId' is not null or undefined
            if (annotationId === null || annotationId === undefined) {
                throw new RequiredError('annotationId','Required parameter annotationId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}/replies`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Document Version Annotations to PDF
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Document Version Annotations from PDF
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read Annotations by Document Version and Type
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet(docId: string, majorVersion: string, minorVersion: string, limit?: string, offset?: string, annotationTypes?: string, paginationId?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (annotationTypes !== undefined) {
                localVarQueryParameter['annotation_types'] = ((annotationTypes:any):string);
            }

            if (paginationId !== undefined) {
                localVarQueryParameter['pagination_id'] = ((paginationId:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Document Version Attachment Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(docId: string, majorVersion: string, minorVersion: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Version Attachment Versions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet(docId: string, majorVersion: string, minorVersion: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Single Document Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Version Notes as CSV
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/doc-export-annotations-to-csv`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Document Event
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/events`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Video Annotations
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/export-video-annotations`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Document Version File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/file`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Document Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut(docId: string, majorVersion: string, minorVersion: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Relationships
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Single Document Relationship
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Single Document Relationship
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(docId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
            }
            // verify required parameter 'relationshipId' is not null or undefined
            if (relationshipId === null || relationshipId === undefined) {
                throw new RequiredError('relationshipId','Required parameter relationshipId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Relationship
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(docId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
            }
            // verify required parameter 'relationshipId' is not null or undefined
            if (relationshipId === null || relationshipId === undefined) {
                throw new RequiredError('relationshipId','Required parameter relationshipId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"relationship_id"}}`, encodeURIComponent(String(relationshipId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Version Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Document Version Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete.');
            }
            // verify required parameter 'renditionType' is not null or undefined
            if (renditionType === null || renditionType === undefined) {
                throw new RequiredError('renditionType','Required parameter renditionType was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"rendition_type"}}`, encodeURIComponent(String(renditionType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Document Version Rendition File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet.');
            }
            // verify required parameter 'renditionType' is not null or undefined
            if (renditionType === null || renditionType === undefined) {
                throw new RequiredError('renditionType','Required parameter renditionType was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"rendition_type"}}`, encodeURIComponent(String(renditionType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload Document Version Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost.');
            }
            // verify required parameter 'renditionType' is not null or undefined
            if (renditionType === null || renditionType === undefined) {
                throw new RequiredError('renditionType','Required parameter renditionType was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"rendition_type"}}`, encodeURIComponent(String(renditionType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace Document Version Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut.');
            }
            // verify required parameter 'renditionType' is not null or undefined
            if (renditionType === null || renditionType === undefined) {
                throw new RequiredError('renditionType','Required parameter renditionType was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"rendition_type"}}`, encodeURIComponent(String(renditionType)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Document Version Thumbnail File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'docId' is not null or undefined
            if (docId === null || docId === undefined) {
                throw new RequiredError('docId','Required parameter docId was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet.');
            }
            const localVarPath = `/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/thumbnail`
                .replace(`{${"doc_id"}}`, encodeURIComponent(String(docId)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Documents
         * @throws {RequiredError}
         */
        objectsDocumentsGet(namedFilter?: string, scope?: string, versionscope?: string, search?: string, limit?: string, sort?: string, start?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (namedFilter !== undefined) {
                localVarQueryParameter['named_filter'] = ((namedFilter:any):string);
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = ((scope:any):string);
            }

            if (versionscope !== undefined) {
                localVarQueryParameter['versionscope'] = ((versionscope:any):string);
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = ((search:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = ((sort:any):string);
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = ((start:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Document Roles
         * @throws {RequiredError}
         */
        objectsDocumentsIdRolesGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsDocumentsIdRolesGet.');
            }
            const localVarPath = `/objects/documents/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign Users & Groups to Roles on a Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsIdRolesPost(id: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsDocumentsIdRolesPost.');
            }
            const localVarPath = `/objects/documents/{id}/roles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Role
         * @throws {RequiredError}
         */
        objectsDocumentsIdRolesRoleNameGet(id: string, roleName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsDocumentsIdRolesRoleNameGet.');
            }
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling objectsDocumentsIdRolesRoleNameGet.');
            }
            const localVarPath = `/objects/documents/{id}/roles/{role_name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"role_name"}}`, encodeURIComponent(String(roleName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document User Actions
         * @throws {RequiredError}
         */
        objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet(id: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet.');
            }
            const localVarPath = `/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Entry Criteria
         * @throws {RequiredError}
         */
        objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
            }
            // verify required parameter 'nameV' is not null or undefined
            if (nameV === null || nameV === undefined) {
                throw new RequiredError('nameV','Required parameter nameV was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet.');
            }
            const localVarPath = `/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"name__v"}}`, encodeURIComponent(String(nameV)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Document User Action
         * @throws {RequiredError}
         */
        objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
            }
            // verify required parameter 'majorVersion' is not null or undefined
            if (majorVersion === null || majorVersion === undefined) {
                throw new RequiredError('majorVersion','Required parameter majorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
            }
            // verify required parameter 'minorVersion' is not null or undefined
            if (minorVersion === null || minorVersion === undefined) {
                throw new RequiredError('minorVersion','Required parameter minorVersion was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
            }
            // verify required parameter 'nameV' is not null or undefined
            if (nameV === null || nameV === undefined) {
                throw new RequiredError('nameV','Required parameter nameV was null or undefined when calling objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut.');
            }
            const localVarPath = `/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"major_version"}}`, encodeURIComponent(String(majorVersion)))
                .replace(`{${"minor_version"}}`, encodeURIComponent(String(minorVersion)))
                .replace(`{${"name__v"}}`, encodeURIComponent(String(nameV)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve User Actions on Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsLifecycleActionsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/lifecycle_actions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Bulk Document User Actions
         * @throws {RequiredError}
         */
        objectsDocumentsLifecycleActionsUserActionNamePut(userActionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userActionName' is not null or undefined
            if (userActionName === null || userActionName === undefined) {
                throw new RequiredError('userActionName','Required parameter userActionName was null or undefined when calling objectsDocumentsLifecycleActionsUserActionNamePut.');
            }
            const localVarPath = `/objects/documents/lifecycle_actions/{user_action_name}`
                .replace(`{${"user_action_name"}}`, encodeURIComponent(String(userActionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsPost(authorization?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Multiple Document Relationships
         * @throws {RequiredError}
         */
        objectsDocumentsRelationshipsBatchDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/relationships/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Multiple Document Relationships
         * @throws {RequiredError}
         */
        objectsDocumentsRelationshipsBatchPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/relationships/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Multiple Document Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsRenditionsBatchDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/renditions/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Multiple Document Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsRenditionsBatchPost(idParam?: string, largeSizeAsset?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/renditions/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (idParam !== undefined) {
                localVarQueryParameter['idParam'] = ((idParam:any):string);
            }

            if (largeSizeAsset !== undefined) {
                localVarQueryParameter['largeSizeAsset'] = ((largeSizeAsset:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Users and Groups from Roles on Multiple Documents & Binders
         * @throws {RequiredError}
         */
        objectsDocumentsRolesBatchDelete(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/roles/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign Users & Groups to Roles on Multiple Documents & Binders
         * @throws {RequiredError}
         */
        objectsDocumentsRolesBatchPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/roles/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Template Collection
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Single Document Template
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Multiple Document Templates
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesPut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Basic Document Template
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesTemplateNameDelete(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling objectsDocumentsTemplatesTemplateNameDelete.');
            }
            const localVarPath = `/objects/documents/templates/{template_name}`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Document Template File
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesTemplateNameFileGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling objectsDocumentsTemplatesTemplateNameFileGet.');
            }
            const localVarPath = `/objects/documents/templates/{template_name}/file`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Document Template Attributes
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesTemplateNameGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling objectsDocumentsTemplatesTemplateNameGet.');
            }
            const localVarPath = `/objects/documents/templates/{template_name}`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Single Document Template
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesTemplateNamePut(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'templateName' is not null or undefined
            if (templateName === null || templateName === undefined) {
                throw new RequiredError('templateName','Required parameter templateName was null or undefined when calling objectsDocumentsTemplatesTemplateNamePut.');
            }
            const localVarPath = `/objects/documents/templates/{template_name}`
                .replace(`{${"template_name"}}`, encodeURIComponent(String(templateName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Document Tokens
         * @throws {RequiredError}
         */
        objectsDocumentsTokensPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Document Versions
         * @throws {RequiredError}
         */
        objectsDocumentsVersionsBatchActionsFileextractPost(source?: boolean, renditions?: boolean, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/versions/batch/actions/fileextract`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (source !== undefined) {
                localVarQueryParameter['source'] = ((source:any):string);
            }

            if (renditions !== undefined) {
                localVarQueryParameter['renditions'] = ((renditions:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Multiple Document Versions
         * @throws {RequiredError}
         */
        objectsDocumentsVersionsBatchDelete(idParam?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/versions/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (idParam !== undefined) {
                localVarQueryParameter['idParam'] = ((idParam:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Multiple Document Versions
         * @throws {RequiredError}
         */
        objectsDocumentsVersionsBatchPost(idParam?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/documents/versions/batch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (idParam !== undefined) {
                localVarQueryParameter['idParam'] = ((idParam:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Domain Information
         * @throws {RequiredError}
         */
        objectsDomainGet(includeApplication?: boolean, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/domain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (includeApplication !== undefined) {
                localVarQueryParameter['include_application'] = ((includeApplication:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Domains
         * @throws {RequiredError}
         */
        objectsDomainsGet(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/domains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add EDL Matched Documents
         * @throws {RequiredError}
         */
        objectsEdlMatchedDocumentsBatchActionsAddPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/edl_matched_documents/batch/actions/add`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove EDL Matched Documents
         * @throws {RequiredError}
         */
        objectsEdlMatchedDocumentsBatchActionsRemovePost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/edl_matched_documents/batch/actions/remove`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Auto Managed Groups
         * @throws {RequiredError}
         */
        objectsGroupsAutoGet(limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/groups/auto`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Groups
         * @throws {RequiredError}
         */
        objectsGroupsGet(includeImplied?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (includeImplied !== undefined) {
                localVarQueryParameter['includeImplied'] = ((includeImplied:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Group
         * @throws {RequiredError}
         */
        objectsGroupsGroupIdDelete(groupId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling objectsGroupsGroupIdDelete.');
            }
            const localVarPath = `/objects/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Group
         * @throws {RequiredError}
         */
        objectsGroupsGroupIdGet(groupId: string, includeImplied?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling objectsGroupsGroupIdGet.');
            }
            const localVarPath = `/objects/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (includeImplied !== undefined) {
                localVarQueryParameter['includeImplied'] = ((includeImplied:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Group
         * @throws {RequiredError}
         */
        objectsGroupsGroupIdPut(groupId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling objectsGroupsGroupIdPut.');
            }
            const localVarPath = `/objects/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Group 
         * @throws {RequiredError}
         */
        objectsGroupsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Application License Usage
         * @throws {RequiredError}
         */
        objectsLicensesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/licenses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Multi-Record Workflows
         * @throws {RequiredError}
         */
        objectsObjectworkflowsActionsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/objectworkflows/actions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Multi-Record Workflow Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsActionsWorkflowNameGet(workflowName: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'workflowName' is not null or undefined
            if (workflowName === null || workflowName === undefined) {
                throw new RequiredError('workflowName','Required parameter workflowName was null or undefined when calling objectsObjectworkflowsActionsWorkflowNameGet.');
            }
            const localVarPath = `/objects/objectworkflows/actions/{workflow_name}`
                .replace(`{${"workflow_name"}}`, encodeURIComponent(String(workflowName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Multi-Record Workflow
         * @throws {RequiredError}
         */
        objectsObjectworkflowsActionsWorkflowNamePost(workflowName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'workflowName' is not null or undefined
            if (workflowName === null || workflowName === undefined) {
                throw new RequiredError('workflowName','Required parameter workflowName was null or undefined when calling objectsObjectworkflowsActionsWorkflowNamePost.');
            }
            const localVarPath = `/objects/objectworkflows/actions/{workflow_name}`
                .replace(`{${"workflow_name"}}`, encodeURIComponent(String(workflowName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Workflows
         * @throws {RequiredError}
         */
        objectsObjectworkflowsGet(objectV?: string, recordIdV?: string, participant?: string, statusV?: string, offset?: string, pageSize?: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/objectworkflows`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (objectV !== undefined) {
                localVarQueryParameter['object__v'] = ((objectV:any):string);
            }

            if (recordIdV !== undefined) {
                localVarQueryParameter['record_id__v'] = ((recordIdV:any):string);
            }

            if (participant !== undefined) {
                localVarQueryParameter['participant'] = ((participant:any):string);
            }

            if (statusV !== undefined) {
                localVarQueryParameter['status__v'] = ((statusV:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = ((pageSize:any):string);
            }

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Workflow Tasks
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksGet(objectV?: string, recordIdV?: string, assigneeV?: string, statusV?: string, offset?: string, pageSize?: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/objectworkflows/tasks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (objectV !== undefined) {
                localVarQueryParameter['object__v'] = ((objectV:any):string);
            }

            if (recordIdV !== undefined) {
                localVarQueryParameter['record_id__v'] = ((recordIdV:any):string);
            }

            if (assigneeV !== undefined) {
                localVarQueryParameter['assignee__v'] = ((assigneeV:any):string);
            }

            if (statusV !== undefined) {
                localVarQueryParameter['status__v'] = ((statusV:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = ((pageSize:any):string);
            }

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept Single Record Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsAcceptPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsAcceptPost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/accept`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsCancelPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsCancelPost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/cancel`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete Single Record Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsCompletePost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsCompletePost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/complete`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Workflow Task Actions
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsGet(taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsGet.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept Multi-item Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsMdwacceptPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsMdwacceptPost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/mdwaccept`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete Multi-item Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsMdwcompletePost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsMdwcompletePost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/mdwcomplete`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Manage Multi-Item Workflow Content
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/mdwmanagecontent`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reassign Multi-item Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsMdwreassignPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsMdwreassignPost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/mdwreassign`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reassign Single Record Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsReassignPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsReassignPost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/reassign`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Workflow Task Action Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsTaskActionGet(taskId: string, taskAction: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsTaskActionGet.');
            }
            // verify required parameter 'taskAction' is not null or undefined
            if (taskAction === null || taskAction === undefined) {
                throw new RequiredError('taskAction','Required parameter taskAction was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsTaskActionGet.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/{task_action}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"task_action"}}`, encodeURIComponent(String(taskAction)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undo Workflow Task Acceptance
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsUndoacceptPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsUndoacceptPost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/undoaccept`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Workflow Task Due Date
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}/actions/updateduedate`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Workflow Task Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdGet(taskId: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling objectsObjectworkflowsTasksTaskIdGet.');
            }
            const localVarPath = `/objects/objectworkflows/tasks/{task_id}`
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Workflow Actions
         * @throws {RequiredError}
         */
        objectsObjectworkflowsWorkflowIdActionsGet(workflowId: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsGet.');
            }
            const localVarPath = `/objects/objectworkflows/{workflow_id}/actions`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Workflow Action Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsWorkflowIdActionsWorkflowActionGet(workflowId: string, workflowAction: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsWorkflowActionGet.');
            }
            // verify required parameter 'workflowAction' is not null or undefined
            if (workflowAction === null || workflowAction === undefined) {
                throw new RequiredError('workflowAction','Required parameter workflowAction was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsWorkflowActionGet.');
            }
            const localVarPath = `/objects/objectworkflows/{workflow_id}/actions/{workflow_action}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"workflow_action"}}`, encodeURIComponent(String(workflowAction)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Workflow Action
         * @throws {RequiredError}
         */
        objectsObjectworkflowsWorkflowIdActionsWorkflowActionPost(workflowId: string, workflowAction: string, documentsSys?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsWorkflowActionPost.');
            }
            // verify required parameter 'workflowAction' is not null or undefined
            if (workflowAction === null || workflowAction === undefined) {
                throw new RequiredError('workflowAction','Required parameter workflowAction was null or undefined when calling objectsObjectworkflowsWorkflowIdActionsWorkflowActionPost.');
            }
            const localVarPath = `/objects/objectworkflows/{workflow_id}/actions/{workflow_action}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)))
                .replace(`{${"workflow_action"}}`, encodeURIComponent(String(workflowAction)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (documentsSys !== undefined) {
                localVarQueryParameter['documents__sys'] = ((documentsSys:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Workflow Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsWorkflowIdGet(workflowId: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'workflowId' is not null or undefined
            if (workflowId === null || workflowId === undefined) {
                throw new RequiredError('workflowId','Required parameter workflowId was null or undefined when calling objectsObjectworkflowsWorkflowIdGet.');
            }
            const localVarPath = `/objects/objectworkflows/{workflow_id}`
                .replace(`{${"workflow_id"}}`, encodeURIComponent(String(workflowId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Picklists
         * @throws {RequiredError}
         */
        objectsPicklistsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/picklists`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Picklist Values
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNameGet(picklistName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'picklistName' is not null or undefined
            if (picklistName === null || picklistName === undefined) {
                throw new RequiredError('picklistName','Required parameter picklistName was null or undefined when calling objectsPicklistsPicklistNameGet.');
            }
            const localVarPath = `/objects/picklists/{picklist_name}`
                .replace(`{${"picklist_name"}}`, encodeURIComponent(String(picklistName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inactivate Picklist Value
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNamePicklistValueNameDelete(picklistName: string, picklistValueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'picklistName' is not null or undefined
            if (picklistName === null || picklistName === undefined) {
                throw new RequiredError('picklistName','Required parameter picklistName was null or undefined when calling objectsPicklistsPicklistNamePicklistValueNameDelete.');
            }
            // verify required parameter 'picklistValueName' is not null or undefined
            if (picklistValueName === null || picklistValueName === undefined) {
                throw new RequiredError('picklistValueName','Required parameter picklistValueName was null or undefined when calling objectsPicklistsPicklistNamePicklistValueNameDelete.');
            }
            const localVarPath = `/objects/picklists/{picklist_name}/{picklist_value_name}`
                .replace(`{${"picklist_name"}}`, encodeURIComponent(String(picklistName)))
                .replace(`{${"picklist_value_name"}}`, encodeURIComponent(String(picklistValueName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Picklist Value
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNamePicklistValueNamePut(picklistName: string, picklistValueName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'picklistName' is not null or undefined
            if (picklistName === null || picklistName === undefined) {
                throw new RequiredError('picklistName','Required parameter picklistName was null or undefined when calling objectsPicklistsPicklistNamePicklistValueNamePut.');
            }
            // verify required parameter 'picklistValueName' is not null or undefined
            if (picklistValueName === null || picklistValueName === undefined) {
                throw new RequiredError('picklistValueName','Required parameter picklistValueName was null or undefined when calling objectsPicklistsPicklistNamePicklistValueNamePut.');
            }
            const localVarPath = `/objects/picklists/{picklist_name}/{picklist_value_name}`
                .replace(`{${"picklist_name"}}`, encodeURIComponent(String(picklistName)))
                .replace(`{${"picklist_value_name"}}`, encodeURIComponent(String(picklistValueName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Picklist Values
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNamePost(picklistName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'picklistName' is not null or undefined
            if (picklistName === null || picklistName === undefined) {
                throw new RequiredError('picklistName','Required parameter picklistName was null or undefined when calling objectsPicklistsPicklistNamePost.');
            }
            const localVarPath = `/objects/picklists/{picklist_name}`
                .replace(`{${"picklist_name"}}`, encodeURIComponent(String(picklistName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Picklist Value Label
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNamePut(picklistName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'picklistName' is not null or undefined
            if (picklistName === null || picklistName === undefined) {
                throw new RequiredError('picklistName','Required parameter picklistName was null or undefined when calling objectsPicklistsPicklistNamePut.');
            }
            const localVarPath = `/objects/picklists/{picklist_name}`
                .replace(`{${"picklist_name"}}`, encodeURIComponent(String(picklistName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build Production Vault
         * @throws {RequiredError}
         */
        objectsSandboxActionsBuildproductionPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/sandbox/actions/buildproduction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Promote to Production
         * @throws {RequiredError}
         */
        objectsSandboxActionsPromoteproductionPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/sandbox/actions/promoteproduction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Recheck Sandbox Usage Limit
         * @throws {RequiredError}
         */
        objectsSandboxActionsRecheckusagePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/sandbox/actions/recheckusage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change Sandbox Size
         * @throws {RequiredError}
         */
        objectsSandboxBatchChangesizePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/sandbox/batch/changesize`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Sandbox Entitlements
         * @throws {RequiredError}
         */
        objectsSandboxEntitlementsSetPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/sandbox/entitlements/set`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Sandboxes
         * @throws {RequiredError}
         */
        objectsSandboxGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/sandbox`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Sandbox
         * @throws {RequiredError}
         */
        objectsSandboxNameDelete(name: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling objectsSandboxNameDelete.');
            }
            const localVarPath = `/objects/sandbox/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or Refresh Sandbox
         * @throws {RequiredError}
         */
        objectsSandboxPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/sandbox`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Sandbox Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotApiNameActionsUpdatePost(apiName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'apiName' is not null or undefined
            if (apiName === null || apiName === undefined) {
                throw new RequiredError('apiName','Required parameter apiName was null or undefined when calling objectsSandboxSnapshotApiNameActionsUpdatePost.');
            }
            const localVarPath = `/objects/sandbox/snapshot/{api_name}/actions/update`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upgrade Sandbox Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotApiNameActionsUpgradePost(apiName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'apiName' is not null or undefined
            if (apiName === null || apiName === undefined) {
                throw new RequiredError('apiName','Required parameter apiName was null or undefined when calling objectsSandboxSnapshotApiNameActionsUpgradePost.');
            }
            const localVarPath = `/objects/sandbox/snapshot/{api_name}/actions/upgrade`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Sandbox Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotApiNameDelete(apiName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'apiName' is not null or undefined
            if (apiName === null || apiName === undefined) {
                throw new RequiredError('apiName','Required parameter apiName was null or undefined when calling objectsSandboxSnapshotApiNameDelete.');
            }
            const localVarPath = `/objects/sandbox/snapshot/{api_name}`
                .replace(`{${"api_name"}}`, encodeURIComponent(String(apiName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Sandbox Snapshots
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/sandbox/snapshot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Sandbox Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/sandbox/snapshot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh Sandbox from Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxVaultIdActionsRefreshPost(vaultId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling objectsSandboxVaultIdActionsRefreshPost.');
            }
            const localVarPath = `/objects/sandbox/{vault_id}/actions/refresh`
                .replace(`{${"vault_id"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Sandbox Details by ID
         * @throws {RequiredError}
         */
        objectsSandboxVaultIdGet(vaultId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling objectsSandboxVaultIdGet.');
            }
            const localVarPath = `/objects/sandbox/{vault_id}`
                .replace(`{${"vault_id"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Security Policies
         * @throws {RequiredError}
         */
        objectsSecuritypoliciesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/securitypolicies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Security Policy
         * @throws {RequiredError}
         */
        objectsSecuritypoliciesSecurityPolicyNameGet(securityPolicyName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'securityPolicyName' is not null or undefined
            if (securityPolicyName === null || securityPolicyName === undefined) {
                throw new RequiredError('securityPolicyName','Required parameter securityPolicyName was null or undefined when calling objectsSecuritypoliciesSecurityPolicyNameGet.');
            }
            const localVarPath = `/objects/securitypolicies/{security_policy_name}`
                .replace(`{${"security_policy_name"}}`, encodeURIComponent(String(securityPolicyName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Users
         * @throws {RequiredError}
         */
        objectsUsersGet(vaults?: string, excludeVaultMembership?: string, excludeAppLicensing?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/users/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (vaults !== undefined) {
                localVarQueryParameter['vaults'] = ((vaults:any):string);
            }

            if (excludeVaultMembership !== undefined) {
                localVarQueryParameter['exclude_vault_membership'] = ((excludeVaultMembership:any):string);
            }

            if (excludeAppLicensing !== undefined) {
                localVarQueryParameter['exclude_app_licensing'] = ((excludeAppLicensing:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve User
         * @throws {RequiredError}
         */
        objectsUsersIdGet(id: string, excludeVaultMembership?: string, excludeAppLicensing?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsUsersIdGet.');
            }
            const localVarPath = `/objects/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (excludeVaultMembership !== undefined) {
                localVarQueryParameter['exclude_vault_membership'] = ((excludeVaultMembership:any):string);
            }

            if (excludeAppLicensing !== undefined) {
                localVarQueryParameter['exclude_app_licensing'] = ((excludeAppLicensing:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve User Permissions
         * @throws {RequiredError}
         */
        objectsUsersIdPermissionsGet(id: string, filter?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsUsersIdPermissionsGet.');
            }
            const localVarPath = `/objects/users/{id}/permissions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Single User
         * @throws {RequiredError}
         */
        objectsUsersIdPut(id: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling objectsUsersIdPut.');
            }
            const localVarPath = `/objects/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Session User
         * @throws {RequiredError}
         */
        objectsUsersMeGet(excludeVaultMembership?: string, excludeAppLicensing?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (excludeVaultMembership !== undefined) {
                localVarQueryParameter['exclude_vault_membership'] = ((excludeVaultMembership:any):string);
            }

            if (excludeAppLicensing !== undefined) {
                localVarQueryParameter['exclude_app_licensing'] = ((excludeAppLicensing:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change My Password
         * @throws {RequiredError}
         */
        objectsUsersMePasswordPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/users/me/password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve My User Permissions
         * @throws {RequiredError}
         */
        objectsUsersMePermissionsGet(filter?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/users/me/permissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update My User
         * @throws {RequiredError}
         */
        objectsUsersMePut(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Single User
         * @throws {RequiredError}
         */
        objectsUsersPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Multiple Users
         * @throws {RequiredError}
         */
        objectsUsersPut(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable User
         * @throws {RequiredError}
         */
        objectsUsersUserIdDelete(userId: string, domain?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling objectsUsersUserIdDelete.');
            }
            const localVarPath = `/objects/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = ((domain:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Vault Membership
         * @throws {RequiredError}
         */
        objectsUsersUserIdVaultMembershipVaultIdPut(userId: string, vaultId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling objectsUsersUserIdVaultMembershipVaultIdPut.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling objectsUsersUserIdVaultMembershipVaultIdPut.');
            }
            const localVarPath = `/objects/users/{user_id}/vault_membership/{vault_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"vault_id"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Vault Compare
         * @throws {RequiredError}
         */
        objectsVaultActionsComparePost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/vault/actions/compare`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Vault Configuration Report
         * @throws {RequiredError}
         */
        objectsVaultActionsConfigreportPost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/objects/vault/actions/configreport`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Component Definition Query
         * @throws {RequiredError}
         */
        queryComponentsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/query/components`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Next Page URL
         * @throws {RequiredError}
         */
        queryNextPagePost(nextPage: string, authorization?: string, accept?: string, xVaultAPIDescribeQuery?: boolean, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'nextPage' is not null or undefined
            if (nextPage === null || nextPage === undefined) {
                throw new RequiredError('nextPage','Required parameter nextPage was null or undefined when calling queryNextPagePost.');
            }
            const localVarPath = `/query/{next_page}`
                .replace(`{${"next_page"}}`, encodeURIComponent(String(nextPage)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIDescribeQuery !== undefined && xVaultAPIDescribeQuery !== null) {
                localVarHeaderParameter['X-VaultAPI-DescribeQuery'] = ((xVaultAPIDescribeQuery:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submitting a Query
         * @throws {RequiredError}
         */
        queryPost(authorization?: string, accept?: string, xVaultAPIDescribeQuery?: boolean, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/query`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIDescribeQuery !== undefined && xVaultAPIDescribeQuery !== null) {
                localVarHeaderParameter['X-VaultAPI-DescribeQuery'] = ((xVaultAPIDescribeQuery:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Previous Page URL
         * @throws {RequiredError}
         */
        queryPreviousPagePost(previousPage: string, authorization?: string, accept?: string, xVaultAPIDescribeQuery?: boolean, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'previousPage' is not null or undefined
            if (previousPage === null || previousPage === undefined) {
                throw new RequiredError('previousPage','Required parameter previousPage was null or undefined when calling queryPreviousPagePost.');
            }
            const localVarPath = `/query/{previous_page}`
                .replace(`{${"previous_page"}}`, encodeURIComponent(String(previousPage)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIDescribeQuery !== undefined && xVaultAPIDescribeQuery !== null) {
                localVarHeaderParameter['X-VaultAPI-DescribeQuery'] = ((xVaultAPIDescribeQuery:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Current User with SCIM
         * @throws {RequiredError}
         */
        scimV2MeGet(attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/scim/v2/Me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = ((attributes:any):string);
            }

            if (excludedAttributes !== undefined) {
                localVarQueryParameter['excludedAttributes'] = ((excludedAttributes:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Current User with SCIM
         * @throws {RequiredError}
         */
        scimV2MePut(attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/scim/v2/Me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = ((attributes:any):string);
            }

            if (excludedAttributes !== undefined) {
                localVarQueryParameter['excludedAttributes'] = ((excludedAttributes:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All SCIM Resource Types
         * @throws {RequiredError}
         */
        scimV2ResourceTypesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/scim/v2/ResourceTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Single SCIM Resource Type
         * @throws {RequiredError}
         */
        scimV2ResourceTypesTypeGet(type: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling scimV2ResourceTypesTypeGet.');
            }
            const localVarPath = `/scim/v2/ResourceTypes/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All SCIM Schema Information
         * @throws {RequiredError}
         */
        scimV2SchemasGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/scim/v2/Schemas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Single SCIM Schema Information
         * @throws {RequiredError}
         */
        scimV2SchemasIdGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling scimV2SchemasIdGet.');
            }
            const localVarPath = `/scim/v2/Schemas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve SCIM Provider
         * @throws {RequiredError}
         */
        scimV2ServiceProviderConfigGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/scim/v2/ServiceProviderConfig`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve SCIM Resources
         * @throws {RequiredError}
         */
        scimV2TypeGet(type: string, filter?: string, attributes?: string, excludedAttributes?: string, sortBy?: string, sortOrder?: string, startIndex?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling scimV2TypeGet.');
            }
            const localVarPath = `/scim/v2/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = ((attributes:any):string);
            }

            if (excludedAttributes !== undefined) {
                localVarQueryParameter['excludedAttributes'] = ((excludedAttributes:any):string);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = ((sortBy:any):string);
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = ((sortOrder:any):string);
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = ((startIndex:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Single SCIM Resource
         * @throws {RequiredError}
         */
        scimV2TypeIdGet(type: string, id: string, attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling scimV2TypeIdGet.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling scimV2TypeIdGet.');
            }
            const localVarPath = `/scim/v2/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = ((attributes:any):string);
            }

            if (excludedAttributes !== undefined) {
                localVarQueryParameter['excludedAttributes'] = ((excludedAttributes:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Users with SCIM
         * @throws {RequiredError}
         */
        scimV2UsersGet(filter?: string, attributes?: string, excludedAttributes?: string, sortBy?: string, sortOrder?: string, count?: string, startIndex?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/scim/v2/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = ((attributes:any):string);
            }

            if (excludedAttributes !== undefined) {
                localVarQueryParameter['excludedAttributes'] = ((excludedAttributes:any):string);
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = ((sortBy:any):string);
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = ((sortOrder:any):string);
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = ((count:any):string);
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = ((startIndex:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Single User with SCIM
         * @throws {RequiredError}
         */
        scimV2UsersIdGet(id: string, filter?: string, attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling scimV2UsersIdGet.');
            }
            const localVarPath = `/scim/v2/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = ((filter:any):string);
            }

            if (attributes !== undefined) {
                localVarQueryParameter['attributes'] = ((attributes:any):string);
            }

            if (excludedAttributes !== undefined) {
                localVarQueryParameter['excludedAttributes'] = ((excludedAttributes:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update User with SCIM
         * @throws {RequiredError}
         */
        scimV2UsersIdPut(id: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling scimV2UsersIdPut.');
            }
            const localVarPath = `/scim/v2/Users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create User with SCIM
         * @throws {RequiredError}
         */
        scimV2UsersPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/scim/v2/Users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Signing Certificate
         * @throws {RequiredError}
         */
        servicesCertificateCertIdGet(certId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'certId' is not null or undefined
            if (certId === null || certId === undefined) {
                throw new RequiredError('certId','Required parameter certId was null or undefined when calling servicesCertificateCertIdGet.');
            }
            const localVarPath = `/services/certificate/{cert_id}`
                .replace(`{${"cert_id"}}`, encodeURIComponent(String(certId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable Configuration Mode
         * @throws {RequiredError}
         */
        servicesConfigurationModeActionsDisablePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/configuration_mode/actions/disable`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable Configuration Mode
         * @throws {RequiredError}
         */
        servicesConfigurationModeActionsEnablePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/configuration_mode/actions/enable`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Available Direct Data Files
         * @throws {RequiredError}
         */
        servicesDirectdataFilesGet(extractType?: string, startTime?: number, stopTime?: number, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/directdata/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (extractType !== undefined) {
                localVarQueryParameter['extract_type'] = ((extractType:any):string);
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = ((startTime:any):string);
            }

            if (stopTime !== undefined) {
                localVarQueryParameter['stop_time'] = ((stopTime:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Direct Data File
         * @throws {RequiredError}
         */
        servicesDirectdataFilesNameGet(name: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling servicesDirectdataFilesNameGet.');
            }
            const localVarPath = `/services/directdata/files/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Item Content
         * @throws {RequiredError}
         */
        servicesFileStagingItemsContentItemGet(item: string, authorization?: string, accept?: string, range?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling servicesFileStagingItemsContentItemGet.');
            }
            const localVarPath = `/services/file_staging/items/content/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (range !== undefined && range !== null) {
                localVarHeaderParameter['Range'] = ((range:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete File or Folder
         * @throws {RequiredError}
         */
        servicesFileStagingItemsItemDelete(item: string, recursive?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling servicesFileStagingItemsItemDelete.');
            }
            const localVarPath = `/services/file_staging/items/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = ((recursive:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Items at a Path
         * @throws {RequiredError}
         */
        servicesFileStagingItemsItemGet(item: string, recursive?: string, limit?: string, formatResult?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling servicesFileStagingItemsItemGet.');
            }
            const localVarPath = `/services/file_staging/items/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = ((recursive:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (formatResult !== undefined) {
                localVarQueryParameter['format_result'] = ((formatResult:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Folder or File
         * @throws {RequiredError}
         */
        servicesFileStagingItemsItemPut(item: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'item' is not null or undefined
            if (item === null || item === undefined) {
                throw new RequiredError('item','Required parameter item was null or undefined when calling servicesFileStagingItemsItemPut.');
            }
            const localVarPath = `/services/file_staging/items/{item}`
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Folder or File
         * @throws {RequiredError}
         */
        servicesFileStagingItemsPost(authorization?: string, accept?: string, contentMD5?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/file_staging/items`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentMD5 !== undefined && contentMD5 !== null) {
                localVarHeaderParameter['Content-MD5'] = ((contentMD5:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Upload Sessions
         * @throws {RequiredError}
         */
        servicesFileStagingUploadGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/file_staging/upload/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Resumable Upload Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadPost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/file_staging/upload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Abort Upload Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdDelete(uploadSessionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'uploadSessionId' is not null or undefined
            if (uploadSessionId === null || uploadSessionId === undefined) {
                throw new RequiredError('uploadSessionId','Required parameter uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdDelete.');
            }
            const localVarPath = `/services/file_staging/upload/{upload_session_id}`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Upload Session Details
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdGet(uploadSessionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'uploadSessionId' is not null or undefined
            if (uploadSessionId === null || uploadSessionId === undefined) {
                throw new RequiredError('uploadSessionId','Required parameter uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdGet.');
            }
            const localVarPath = `/services/file_staging/upload/{upload_session_id}`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List File Parts Uploaded to Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdPartsGet(uploadSessionId: string, limit?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'uploadSessionId' is not null or undefined
            if (uploadSessionId === null || uploadSessionId === undefined) {
                throw new RequiredError('uploadSessionId','Required parameter uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdPartsGet.');
            }
            const localVarPath = `/services/file_staging/upload/{upload_session_id}/parts`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Commit Upload Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdPost(uploadSessionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'uploadSessionId' is not null or undefined
            if (uploadSessionId === null || uploadSessionId === undefined) {
                throw new RequiredError('uploadSessionId','Required parameter uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdPost.');
            }
            const localVarPath = `/services/file_staging/upload/{upload_session_id}`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload to a Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdPut(uploadSessionId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIFilePartNumber?: string, contentMD5?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'uploadSessionId' is not null or undefined
            if (uploadSessionId === null || uploadSessionId === undefined) {
                throw new RequiredError('uploadSessionId','Required parameter uploadSessionId was null or undefined when calling servicesFileStagingUploadUploadSessionIdPut.');
            }
            const localVarPath = `/services/file_staging/upload/{upload_session_id}`
                .replace(`{${"upload_session_id"}}`, encodeURIComponent(String(uploadSessionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIFilePartNumber !== undefined && xVaultAPIFilePartNumber !== null) {
                localVarHeaderParameter['X-VaultAPI-FilePartNumber'] = ((xVaultAPIFilePartNumber:any):string);
            }

            if (contentMD5 !== undefined && contentMD5 !== null) {
                localVarHeaderParameter['Content-MD5'] = ((contentMD5:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Job Histories
         * @throws {RequiredError}
         */
        servicesJobsHistoriesGet(startDate?: string, endDate?: string, status?: string, limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/jobs/histories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = ((startDate:any):string);
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = ((endDate:any):string);
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = ((status:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Import Bulk Translation File Job Errors
         * @throws {RequiredError}
         */
        servicesJobsJobIdErrorsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling servicesJobsJobIdErrorsGet.');
            }
            const localVarPath = `/services/jobs/{job_id}/errors`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Job Status
         * @throws {RequiredError}
         */
        servicesJobsJobIdGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling servicesJobsJobIdGet.');
            }
            const localVarPath = `/services/jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Import Bulk Translation File Job Summary
         * @throws {RequiredError}
         */
        servicesJobsJobIdSummaryGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling servicesJobsJobIdSummaryGet.');
            }
            const localVarPath = `/services/jobs/{job_id}/summary`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve SDK Job Tasks
         * @throws {RequiredError}
         */
        servicesJobsJobIdTasksGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling servicesJobsJobIdTasksGet.');
            }
            const localVarPath = `/services/jobs/{job_id}/tasks`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Job Monitors
         * @throws {RequiredError}
         */
        servicesJobsMonitorsGet(startDate?: string, endDate?: string, status?: string, limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/jobs/monitors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = ((startDate:any):string);
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = ((endDate:any):string);
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = ((status:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start Job
         * @throws {RequiredError}
         */
        servicesJobsStartNowJobIdPost(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling servicesJobsStartNowJobIdPost.');
            }
            const localVarPath = `/services/jobs/start_now/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extract Data Files
         * @throws {RequiredError}
         */
        servicesLoaderExtractPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/loader/extract`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Load Failure Log Results
         * @throws {RequiredError}
         */
        servicesLoaderJobIdTasksTaskIdFailurelogGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling servicesLoaderJobIdTasksTaskIdFailurelogGet.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling servicesLoaderJobIdTasksTaskIdFailurelogGet.');
            }
            const localVarPath = `/services/loader/{job_id}/tasks/{task_id}/failurelog`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Loader Extract Results
         * @throws {RequiredError}
         */
        servicesLoaderJobIdTasksTaskIdResultsGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling servicesLoaderJobIdTasksTaskIdResultsGet.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling servicesLoaderJobIdTasksTaskIdResultsGet.');
            }
            const localVarPath = `/services/loader/{job_id}/tasks/{task_id}/results`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Loader Extract Renditions Results
         * @throws {RequiredError}
         */
        servicesLoaderJobIdTasksTaskIdResultsRenditionsGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling servicesLoaderJobIdTasksTaskIdResultsRenditionsGet.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling servicesLoaderJobIdTasksTaskIdResultsRenditionsGet.');
            }
            const localVarPath = `/services/loader/{job_id}/tasks/{task_id}/results/renditions`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Load Success Log Results
         * @throws {RequiredError}
         */
        servicesLoaderJobIdTasksTaskIdSuccesslogGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling servicesLoaderJobIdTasksTaskIdSuccesslogGet.');
            }
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling servicesLoaderJobIdTasksTaskIdSuccesslogGet.');
            }
            const localVarPath = `/services/loader/{job_id}/tasks/{task_id}/successlog`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Load Data Objects
         * @throws {RequiredError}
         */
        servicesLoaderLoadPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/loader/load`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Package
         * @throws {RequiredError}
         */
        servicesPackageActionsValidatePost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/package/actions/validate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export Package
         * @throws {RequiredError}
         */
        servicesPackagePost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/package`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Package
         * @throws {RequiredError}
         */
        servicesPackagePut(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/package`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Queues
         * @throws {RequiredError}
         */
        servicesQueuesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/services/queues`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable Delivery
         * @throws {RequiredError}
         */
        servicesQueuesQueueNameActionsDisableDeliveryPut(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'queueName' is not null or undefined
            if (queueName === null || queueName === undefined) {
                throw new RequiredError('queueName','Required parameter queueName was null or undefined when calling servicesQueuesQueueNameActionsDisableDeliveryPut.');
            }
            const localVarPath = `/services/queues/{queue_name}/actions/disable_delivery`
                .replace(`{${"queue_name"}}`, encodeURIComponent(String(queueName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable Delivery
         * @throws {RequiredError}
         */
        servicesQueuesQueueNameActionsEnableDeliveryPut(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'queueName' is not null or undefined
            if (queueName === null || queueName === undefined) {
                throw new RequiredError('queueName','Required parameter queueName was null or undefined when calling servicesQueuesQueueNameActionsEnableDeliveryPut.');
            }
            const localVarPath = `/services/queues/{queue_name}/actions/enable_delivery`
                .replace(`{${"queue_name"}}`, encodeURIComponent(String(queueName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Queue
         * @throws {RequiredError}
         */
        servicesQueuesQueueNameActionsResetPut(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'queueName' is not null or undefined
            if (queueName === null || queueName === undefined) {
                throw new RequiredError('queueName','Required parameter queueName was null or undefined when calling servicesQueuesQueueNameActionsResetPut.');
            }
            const localVarPath = `/services/queues/{queue_name}/actions/reset`
                .replace(`{${"queue_name"}}`, encodeURIComponent(String(queueName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Queue Status
         * @throws {RequiredError}
         */
        servicesQueuesQueueNameGet(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'queueName' is not null or undefined
            if (queueName === null || queueName === undefined) {
                throw new RequiredError('queueName','Required parameter queueName was null or undefined when calling servicesQueuesQueueNameGet.');
            }
            const localVarPath = `/services/queues/{queue_name}`
                .replace(`{${"queue_name"}}`, encodeURIComponent(String(queueName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate Imported Package
         * @throws {RequiredError}
         */
        servicesVobjectVaultPackageVPackageIdActionsValidatePost(packageId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling servicesVobjectVaultPackageVPackageIdActionsValidatePost.');
            }
            const localVarPath = `/services/vobject/vault_package__v/{package_id}/actions/validate`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary End Session
         * @throws {RequiredError}
         */
        sessionDelete(accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/session`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Single Client Code Distribution
         * @throws {RequiredError}
         */
        uicodeDistributionsDistributionNameCodeGet(distributionName: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'distributionName' is not null or undefined
            if (distributionName === null || distributionName === undefined) {
                throw new RequiredError('distributionName','Required parameter distributionName was null or undefined when calling uicodeDistributionsDistributionNameCodeGet.');
            }
            const localVarPath = `/uicode/distributions/{distribution_name}/code`
                .replace(`{${"distribution_name"}}`, encodeURIComponent(String(distributionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Single Client Code Distribution
         * @throws {RequiredError}
         */
        uicodeDistributionsDistributionNameDelete(distributionName: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'distributionName' is not null or undefined
            if (distributionName === null || distributionName === undefined) {
                throw new RequiredError('distributionName','Required parameter distributionName was null or undefined when calling uicodeDistributionsDistributionNameDelete.');
            }
            const localVarPath = `/uicode/distributions/{distribution_name}`
                .replace(`{${"distribution_name"}}`, encodeURIComponent(String(distributionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Single Client Code Distribution Metadata
         * @throws {RequiredError}
         */
        uicodeDistributionsDistributionNameGet(distributionName: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'distributionName' is not null or undefined
            if (distributionName === null || distributionName === undefined) {
                throw new RequiredError('distributionName','Required parameter distributionName was null or undefined when calling uicodeDistributionsDistributionNameGet.');
            }
            const localVarPath = `/uicode/distributions/{distribution_name}`
                .replace(`{${"distribution_name"}}`, encodeURIComponent(String(distributionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve All Client Code Distribution Metadata
         * @throws {RequiredError}
         */
        uicodeDistributionsGet(accept?: string, authorization?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/uicode/distributions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add or Replace Single Client Code Distribution
         * @throws {RequiredError}
         */
        uicodeDistributionsPost(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/uicode/distributions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploy Package
         * @throws {RequiredError}
         */
        vobjectVaultPackageVPackageIdActionsDeployPost(packageId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling vobjectVaultPackageVPackageIdActionsDeployPost.');
            }
            const localVarPath = `/vobject/vault_package__v/{package_id}/actions/deploy`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Package Deploy Results
         * @throws {RequiredError}
         */
        vobjectVaultPackageVPackageIdActionsDeployResultsGet(packageId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling vobjectVaultPackageVPackageIdActionsDeployResultsGet.');
            }
            const localVarPath = `/vobject/vault_package__v/{package_id}/actions/deploy/results`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Results of Cascade Delete Job
         * @throws {RequiredError}
         */
        vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet(objectName: string, jobStatus: string, jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet.');
            }
            // verify required parameter 'jobStatus' is not null or undefined
            if (jobStatus === null || jobStatus === undefined) {
                throw new RequiredError('jobStatus','Required parameter jobStatus was null or undefined when calling vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet.');
            }
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet.');
            }
            const localVarPath = `/vobjects/cascadedelete/results/{object_name}/{job_status}/{job_id}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"job_status"}}`, encodeURIComponent(String(jobStatus)))
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Results of Deep Copy Job
         * @throws {RequiredError}
         */
        vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet(objectName: string, jobStatus: string, jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet.');
            }
            // verify required parameter 'jobStatus' is not null or undefined
            if (jobStatus === null || jobStatus === undefined) {
                throw new RequiredError('jobStatus','Required parameter jobStatus was null or undefined when calling vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet.');
            }
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet.');
            }
            const localVarPath = `/vobjects/deepcopy/results/{object_name}/{job_status}/{job_id}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"job_status"}}`, encodeURIComponent(String(jobStatus)))
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Placeholder from an EDL Item
         * @throws {RequiredError}
         */
        vobjectsEdlItemVActionsCreateplaceholderPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/vobjects/edl_item__v/actions/createplaceholder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Merge Records Job Log
         * @throws {RequiredError}
         */
        vobjectsMergesJobIdLogGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling vobjectsMergesJobIdLogGet.');
            }
            const localVarPath = `/vobjects/merges/{job_id}/log`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Record Merge Results
         * @throws {RequiredError}
         */
        vobjectsMergesJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling vobjectsMergesJobIdResultsGet.');
            }
            const localVarPath = `/vobjects/merges/{job_id}/results`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Record Merge Status
         * @throws {RequiredError}
         */
        vobjectsMergesJobIdStatusGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'jobId' is not null or undefined
            if (jobId === null || jobId === undefined) {
                throw new RequiredError('jobId','Required parameter jobId was null or undefined when calling vobjectsMergesJobIdStatusGet.');
            }
            const localVarPath = `/vobjects/merges/{job_id}/status`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Object Action on Multiple Records
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsActionNamePost(objectName: string, actionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameActionsActionNamePost.');
            }
            // verify required parameter 'actionName' is not null or undefined
            if (actionName === null || actionName === undefined) {
                throw new RequiredError('actionName','Required parameter actionName was null or undefined when calling vobjectsObjectNameActionsActionNamePost.');
            }
            const localVarPath = `/vobjects/{object_name}/actions/{action_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"action_name"}}`, encodeURIComponent(String(actionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change Object Type
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsChangetypePost(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameActionsChangetypePost.');
            }
            const localVarPath = `/vobjects/{object_name}/actions/changetype`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Record Merge
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsMergePost(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, vobjectsObjectNameActionsMergePostRequestInner?: Array<VobjectsObjectNameActionsMergePostRequestInner>, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameActionsMergePost.');
            }
            const localVarPath = `/vobjects/{object_name}/actions/merge`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (typeof vobjectsObjectNameActionsMergePostRequestInner !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(vobjectsObjectNameActionsMergePostRequestInner != null ? vobjectsObjectNameActionsMergePostRequestInner : {}) : (((vobjectsObjectNameActionsMergePostRequestInner:any):string) || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Roll-up Field Recalculation Status
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsRecalculaterollupsGet(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameActionsRecalculaterollupsGet.');
            }
            const localVarPath = `/vobjects/{object_name}/actions/recalculaterollups`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Recalculate Roll-up Fields
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsRecalculaterollupsPost(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameActionsRecalculaterollupsPost.');
            }
            const localVarPath = `/vobjects/{object_name}/actions/recalculaterollups`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Corporate Currency Fields
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsUpdatecorporatecurrencyPut(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameActionsUpdatecorporatecurrencyPut.');
            }
            const localVarPath = `/vobjects/{object_name}/actions/updatecorporatecurrency`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Multiple Object Record Attachments
         * @throws {RequiredError}
         */
        vobjectsObjectNameAttachmentsBatchDelete(objectName: string, idParam?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameAttachmentsBatchDelete.');
            }
            const localVarPath = `/vobjects/{object_name}/attachments/batch`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (idParam !== undefined) {
                localVarQueryParameter['idParam'] = ((idParam:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Multiple Object Record Attachments
         * @throws {RequiredError}
         */
        vobjectsObjectNameAttachmentsBatchPost(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameAttachmentsBatchPost.');
            }
            const localVarPath = `/vobjects/{object_name}/attachments/batch`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Multiple Object Record Attachment Descriptions
         * @throws {RequiredError}
         */
        vobjectsObjectNameAttachmentsBatchPut(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameAttachmentsBatchPut.');
            }
            const localVarPath = `/vobjects/{object_name}/attachments/batch`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNameDelete(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameDelete.');
            }
            const localVarPath = `/vobjects/{object_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Record Roles
         * @throws {RequiredError}
         */
        vobjectsObjectNameIdRolesRoleNameGet(objectName: string, id: string, roleName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameIdRolesRoleNameGet.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling vobjectsObjectNameIdRolesRoleNameGet.');
            }
            // verify required parameter 'roleName' is not null or undefined
            if (roleName === null || roleName === undefined) {
                throw new RequiredError('roleName','Required parameter roleName was null or undefined when calling vobjectsObjectNameIdRolesRoleNameGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{id}/roles/{role_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"role_name"}}`, encodeURIComponent(String(roleName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object User Actions Details
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsActionNameGet(objectName: string, objectRecordId: string, actionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNameGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNameGet.');
            }
            // verify required parameter 'actionName' is not null or undefined
            if (actionName === null || actionName === undefined) {
                throw new RequiredError('actionName','Required parameter actionName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNameGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/actions/{action_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"action_name"}}`, encodeURIComponent(String(actionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate Object Action on a Single Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsActionNamePost(objectName: string, objectRecordId: string, actionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNamePost.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNamePost.');
            }
            // verify required parameter 'actionName' is not null or undefined
            if (actionName === null || actionName === undefined) {
                throw new RequiredError('actionName','Required parameter actionName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsActionNamePost.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/actions/{action_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"action_name"}}`, encodeURIComponent(String(actionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cascade Delete Object Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsCascadedeletePost(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsCascadedeletePost.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsCascadedeletePost.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/actions/cascadedelete`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deep Copy Object Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsDeepcopyPost(objectName: string, objectRecordId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsDeepcopyPost.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsDeepcopyPost.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/actions/deepcopy`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Record User Actions
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsGet(objectName: string, objectRecordId: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdActionsGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/actions`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (loc !== undefined) {
                localVarQueryParameter['loc'] = ((loc:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Attachment Field File
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet(objectName: string, objectRecordId: string, attachmentFieldName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet.');
            }
            // verify required parameter 'attachmentFieldName' is not null or undefined
            if (attachmentFieldName === null || attachmentFieldName === undefined) {
                throw new RequiredError('attachmentFieldName','Required parameter attachmentFieldName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_field_name"}}`, encodeURIComponent(String(attachmentFieldName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Attachment Field File
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost(objectName: string, objectRecordId: string, attachmentFieldName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost.');
            }
            // verify required parameter 'attachmentFieldName' is not null or undefined
            if (attachmentFieldName === null || attachmentFieldName === undefined) {
                throw new RequiredError('attachmentFieldName','Required parameter attachmentFieldName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_field_name"}}`, encodeURIComponent(String(attachmentFieldName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download All Attachment Field Files
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachment_fields/file`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Object Record Attachment
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Record Attachment Metadata
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Object Record Attachment Description
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Object Record Attachment Version
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Object Record Attachment File
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}/file`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Record Attachment Version Metadata
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore Object Record Attachment Version
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, restore?: boolean, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
            }
            // verify required parameter 'attachmentVersion' is not null or undefined
            if (attachmentVersion === null || attachmentVersion === undefined) {
                throw new RequiredError('attachmentVersion','Required parameter attachmentVersion was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)))
                .replace(`{${"attachment_version"}}`, encodeURIComponent(String(attachmentVersion)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (restore !== undefined) {
                localVarQueryParameter['restore'] = ((restore:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Record Attachment Versions
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download All Object Record Attachment Files
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsFileGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsFileGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsFileGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments/file`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Record Attachments
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Object Record Attachment
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsPost(objectName: string, objectRecordId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsPost.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAttachmentsPost.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/attachments`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Complete Audit History for a Single Object Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAudittrailGet(objectName: string, objectRecordId: string, startDate?: string, endDate?: string, formatResult?: string, limit?: string, offset?: string, events?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdAudittrailGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdAudittrailGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}/audittrail`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = ((startDate:any):string);
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = ((endDate:any):string);
            }

            if (formatResult !== undefined) {
                localVarQueryParameter['format_result'] = ((formatResult:any):string);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (events !== undefined) {
                localVarQueryParameter['events'] = ((events:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Object Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameObjectRecordIdGet.');
            }
            // verify required parameter 'objectRecordId' is not null or undefined
            if (objectRecordId === null || objectRecordId === undefined) {
                throw new RequiredError('objectRecordId','Required parameter objectRecordId was null or undefined when calling vobjectsObjectNameObjectRecordIdGet.');
            }
            const localVarPath = `/vobjects/{object_name}/{object_record_id}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)))
                .replace(`{${"object_record_id"}}`, encodeURIComponent(String(objectRecordId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create & Upsert Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNamePost(objectName: string, idParam?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPINoTriggers?: boolean, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNamePost.');
            }
            const localVarPath = `/vobjects/{object_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (idParam !== undefined) {
                localVarQueryParameter['idParam'] = ((idParam:any):string);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPINoTriggers !== undefined && xVaultAPINoTriggers !== null) {
                localVarHeaderParameter['X-VaultAPI-NoTriggers'] = ((xVaultAPINoTriggers:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNamePut(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPINoTriggers?: boolean, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNamePut.');
            }
            const localVarPath = `/vobjects/{object_name}`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIMigrationMode !== undefined && xVaultAPIMigrationMode !== null) {
                localVarHeaderParameter['X-VaultAPI-MigrationMode'] = ((xVaultAPIMigrationMode:any):string);
            }

            if (xVaultAPINoTriggers !== undefined && xVaultAPINoTriggers !== null) {
                localVarHeaderParameter['X-VaultAPI-NoTriggers'] = ((xVaultAPINoTriggers:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Users & Groups from Roles on Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNameRolesDelete(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameRolesDelete.');
            }
            const localVarPath = `/vobjects/{object_name}/roles`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign Users & Groups to Roles on Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNameRolesPost(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'objectName' is not null or undefined
            if (objectName === null || objectName === undefined) {
                throw new RequiredError('objectName','Required parameter objectName was null or undefined when calling vobjectsObjectNameRolesPost.');
            }
            const localVarPath = `/vobjects/{object_name}/roles`
                .replace(`{${"object_name"}}`, encodeURIComponent(String(objectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = ((contentType:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Outbound Package Dependencies
         * @throws {RequiredError}
         */
        vobjectsOutboundPackageVPackageIdDependenciesGet(packageId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling vobjectsOutboundPackageVPackageIdDependenciesGet.');
            }
            const localVarPath = `/vobjects/outbound_package__v/{package_id}/dependencies`
                .replace(`{${"package_id"}}`, encodeURIComponent(String(packageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = ((authorization:any):string);
            }

            if (accept !== undefined && accept !== null) {
                localVarHeaderParameter['Accept'] = ((accept:any):string);
            }

            if (xVaultAPIClientID !== undefined && xVaultAPIClientID !== null) {
                localVarHeaderParameter['X-VaultAPI-ClientID'] = ((xVaultAPIClientID:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type DefaultApiType = { 
    apiGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    apiMdlComponentsComponentTypeAndRecordNameFilesGet(componentTypeAndRecordName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    apiMdlComponentsComponentTypeAndRecordNameGet(componentTypeAndRecordName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    apiMdlExecuteAsyncJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    apiMdlExecuteAsyncPost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    apiMdlExecutePost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    apiMdlFilesPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    audittrailAuditTrailTypeGet(auditTrailType: string, startDate?: string, endDate?: string, allDates?: string, formatResult?: string, limit?: string, offset?: string, objects?: string, events?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    authDiscoveryPost(accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    authOauthSessionOathOidcProfileIdPost(oathOidcProfileId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    authPost(contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeClassNameDelete(className: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeClassNameDisablePut(className: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeClassNameEnablePut(className: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeClassNameGet(className: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeProfilerGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeProfilerPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeProfilerSessionNameActionsEndPost(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeProfilerSessionNameDelete(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeProfilerSessionNameGet(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codeProfilerSessionNameResultsGet(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    codePut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    compositesTreesEdlHierarchyOrTemplateActionsListnodesPost(edlHierarchyOrTemplate: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    compositesTreesEdlHierarchyOrTemplateGet(edlHierarchyOrTemplate: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    compositesTreesEdlHierarchyVParentNodeIdChildrenGet(parentNodeId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    compositesTreesEdlHierarchyVParentNodeIdChildrenPut(parentNodeId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    configurationComponentTypeAndRecordNameGet(componentTypeAndRecordName: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    configurationComponentTypeGet(componentType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    configurationObjectNameAndObjectTypeGet(objectNameAndObjectType: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    configurationObjecttypeGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    configurationRoleAssignmentRuleDelete(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    configurationRoleAssignmentRuleGet(lifecycleV?: string, roleV?: string, productV?: string, countryV?: string, studyV?: string, studyCountryV?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    configurationRoleAssignmentRulePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    configurationRoleAssignmentRulePut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    delegationLoginPost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    delegationVaultsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    keepAlivePost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    limitsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    logsApiUsageGet(_date?: string, logFormat?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    logsCodeDebugGet(userId?: string, includeInactive?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    logsCodeDebugIdActionsResetDelete(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    logsCodeDebugIdActionsResetPost(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    logsCodeDebugIdFilesGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    logsCodeDebugIdGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    logsCodeDebugPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    logsCodeRuntimeGet(_date?: string, logFormat?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    messagesMessageTypeActionsImportPost(messageType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    messagesMessageTypeLanguageLangActionsExportPost(messageType: string, lang: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataAudittrailAuditTrailTypeGet(auditTrailType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataAudittrailGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataComponentsComponentTypeGet(componentType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataComponentsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsBindersTemplatesBindernodesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsBindersTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet(placemarkType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet(referenceType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet(annotationType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet(eventType: string, eventSubtype: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsEventsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsLockGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsPropertiesFindCommonPost(contentType?: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsPropertiesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsTypesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsTypesTypeGet(type: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsTypesTypeRelationshipsGet(type: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet(type: string, subtype: string, classification: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsDocumentsTypesTypeSubtypesSubtypeGet(type: string, subtype: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsGroupsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsSecuritypoliciesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataObjectsUsersGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataQueryDocumentsRelationshipsDocumentSignatureSysrGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataVobjectsGet(loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataVobjectsObjectNameActionsCanceldeploymentPost(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataVobjectsObjectNameFieldsObjectFieldNameGet(objectName: string, objectFieldName: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataVobjectsObjectNameGet(objectName: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataVobjectsObjectNamePageLayoutsGet(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    metadataVobjectsObjectNamePageLayoutsLayoutNameGet(objectName: string, layoutName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    notificationsHistoriesGet(startDate?: string, endDate?: string, allDates?: boolean, formatResult?: string, limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectWorkflowActionsActionGet(action: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectWorkflowActionsActionPost(action: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectWorkflowActionsCanceltasksPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectWorkflowActionsCancelworkflowsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectWorkflowActionsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectWorkflowActionsReassigntasksPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectWorkflowActionsReplaceworkflowownerPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersActionsExportJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdActionsExportPost(binderId: string, source?: boolean, renditiontype?: string, docversion?: string, attachments?: string, _export?: string, docfield?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdActionsPost(binderId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdBindingRulePut(binderId: string, contentType?: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdDelete(binderId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdDocumentsNodeIdBindingRulePut(binderId: string, nodeId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdDocumentsPost(binderId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdDocumentsSectionIdDelete(binderId: string, sectionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdDocumentsSectionIdPut(binderId: string, sectionId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdGet(binderId: string, depth?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdPost(binderId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdPut(binderId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete(binderId: string, roleNameAndUserOrGroup: string, id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdSectionsNodeIdBindingRulePut(binderId: string, nodeId: string, contentType?: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdSectionsNodeIdPut(binderId: string, nodeId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdSectionsPost(binderId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdSectionsSectionIdDelete(binderId: string, sectionId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdSectionsSectionIdGet(binderId: string, sectionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdVersionsGet(binderId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost(binderId: string, majorVersion: string, minorVersion: string, source?: boolean, renditiontype?: string, docversion?: string, attachments?: string, _export?: string, docfield?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdVersionsMajorVersionMinorVersionGet(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdVersionsMajorVersionMinorVersionPut(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(binderId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(binderId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet(binderId: string, majorVersion: string, minorVersion: string, sectionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersIdRolesGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersIdRolesPost(id: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersIdRolesRoleNameGet(id: string, roleName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet(id: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersLifecycleActionsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersLifecycleActionsUserActionNamePut(userActionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersPost(async?: boolean, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersTemplatesPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersTemplatesPut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersTemplatesTemplateNameBindernodesGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersTemplatesTemplateNameBindernodesPost(templateName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersTemplatesTemplateNameBindernodesPut(templateName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersTemplatesTemplateNameDelete(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsBindersTemplatesTemplateNameGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDeletionsDocumentsGet(startDate?: string, endDate?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDeletionsVobjectsObjectNameGet(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsActionsGet(loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet(lifecycleAndStateAndAction: string, jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsActionsWorkflowNameGet(workflowName: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsActionsWorkflowNamePost(workflowName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsAnnotationsBatchDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsAnnotationsBatchPost(authorization: string, contentType: string, accept: string, xVaultAPIClientID: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsAnnotationsBatchPut(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsAnnotationsRepliesBatchPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsAttachmentsBatchDelete(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsAttachmentsBatchPost(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsAttachmentsBatchPut(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsBatchActionsFileextractJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsBatchActionsFileextractPost(source?: boolean, renditions?: boolean, allversions?: boolean, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsBatchActionsReclassifyPut(authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsBatchActionsRerenderPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsBatchDelete(idParam?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsBatchLockDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsBatchPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsBatchPut(authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAnchorsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAnnotationsFileGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAnnotationsFilePost(docId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsAttachmentIdDelete(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsAttachmentIdFileGet(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsAttachmentIdGet(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsAttachmentIdPut(docId: string, attachmentId: string, accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(docId: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(docId: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(docId: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(docId: string, attachmentId: string, attachmentVersion: string, restore?: boolean, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsFileGet(docId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsGet(docId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAttachmentsPost(docId: string, accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdAudittrailGet(docId: string, startDate?: string, endDate?: string, formatResult?: string, limit?: string, offset?: string, events?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdDelete(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdEventsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdFileGet(docId: string, lockDocument?: boolean, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdLockDelete(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdLockGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdLockPost(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdPost(docId: string, suppressRendition?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdPut(docId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdRenditionsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdRenditionsRenditionTypeDelete(docId: string, renditionType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdRenditionsRenditionTypeGet(docId: string, renditionType: string, steadyState?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdRenditionsRenditionTypePost(docId: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdRenditionsRenditionTypePut(docId: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete(docId: string, roleNameAndUserOrGroup: string, id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet(docId: string, majorVersion: string, minorVersion: string, annotationId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet(docId: string, majorVersion: string, minorVersion: string, annotationId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet(docId: string, majorVersion: string, minorVersion: string, limit?: string, offset?: string, annotationTypes?: string, paginationId?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(docId: string, majorVersion: string, minorVersion: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet(docId: string, majorVersion: string, minorVersion: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut(docId: string, majorVersion: string, minorVersion: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(docId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(docId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsGet(namedFilter?: string, scope?: string, versionscope?: string, search?: string, limit?: string, sort?: string, start?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsIdRolesGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsIdRolesPost(id: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsIdRolesRoleNameGet(id: string, roleName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet(id: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsLifecycleActionsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsLifecycleActionsUserActionNamePut(userActionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsPost(authorization?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsRelationshipsBatchDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsRelationshipsBatchPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsRenditionsBatchDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsRenditionsBatchPost(idParam?: string, largeSizeAsset?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsRolesBatchDelete(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsRolesBatchPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsTemplatesPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsTemplatesPut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsTemplatesTemplateNameDelete(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsTemplatesTemplateNameFileGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsTemplatesTemplateNameGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsTemplatesTemplateNamePut(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsTokensPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsVersionsBatchActionsFileextractPost(source?: boolean, renditions?: boolean, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsVersionsBatchDelete(idParam?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDocumentsVersionsBatchPost(idParam?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDomainGet(includeApplication?: boolean, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsDomainsGet(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsEdlMatchedDocumentsBatchActionsAddPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsEdlMatchedDocumentsBatchActionsRemovePost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsGroupsAutoGet(limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsGroupsGet(includeImplied?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsGroupsGroupIdDelete(groupId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsGroupsGroupIdGet(groupId: string, includeImplied?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsGroupsGroupIdPut(groupId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsGroupsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsLicensesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsActionsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsActionsWorkflowNameGet(workflowName: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsActionsWorkflowNamePost(workflowName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsGet(objectV?: string, recordIdV?: string, participant?: string, statusV?: string, offset?: string, pageSize?: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksGet(objectV?: string, recordIdV?: string, assigneeV?: string, statusV?: string, offset?: string, pageSize?: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsAcceptPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsCancelPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsCompletePost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsGet(taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsMdwacceptPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsMdwcompletePost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsMdwreassignPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsReassignPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsTaskActionGet(taskId: string, taskAction: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsUndoacceptPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsTasksTaskIdGet(taskId: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsWorkflowIdActionsGet(workflowId: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsWorkflowIdActionsWorkflowActionGet(workflowId: string, workflowAction: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsWorkflowIdActionsWorkflowActionPost(workflowId: string, workflowAction: string, documentsSys?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsObjectworkflowsWorkflowIdGet(workflowId: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsPicklistsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsPicklistsPicklistNameGet(picklistName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsPicklistsPicklistNamePicklistValueNameDelete(picklistName: string, picklistValueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsPicklistsPicklistNamePicklistValueNamePut(picklistName: string, picklistValueName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsPicklistsPicklistNamePost(picklistName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsPicklistsPicklistNamePut(picklistName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxActionsBuildproductionPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxActionsPromoteproductionPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxActionsRecheckusagePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxBatchChangesizePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxEntitlementsSetPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxNameDelete(name: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxSnapshotApiNameActionsUpdatePost(apiName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxSnapshotApiNameActionsUpgradePost(apiName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxSnapshotApiNameDelete(apiName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxSnapshotGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxSnapshotPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxVaultIdActionsRefreshPost(vaultId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSandboxVaultIdGet(vaultId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSecuritypoliciesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsSecuritypoliciesSecurityPolicyNameGet(securityPolicyName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersGet(vaults?: string, excludeVaultMembership?: string, excludeAppLicensing?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersIdGet(id: string, excludeVaultMembership?: string, excludeAppLicensing?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersIdPermissionsGet(id: string, filter?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersIdPut(id: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersMeGet(excludeVaultMembership?: string, excludeAppLicensing?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersMePasswordPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersMePermissionsGet(filter?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersMePut(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersPut(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersUserIdDelete(userId: string, domain?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsUsersUserIdVaultMembershipVaultIdPut(userId: string, vaultId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsVaultActionsComparePost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    objectsVaultActionsConfigreportPost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    queryComponentsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    queryNextPagePost(nextPage: string, authorization?: string, accept?: string, xVaultAPIDescribeQuery?: boolean, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    queryPost(authorization?: string, accept?: string, xVaultAPIDescribeQuery?: boolean, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    queryPreviousPagePost(previousPage: string, authorization?: string, accept?: string, xVaultAPIDescribeQuery?: boolean, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2MeGet(attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2MePut(attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2ResourceTypesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2ResourceTypesTypeGet(type: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2SchemasGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2SchemasIdGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2ServiceProviderConfigGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2TypeGet(type: string, filter?: string, attributes?: string, excludedAttributes?: string, sortBy?: string, sortOrder?: string, startIndex?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2TypeIdGet(type: string, id: string, attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2UsersGet(filter?: string, attributes?: string, excludedAttributes?: string, sortBy?: string, sortOrder?: string, count?: string, startIndex?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2UsersIdGet(id: string, filter?: string, attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2UsersIdPut(id: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    scimV2UsersPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesCertificateCertIdGet(certId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesConfigurationModeActionsDisablePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesConfigurationModeActionsEnablePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesDirectdataFilesGet(extractType?: string, startTime?: number, stopTime?: number, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesDirectdataFilesNameGet(name: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingItemsContentItemGet(item: string, authorization?: string, accept?: string, range?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingItemsItemDelete(item: string, recursive?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingItemsItemGet(item: string, recursive?: string, limit?: string, formatResult?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingItemsItemPut(item: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingItemsPost(authorization?: string, accept?: string, contentMD5?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingUploadGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingUploadPost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingUploadUploadSessionIdDelete(uploadSessionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingUploadUploadSessionIdGet(uploadSessionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingUploadUploadSessionIdPartsGet(uploadSessionId: string, limit?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingUploadUploadSessionIdPost(uploadSessionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesFileStagingUploadUploadSessionIdPut(uploadSessionId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIFilePartNumber?: string, contentMD5?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesJobsHistoriesGet(startDate?: string, endDate?: string, status?: string, limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesJobsJobIdErrorsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesJobsJobIdGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesJobsJobIdSummaryGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesJobsJobIdTasksGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesJobsMonitorsGet(startDate?: string, endDate?: string, status?: string, limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesJobsStartNowJobIdPost(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesLoaderExtractPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesLoaderJobIdTasksTaskIdFailurelogGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesLoaderJobIdTasksTaskIdResultsGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesLoaderJobIdTasksTaskIdResultsRenditionsGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesLoaderJobIdTasksTaskIdSuccesslogGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesLoaderLoadPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesPackageActionsValidatePost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesPackagePost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesPackagePut(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesQueuesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesQueuesQueueNameActionsDisableDeliveryPut(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesQueuesQueueNameActionsEnableDeliveryPut(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesQueuesQueueNameActionsResetPut(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesQueuesQueueNameGet(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    servicesVobjectVaultPackageVPackageIdActionsValidatePost(packageId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    sessionDelete(accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    uicodeDistributionsDistributionNameCodeGet(distributionName: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    uicodeDistributionsDistributionNameDelete(distributionName: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    uicodeDistributionsDistributionNameGet(distributionName: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    uicodeDistributionsGet(accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    uicodeDistributionsPost(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectVaultPackageVPackageIdActionsDeployPost(packageId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectVaultPackageVPackageIdActionsDeployResultsGet(packageId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet(objectName: string, jobStatus: string, jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet(objectName: string, jobStatus: string, jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsEdlItemVActionsCreateplaceholderPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsMergesJobIdLogGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsMergesJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsMergesJobIdStatusGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameActionsActionNamePost(objectName: string, actionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameActionsChangetypePost(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameActionsMergePost(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, vobjectsObjectNameActionsMergePostRequestInner?: Array<VobjectsObjectNameActionsMergePostRequestInner>, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameActionsRecalculaterollupsGet(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameActionsRecalculaterollupsPost(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameActionsUpdatecorporatecurrencyPut(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameAttachmentsBatchDelete(objectName: string, idParam?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameAttachmentsBatchPost(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameAttachmentsBatchPut(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameDelete(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameIdRolesRoleNameGet(objectName: string, id: string, roleName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdActionsActionNameGet(objectName: string, objectRecordId: string, actionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdActionsActionNamePost(objectName: string, objectRecordId: string, actionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdActionsCascadedeletePost(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdActionsDeepcopyPost(objectName: string, objectRecordId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdActionsGet(objectName: string, objectRecordId: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet(objectName: string, objectRecordId: string, attachmentFieldName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost(objectName: string, objectRecordId: string, attachmentFieldName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, restore?: boolean, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsFileGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAttachmentsPost(objectName: string, objectRecordId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdAudittrailGet(objectName: string, objectRecordId: string, startDate?: string, endDate?: string, formatResult?: string, limit?: string, offset?: string, events?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameObjectRecordIdGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNamePost(objectName: string, idParam?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPINoTriggers?: boolean, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNamePut(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPINoTriggers?: boolean, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameRolesDelete(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsObjectNameRolesPost(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,

    vobjectsOutboundPackageVPackageIdDependenciesGet(packageId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions): Promise<Response>,
}

/**
 * DefaultApi - factory function to inject configuration 
 * @export
 */
export const DefaultApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): DefaultApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * 
         * @summary Retrieve API Versions
         * @throws {RequiredError}
         */
        apiGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Content File
         * @throws {RequiredError}
         */
        apiMdlComponentsComponentTypeAndRecordNameFilesGet(componentTypeAndRecordName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiMdlComponentsComponentTypeAndRecordNameFilesGet(componentTypeAndRecordName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Component Record (MDL)
         * @throws {RequiredError}
         */
        apiMdlComponentsComponentTypeAndRecordNameGet(componentTypeAndRecordName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiMdlComponentsComponentTypeAndRecordNameGet(componentTypeAndRecordName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Asynchronous MDL Script Results
         * @throws {RequiredError}
         */
        apiMdlExecuteAsyncJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiMdlExecuteAsyncJobIdResultsGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Execute MDL Script Asynchronously
         * @throws {RequiredError}
         */
        apiMdlExecuteAsyncPost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiMdlExecuteAsyncPost(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Execute MDL Script
         * @throws {RequiredError}
         */
        apiMdlExecutePost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiMdlExecutePost(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Upload Content File
         * @throws {RequiredError}
         */
        apiMdlFilesPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiMdlFilesPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Audit Details
         * @throws {RequiredError}
         */
        audittrailAuditTrailTypeGet(auditTrailType: string, startDate?: string, endDate?: string, allDates?: string, formatResult?: string, limit?: string, offset?: string, objects?: string, events?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).audittrailAuditTrailTypeGet(auditTrailType, startDate, endDate, allDates, formatResult, limit, offset, objects, events, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Authentication Type Discovery
         * @throws {RequiredError}
         */
        authDiscoveryPost(accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).authDiscoveryPost(accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary OAuth 2.0 / OpenID Connect
         * @throws {RequiredError}
         */
        authOauthSessionOathOidcProfileIdPost(oathOidcProfileId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).authOauthSessionOathOidcProfileIdPost(oathOidcProfileId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary User Name and Password
         * @throws {RequiredError}
         */
        authPost(contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).authPost(contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Single Source Code File
         * @throws {RequiredError}
         */
        codeClassNameDelete(className: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeClassNameDelete(className, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Disable Vault Extension
         * @throws {RequiredError}
         */
        codeClassNameDisablePut(className: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeClassNameDisablePut(className, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Enable Vault Extension
         * @throws {RequiredError}
         */
        codeClassNameEnablePut(className: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeClassNameEnablePut(className, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Single Source Code File
         * @throws {RequiredError}
         */
        codeClassNameGet(className: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeClassNameGet(className, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Profiling Sessions
         * @throws {RequiredError}
         */
        codeProfilerGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeProfilerGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Profiling Session
         * @throws {RequiredError}
         */
        codeProfilerPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeProfilerPost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary End Profiling Session
         * @throws {RequiredError}
         */
        codeProfilerSessionNameActionsEndPost(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeProfilerSessionNameActionsEndPost(sessionName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Profiling Session
         * @throws {RequiredError}
         */
        codeProfilerSessionNameDelete(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeProfilerSessionNameDelete(sessionName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Profiling Session
         * @throws {RequiredError}
         */
        codeProfilerSessionNameGet(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeProfilerSessionNameGet(sessionName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Profiling Session Results
         * @throws {RequiredError}
         */
        codeProfilerSessionNameResultsGet(sessionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codeProfilerSessionNameResultsGet(sessionName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Add or Replace Single Source Code File
         * @throws {RequiredError}
         */
        codePut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).codePut(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Specific Root Nodes
         * @throws {RequiredError}
         */
        compositesTreesEdlHierarchyOrTemplateActionsListnodesPost(edlHierarchyOrTemplate: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).compositesTreesEdlHierarchyOrTemplateActionsListnodesPost(edlHierarchyOrTemplate, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Root Nodes
         * @throws {RequiredError}
         */
        compositesTreesEdlHierarchyOrTemplateGet(edlHierarchyOrTemplate: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).compositesTreesEdlHierarchyOrTemplateGet(edlHierarchyOrTemplate, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve a Node\'s Children
         * @throws {RequiredError}
         */
        compositesTreesEdlHierarchyVParentNodeIdChildrenGet(parentNodeId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).compositesTreesEdlHierarchyVParentNodeIdChildrenGet(parentNodeId, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Node Order
         * @throws {RequiredError}
         */
        compositesTreesEdlHierarchyVParentNodeIdChildrenPut(parentNodeId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).compositesTreesEdlHierarchyVParentNodeIdChildrenPut(parentNodeId, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Component Record (XML/JSON)
         * @throws {RequiredError}
         */
        configurationComponentTypeAndRecordNameGet(componentTypeAndRecordName: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).configurationComponentTypeAndRecordNameGet(componentTypeAndRecordName, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Component Record Collection
         * @throws {RequiredError}
         */
        configurationComponentTypeGet(componentType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).configurationComponentTypeGet(componentType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Details from a Specific Object
         * @throws {RequiredError}
         */
        configurationObjectNameAndObjectTypeGet(objectNameAndObjectType: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).configurationObjectNameAndObjectTypeGet(objectNameAndObjectType, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Details from All Object Types
         * @throws {RequiredError}
         */
        configurationObjecttypeGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).configurationObjecttypeGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Lifecycle Role Assignment Override Rules
         * @throws {RequiredError}
         */
        configurationRoleAssignmentRuleDelete(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).configurationRoleAssignmentRuleDelete(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Lifecycle Role Assignment Rules (Default & Override)
         * @throws {RequiredError}
         */
        configurationRoleAssignmentRuleGet(lifecycleV?: string, roleV?: string, productV?: string, countryV?: string, studyV?: string, studyCountryV?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).configurationRoleAssignmentRuleGet(lifecycleV, roleV, productV, countryV, studyV, studyCountryV, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Lifecycle Role Assignment Override Rules
         * @throws {RequiredError}
         */
        configurationRoleAssignmentRulePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).configurationRoleAssignmentRulePost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Lifecycle Role Assignment Rules (Default & Override)
         * @throws {RequiredError}
         */
        configurationRoleAssignmentRulePut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).configurationRoleAssignmentRulePut(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Delegated Session
         * @throws {RequiredError}
         */
        delegationLoginPost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).delegationLoginPost(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Delegations
         * @throws {RequiredError}
         */
        delegationVaultsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).delegationVaultsGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Session Keep Alive
         * @throws {RequiredError}
         */
        keepAlivePost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).keepAlivePost(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Limits on Objects
         * @throws {RequiredError}
         */
        limitsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).limitsGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Daily API Usage
         * @throws {RequiredError}
         */
        logsApiUsageGet(_date?: string, logFormat?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logsApiUsageGet(_date, logFormat, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Debug Logs
         * @throws {RequiredError}
         */
        logsCodeDebugGet(userId?: string, includeInactive?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logsCodeDebugGet(userId, includeInactive, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Debug Log
         * @throws {RequiredError}
         */
        logsCodeDebugIdActionsResetDelete(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logsCodeDebugIdActionsResetDelete(id, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Reset Debug Log
         * @throws {RequiredError}
         */
        logsCodeDebugIdActionsResetPost(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logsCodeDebugIdActionsResetPost(id, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Debug Log Files
         * @throws {RequiredError}
         */
        logsCodeDebugIdFilesGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logsCodeDebugIdFilesGet(id, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Single Debug Log
         * @throws {RequiredError}
         */
        logsCodeDebugIdGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logsCodeDebugIdGet(id, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Debug Log
         * @throws {RequiredError}
         */
        logsCodeDebugPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logsCodeDebugPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download SDK Runtime Log
         * @throws {RequiredError}
         */
        logsCodeRuntimeGet(_date?: string, logFormat?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).logsCodeRuntimeGet(_date, logFormat, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Import Bulk Translation File
         * @throws {RequiredError}
         */
        messagesMessageTypeActionsImportPost(messageType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).messagesMessageTypeActionsImportPost(messageType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Export Bulk Translation File
         * @throws {RequiredError}
         */
        messagesMessageTypeLanguageLangActionsExportPost(messageType: string, lang: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).messagesMessageTypeLanguageLangActionsExportPost(messageType, lang, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Audit Metadata
         * @throws {RequiredError}
         */
        metadataAudittrailAuditTrailTypeGet(auditTrailType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataAudittrailAuditTrailTypeGet(auditTrailType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Audit Types
         * @throws {RequiredError}
         */
        metadataAudittrailGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataAudittrailGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Component Type Metadata
         * @throws {RequiredError}
         */
        metadataComponentsComponentTypeGet(componentType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataComponentsComponentTypeGet(componentType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Component Metadata
         * @throws {RequiredError}
         */
        metadataComponentsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataComponentsGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Template Node Metadata
         * @throws {RequiredError}
         */
        metadataObjectsBindersTemplatesBindernodesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsBindersTemplatesBindernodesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Template Metadata
         * @throws {RequiredError}
         */
        metadataObjectsBindersTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsBindersTemplatesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Annotation Placemark Type Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet(placemarkType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet(placemarkType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Annotation Reference Type Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet(referenceType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet(referenceType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Annotation Type Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet(annotationType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet(annotationType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Event SubType Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet(eventType: string, eventSubtype: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet(eventType, eventSubtype, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Event Types and Subtypes
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsEventsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsEventsGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Lock Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsLockGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsLockGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Common Document Fields
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsPropertiesFindCommonPost(contentType?: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsPropertiesFindCommonPost(contentType, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Document Fields
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsPropertiesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsPropertiesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Template Metadata
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsTemplatesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Document Types
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsTypesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Type
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesTypeGet(type: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsTypesTypeGet(type, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Type Relationships
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesTypeRelationshipsGet(type: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsTypesTypeRelationshipsGet(type, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Classification
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet(type: string, subtype: string, classification: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet(type, subtype, classification, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Subtype
         * @throws {RequiredError}
         */
        metadataObjectsDocumentsTypesTypeSubtypesSubtypeGet(type: string, subtype: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsDocumentsTypesTypeSubtypesSubtypeGet(type, subtype, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Group Metadata
         * @throws {RequiredError}
         */
        metadataObjectsGroupsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsGroupsGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Security Policy Metadata
         * @throws {RequiredError}
         */
        metadataObjectsSecuritypoliciesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsSecuritypoliciesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve User Metadata
         * @throws {RequiredError}
         */
        metadataObjectsUsersGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataObjectsUsersGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Archived Document Signature Metadata
         * @throws {RequiredError}
         */
        metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Signature Metadata
         * @throws {RequiredError}
         */
        metadataQueryDocumentsRelationshipsDocumentSignatureSysrGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataQueryDocumentsRelationshipsDocumentSignatureSysrGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Collection
         * @throws {RequiredError}
         */
        metadataVobjectsGet(loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataVobjectsGet(loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Cancel Raw Object Deployment
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNameActionsCanceldeploymentPost(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataVobjectsObjectNameActionsCanceldeploymentPost(objectName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Field Metadata
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNameFieldsObjectFieldNameGet(objectName: string, objectFieldName: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataVobjectsObjectNameFieldsObjectFieldNameGet(objectName, objectFieldName, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Metadata
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNameGet(objectName: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataVobjectsObjectNameGet(objectName, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Page Layouts
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNamePageLayoutsGet(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataVobjectsObjectNamePageLayoutsGet(objectName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Page Layout Metadata
         * @throws {RequiredError}
         */
        metadataVobjectsObjectNamePageLayoutsLayoutNameGet(objectName: string, layoutName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).metadataVobjectsObjectNamePageLayoutsLayoutNameGet(objectName, layoutName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Email Notification Histories
         * @throws {RequiredError}
         */
        notificationsHistoriesGet(startDate?: string, endDate?: string, allDates?: boolean, formatResult?: string, limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).notificationsHistoriesGet(startDate, endDate, allDates, formatResult, limit, offset, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Bulk Workflow Action Details
         * @throws {RequiredError}
         */
        objectWorkflowActionsActionGet(action: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectWorkflowActionsActionGet(action, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Workflow Actions on Multiple Workflows
         * @throws {RequiredError}
         */
        objectWorkflowActionsActionPost(action: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectWorkflowActionsActionPost(action, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Cancel Workflow Tasks
         * @throws {RequiredError}
         */
        objectWorkflowActionsCanceltasksPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectWorkflowActionsCanceltasksPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Cancel Workflows
         * @throws {RequiredError}
         */
        objectWorkflowActionsCancelworkflowsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectWorkflowActionsCancelworkflowsPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Bulk Workflow Actions
         * @throws {RequiredError}
         */
        objectWorkflowActionsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectWorkflowActionsGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Reassign Workflow Tasks
         * @throws {RequiredError}
         */
        objectWorkflowActionsReassigntasksPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectWorkflowActionsReassigntasksPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Replace Workflow Owner
         * @throws {RequiredError}
         */
        objectWorkflowActionsReplaceworkflowownerPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectWorkflowActionsReplaceworkflowownerPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Export Results
         * @throws {RequiredError}
         */
        objectsBindersActionsExportJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersActionsExportJobIdResultsGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Export Binder (Latest Version)
         * @throws {RequiredError}
         */
        objectsBindersBinderIdActionsExportPost(binderId: string, source?: boolean, renditiontype?: string, docversion?: string, attachments?: string, _export?: string, docfield?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdActionsExportPost(binderId, source, renditiontype, docversion, attachments, _export, docfield, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Refresh Binder Auto-Filing
         * @throws {RequiredError}
         */
        objectsBindersBinderIdActionsPost(binderId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdActionsPost(binderId, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Binding Rule
         * @throws {RequiredError}
         */
        objectsBindersBinderIdBindingRulePut(binderId: string, contentType?: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdBindingRulePut(binderId, contentType, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDelete(binderId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdDelete(binderId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Binder Document Binding Rule
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDocumentsNodeIdBindingRulePut(binderId: string, nodeId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdDocumentsNodeIdBindingRulePut(binderId, nodeId, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Add Document to Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDocumentsPost(binderId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdDocumentsPost(binderId, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Remove Document from Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDocumentsSectionIdDelete(binderId: string, sectionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdDocumentsSectionIdDelete(binderId, sectionId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Move Document in Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdDocumentsSectionIdPut(binderId: string, sectionId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdDocumentsSectionIdPut(binderId, sectionId, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdGet(binderId: string, depth?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdGet(binderId, depth, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Binder Version
         * @throws {RequiredError}
         */
        objectsBindersBinderIdPost(binderId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdPost(binderId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdPut(binderId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdPut(binderId, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Remove Users & Groups from Roles on a Single Binder
         * @throws {RequiredError}
         */
        objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete(binderId: string, roleNameAndUserOrGroup: string, id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete(binderId, roleNameAndUserOrGroup, id, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Binder Section Binding Rule
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsNodeIdBindingRulePut(binderId: string, nodeId: string, contentType?: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdSectionsNodeIdBindingRulePut(binderId, nodeId, contentType, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Binder Section
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsNodeIdPut(binderId: string, nodeId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdSectionsNodeIdPut(binderId, nodeId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Binder Section
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsPost(binderId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdSectionsPost(binderId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Binder Section
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsSectionIdDelete(binderId: string, sectionId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdSectionsSectionIdDelete(binderId, sectionId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Sections
         * @throws {RequiredError}
         */
        objectsBindersBinderIdSectionsSectionIdGet(binderId: string, sectionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdSectionsSectionIdGet(binderId, sectionId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Binder Versions
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsGet(binderId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdVersionsGet(binderId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Export Binder (Specific Version)
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost(binderId: string, majorVersion: string, minorVersion: string, source?: boolean, renditiontype?: string, docversion?: string, attachments?: string, _export?: string, docfield?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost(binderId, majorVersion, minorVersion, source, renditiontype, docversion, attachments, _export, docfield, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Binder Version
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdVersionsMajorVersionMinorVersionDelete(binderId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Version
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionGet(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdVersionsMajorVersionMinorVersionGet(binderId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Binder Version
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionPut(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdVersionsMajorVersionMinorVersionPut(binderId, majorVersion, minorVersion, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Binder Relationship
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost(binderId: string, majorVersion: string, minorVersion: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost(binderId, majorVersion, minorVersion, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Binder Relationship
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(binderId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(binderId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Relationship
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(binderId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(binderId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Version Section
         * @throws {RequiredError}
         */
        objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet(binderId: string, majorVersion: string, minorVersion: string, sectionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet(binderId, majorVersion, minorVersion, sectionId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Binder Roles
         * @throws {RequiredError}
         */
        objectsBindersIdRolesGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersIdRolesGet(id, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Assign Users & Groups to Roles on a Single Binder
         * @throws {RequiredError}
         */
        objectsBindersIdRolesPost(id: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersIdRolesPost(id, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Role
         * @throws {RequiredError}
         */
        objectsBindersIdRolesRoleNameGet(id: string, roleName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersIdRolesRoleNameGet(id, roleName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder User Actions
         * @throws {RequiredError}
         */
        objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet(id: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet(id, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Entry Criteria
         * @throws {RequiredError}
         */
        objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(id, majorVersion, minorVersion, nameV, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Binder User Action
         * @throws {RequiredError}
         */
        objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(id, majorVersion, minorVersion, nameV, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve User Actions on Multiple Binders
         * @throws {RequiredError}
         */
        objectsBindersLifecycleActionsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersLifecycleActionsPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Bulk Binder User Actions
         * @throws {RequiredError}
         */
        objectsBindersLifecycleActionsUserActionNamePut(userActionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersLifecycleActionsUserActionNamePut(userActionName, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Binder
         * @throws {RequiredError}
         */
        objectsBindersPost(async?: boolean, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersPost(async, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Template Collection
         * @throws {RequiredError}
         */
        objectsBindersTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersTemplatesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Binder Template
         * @throws {RequiredError}
         */
        objectsBindersTemplatesPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersTemplatesPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Binder Template
         * @throws {RequiredError}
         */
        objectsBindersTemplatesPut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersTemplatesPut(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Template Node Attributes
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameBindernodesGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersTemplatesTemplateNameBindernodesGet(templateName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Binder Template Node
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameBindernodesPost(templateName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersTemplatesTemplateNameBindernodesPost(templateName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Replace Binder Template Nodes
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameBindernodesPut(templateName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersTemplatesTemplateNameBindernodesPut(templateName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Binder Template
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameDelete(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersTemplatesTemplateNameDelete(templateName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Binder Template Attributes
         * @throws {RequiredError}
         */
        objectsBindersTemplatesTemplateNameGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsBindersTemplatesTemplateNameGet(templateName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Deleted Document IDs
         * @throws {RequiredError}
         */
        objectsDeletionsDocumentsGet(startDate?: string, endDate?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDeletionsDocumentsGet(startDate, endDate, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Deleted Object Record ID
         * @throws {RequiredError}
         */
        objectsDeletionsVobjectsObjectNameGet(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDeletionsVobjectsObjectNameGet(objectName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Document Workflows
         * @throws {RequiredError}
         */
        objectsDocumentsActionsGet(loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsActionsGet(loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Controlled Copy Job Results
         * @throws {RequiredError}
         */
        objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet(lifecycleAndStateAndAction: string, jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet(lifecycleAndStateAndAction, jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Workflow Details
         * @throws {RequiredError}
         */
        objectsDocumentsActionsWorkflowNameGet(workflowName: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsActionsWorkflowNameGet(workflowName, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Document Workflow
         * @throws {RequiredError}
         */
        objectsDocumentsActionsWorkflowNamePost(workflowName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsActionsWorkflowNamePost(workflowName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Annotations
         * @throws {RequiredError}
         */
        objectsDocumentsAnnotationsBatchDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsAnnotationsBatchDelete(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Multiple Annotations
         * @throws {RequiredError}
         */
        objectsDocumentsAnnotationsBatchPost(authorization: string, contentType: string, accept: string, xVaultAPIClientID: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsAnnotationsBatchPost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Annotations
         * @throws {RequiredError}
         */
        objectsDocumentsAnnotationsBatchPut(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsAnnotationsBatchPut(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Add Annotation Replies
         * @throws {RequiredError}
         */
        objectsDocumentsAnnotationsRepliesBatchPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsAnnotationsRepliesBatchPost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Multiple Document Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsAttachmentsBatchDelete(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsAttachmentsBatchDelete(accept, authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Multiple Document Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsAttachmentsBatchPost(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsAttachmentsBatchPost(accept, authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Multiple Document Attachment Descriptions
         * @throws {RequiredError}
         */
        objectsDocumentsAttachmentsBatchPut(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsAttachmentsBatchPut(accept, authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Export Results
         * @throws {RequiredError}
         */
        objectsDocumentsBatchActionsFileextractJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsBatchActionsFileextractJobIdResultsGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Export Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchActionsFileextractPost(source?: boolean, renditions?: boolean, allversions?: boolean, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsBatchActionsFileextractPost(source, renditions, allversions, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Reclassify Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchActionsReclassifyPut(authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsBatchActionsReclassifyPut(authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Multiple Document Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsBatchActionsRerenderPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsBatchActionsRerenderPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchDelete(idParam?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsBatchDelete(idParam, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Undo Collaborative Authoring Checkout
         * @throws {RequiredError}
         */
        objectsDocumentsBatchLockDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsBatchLockDelete(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsBatchPost(authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsBatchPut(authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsBatchPut(authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Anchor IDs
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAnchorsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAnchorsGet(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Export Document Annotations to PDF
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAnnotationsFileGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAnnotationsFileGet(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Import Document Annotations from PDF
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAnnotationsFilePost(docId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAnnotationsFilePost(docId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Single Document Attachment
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdDelete(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsAttachmentIdDelete(docId, attachmentId, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Document Attachment
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdFileGet(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsAttachmentIdFileGet(docId, attachmentId, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Attachment Metadata
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdGet(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsAttachmentIdGet(docId, attachmentId, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Document Attachment Description
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdPut(docId: string, attachmentId: string, accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsAttachmentIdPut(docId, attachmentId, accept, authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Single Document Attachment Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(docId: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(docId, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Document Attachment Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(docId: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(docId, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Attachment Version Metadata
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(docId: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(docId, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Restore Document Attachment Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(docId: string, attachmentId: string, attachmentVersion: string, restore?: boolean, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(docId, attachmentId, attachmentVersion, restore, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Attachment Versions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet(docId: string, attachmentId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet(docId, attachmentId, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download All Document Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsFileGet(docId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsFileGet(docId, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsGet(docId: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsGet(docId, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Document Attachment
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAttachmentsPost(docId: string, accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAttachmentsPost(docId, accept, authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Complete Audit History for a Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdAudittrailGet(docId: string, startDate?: string, endDate?: string, formatResult?: string, limit?: string, offset?: string, events?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdAudittrailGet(docId, startDate, endDate, formatResult, limit, offset, events, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdDelete(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdDelete(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Events
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdEventsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdEventsGet(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Document File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdFileGet(docId: string, lockDocument?: boolean, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdFileGet(docId, lockDocument, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdGet(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Document Lock
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdLockDelete(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdLockDelete(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Lock
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdLockGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdLockGet(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Document Lock
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdLockPost(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdLockPost(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download All Document Version Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet(docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Single Document Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdPost(docId: string, suppressRendition?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdPost(docId, suppressRendition, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdPut(docId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdPut(docId, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdRenditionsGet(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Single Document Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsRenditionTypeDelete(docId: string, renditionType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdRenditionsRenditionTypeDelete(docId, renditionType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Document Rendition File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsRenditionTypeGet(docId: string, renditionType: string, steadyState?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdRenditionsRenditionTypeGet(docId, renditionType, steadyState, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Add Single Document Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsRenditionTypePost(docId: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdRenditionsRenditionTypePost(docId, renditionType, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Replace Document Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRenditionsRenditionTypePut(docId: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdRenditionsRenditionTypePut(docId, renditionType, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Remove Users & Groups from Roles on a Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete(docId: string, roleNameAndUserOrGroup: string, id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete(docId, roleNameAndUserOrGroup, id, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Version Attachments
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet(docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Versions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsGet(docId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsGet(docId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Read Annotations by ID
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet(docId: string, majorVersion: string, minorVersion: string, annotationId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet(docId, majorVersion, minorVersion, annotationId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Read Replies of Parent Annotation
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet(docId: string, majorVersion: string, minorVersion: string, annotationId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet(docId, majorVersion, minorVersion, annotationId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Export Document Version Annotations to PDF
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet(docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Import Document Version Annotations from PDF
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost(docId, majorVersion, minorVersion, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Read Annotations by Document Version and Type
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet(docId: string, majorVersion: string, minorVersion: string, limit?: string, offset?: string, annotationTypes?: string, paginationId?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet(docId, majorVersion, minorVersion, limit, offset, annotationTypes, paginationId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Document Version Attachment Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(docId: string, majorVersion: string, minorVersion: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(docId, majorVersion, minorVersion, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Version Attachment Versions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet(docId: string, majorVersion: string, minorVersion: string, attachmentId: string, attachmentVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet(docId, majorVersion, minorVersion, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Single Document Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete(docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Version Notes as CSV
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet(docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Document Event
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost(docId, majorVersion, minorVersion, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Video Annotations
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet(docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Document Version File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet(docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionGet(docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Document Version
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut(docId: string, majorVersion: string, minorVersion: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionPut(docId, majorVersion, minorVersion, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Relationships
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet(docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Single Document Relationship
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost(docId, majorVersion, minorVersion, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Single Document Relationship
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(docId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(docId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Relationship
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(docId: string, majorVersion: string, minorVersion: string, relationshipId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(docId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Version Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet(docId: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet(docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Document Version Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete(docId, majorVersion, minorVersion, renditionType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Document Version Rendition File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet(docId, majorVersion, minorVersion, renditionType, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Upload Document Version Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost(docId, majorVersion, minorVersion, renditionType, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Replace Document Version Rendition
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut(docId: string, majorVersion: string, minorVersion: string, renditionType: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut(docId, majorVersion, minorVersion, renditionType, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Document Version Thumbnail File
         * @throws {RequiredError}
         */
        objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet(docId: string, majorVersion: string, minorVersion: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet(docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Documents
         * @throws {RequiredError}
         */
        objectsDocumentsGet(namedFilter?: string, scope?: string, versionscope?: string, search?: string, limit?: string, sort?: string, start?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsGet(namedFilter, scope, versionscope, search, limit, sort, start, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Document Roles
         * @throws {RequiredError}
         */
        objectsDocumentsIdRolesGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsIdRolesGet(id, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Assign Users & Groups to Roles on a Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsIdRolesPost(id: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsIdRolesPost(id, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Role
         * @throws {RequiredError}
         */
        objectsDocumentsIdRolesRoleNameGet(id: string, roleName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsIdRolesRoleNameGet(id, roleName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document User Actions
         * @throws {RequiredError}
         */
        objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet(id: string, majorVersion: string, minorVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet(id, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Entry Criteria
         * @throws {RequiredError}
         */
        objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(id, majorVersion, minorVersion, nameV, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Document User Action
         * @throws {RequiredError}
         */
        objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(id: string, majorVersion: string, minorVersion: string, nameV: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(id, majorVersion, minorVersion, nameV, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve User Actions on Multiple Documents
         * @throws {RequiredError}
         */
        objectsDocumentsLifecycleActionsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsLifecycleActionsPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Bulk Document User Actions
         * @throws {RequiredError}
         */
        objectsDocumentsLifecycleActionsUserActionNamePut(userActionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsLifecycleActionsUserActionNamePut(userActionName, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Single Document
         * @throws {RequiredError}
         */
        objectsDocumentsPost(authorization?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsPost(authorization, accept, xVaultAPIMigrationMode, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Multiple Document Relationships
         * @throws {RequiredError}
         */
        objectsDocumentsRelationshipsBatchDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsRelationshipsBatchDelete(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Multiple Document Relationships
         * @throws {RequiredError}
         */
        objectsDocumentsRelationshipsBatchPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsRelationshipsBatchPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Multiple Document Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsRenditionsBatchDelete(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsRenditionsBatchDelete(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Add Multiple Document Renditions
         * @throws {RequiredError}
         */
        objectsDocumentsRenditionsBatchPost(idParam?: string, largeSizeAsset?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: boolean, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsRenditionsBatchPost(idParam, largeSizeAsset, authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Remove Users and Groups from Roles on Multiple Documents & Binders
         * @throws {RequiredError}
         */
        objectsDocumentsRolesBatchDelete(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsRolesBatchDelete(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Assign Users & Groups to Roles on Multiple Documents & Binders
         * @throws {RequiredError}
         */
        objectsDocumentsRolesBatchPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsRolesBatchPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Template Collection
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsTemplatesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Single Document Template
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsTemplatesPost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Multiple Document Templates
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesPut(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsTemplatesPut(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Basic Document Template
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesTemplateNameDelete(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsTemplatesTemplateNameDelete(templateName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Document Template File
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesTemplateNameFileGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsTemplatesTemplateNameFileGet(templateName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Document Template Attributes
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesTemplateNameGet(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsTemplatesTemplateNameGet(templateName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Single Document Template
         * @throws {RequiredError}
         */
        objectsDocumentsTemplatesTemplateNamePut(templateName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsTemplatesTemplateNamePut(templateName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Document Tokens
         * @throws {RequiredError}
         */
        objectsDocumentsTokensPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsTokensPost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Export Document Versions
         * @throws {RequiredError}
         */
        objectsDocumentsVersionsBatchActionsFileextractPost(source?: boolean, renditions?: boolean, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsVersionsBatchActionsFileextractPost(source, renditions, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Multiple Document Versions
         * @throws {RequiredError}
         */
        objectsDocumentsVersionsBatchDelete(idParam?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsVersionsBatchDelete(idParam, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Multiple Document Versions
         * @throws {RequiredError}
         */
        objectsDocumentsVersionsBatchPost(idParam?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIMigrationMode?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDocumentsVersionsBatchPost(idParam, authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Domain Information
         * @throws {RequiredError}
         */
        objectsDomainGet(includeApplication?: boolean, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDomainGet(includeApplication, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Domains
         * @throws {RequiredError}
         */
        objectsDomainsGet(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsDomainsGet(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Add EDL Matched Documents
         * @throws {RequiredError}
         */
        objectsEdlMatchedDocumentsBatchActionsAddPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsEdlMatchedDocumentsBatchActionsAddPost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Remove EDL Matched Documents
         * @throws {RequiredError}
         */
        objectsEdlMatchedDocumentsBatchActionsRemovePost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsEdlMatchedDocumentsBatchActionsRemovePost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Auto Managed Groups
         * @throws {RequiredError}
         */
        objectsGroupsAutoGet(limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsGroupsAutoGet(limit, offset, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Groups
         * @throws {RequiredError}
         */
        objectsGroupsGet(includeImplied?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsGroupsGet(includeImplied, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Group
         * @throws {RequiredError}
         */
        objectsGroupsGroupIdDelete(groupId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsGroupsGroupIdDelete(groupId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Group
         * @throws {RequiredError}
         */
        objectsGroupsGroupIdGet(groupId: string, includeImplied?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsGroupsGroupIdGet(groupId, includeImplied, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Group
         * @throws {RequiredError}
         */
        objectsGroupsGroupIdPut(groupId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsGroupsGroupIdPut(groupId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Group 
         * @throws {RequiredError}
         */
        objectsGroupsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsGroupsPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Application License Usage
         * @throws {RequiredError}
         */
        objectsLicensesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsLicensesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Multi-Record Workflows
         * @throws {RequiredError}
         */
        objectsObjectworkflowsActionsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsActionsGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Multi-Record Workflow Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsActionsWorkflowNameGet(workflowName: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsActionsWorkflowNameGet(workflowName, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Multi-Record Workflow
         * @throws {RequiredError}
         */
        objectsObjectworkflowsActionsWorkflowNamePost(workflowName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsActionsWorkflowNamePost(workflowName, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Workflows
         * @throws {RequiredError}
         */
        objectsObjectworkflowsGet(objectV?: string, recordIdV?: string, participant?: string, statusV?: string, offset?: string, pageSize?: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsGet(objectV, recordIdV, participant, statusV, offset, pageSize, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Workflow Tasks
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksGet(objectV?: string, recordIdV?: string, assigneeV?: string, statusV?: string, offset?: string, pageSize?: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksGet(objectV, recordIdV, assigneeV, statusV, offset, pageSize, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Accept Single Record Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsAcceptPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsAcceptPost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Cancel Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsCancelPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsCancelPost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Complete Single Record Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsCompletePost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsCompletePost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Workflow Task Actions
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsGet(taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsGet(taskId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Accept Multi-item Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsMdwacceptPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsMdwacceptPost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Complete Multi-item Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsMdwcompletePost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsMdwcompletePost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Manage Multi-Item Workflow Content
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Reassign Multi-item Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsMdwreassignPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsMdwreassignPost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Reassign Single Record Workflow Task
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsReassignPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsReassignPost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Workflow Task Action Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsTaskActionGet(taskId: string, taskAction: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsTaskActionGet(taskId, taskAction, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Undo Workflow Task Acceptance
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsUndoacceptPost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsUndoacceptPost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Workflow Task Due Date
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost(taskId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost(taskId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Workflow Task Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsTasksTaskIdGet(taskId: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsTasksTaskIdGet(taskId, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Workflow Actions
         * @throws {RequiredError}
         */
        objectsObjectworkflowsWorkflowIdActionsGet(workflowId: string, loc?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsWorkflowIdActionsGet(workflowId, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Workflow Action Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsWorkflowIdActionsWorkflowActionGet(workflowId: string, workflowAction: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsWorkflowIdActionsWorkflowActionGet(workflowId, workflowAction, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Workflow Action
         * @throws {RequiredError}
         */
        objectsObjectworkflowsWorkflowIdActionsWorkflowActionPost(workflowId: string, workflowAction: string, documentsSys?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsWorkflowIdActionsWorkflowActionPost(workflowId, workflowAction, documentsSys, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Workflow Details
         * @throws {RequiredError}
         */
        objectsObjectworkflowsWorkflowIdGet(workflowId: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsObjectworkflowsWorkflowIdGet(workflowId, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Picklists
         * @throws {RequiredError}
         */
        objectsPicklistsGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsPicklistsGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Picklist Values
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNameGet(picklistName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsPicklistsPicklistNameGet(picklistName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Inactivate Picklist Value
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNamePicklistValueNameDelete(picklistName: string, picklistValueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsPicklistsPicklistNamePicklistValueNameDelete(picklistName, picklistValueName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Picklist Value
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNamePicklistValueNamePut(picklistName: string, picklistValueName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsPicklistsPicklistNamePicklistValueNamePut(picklistName, picklistValueName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Picklist Values
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNamePost(picklistName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsPicklistsPicklistNamePost(picklistName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Picklist Value Label
         * @throws {RequiredError}
         */
        objectsPicklistsPicklistNamePut(picklistName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsPicklistsPicklistNamePut(picklistName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Build Production Vault
         * @throws {RequiredError}
         */
        objectsSandboxActionsBuildproductionPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxActionsBuildproductionPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Promote to Production
         * @throws {RequiredError}
         */
        objectsSandboxActionsPromoteproductionPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxActionsPromoteproductionPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Recheck Sandbox Usage Limit
         * @throws {RequiredError}
         */
        objectsSandboxActionsRecheckusagePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxActionsRecheckusagePost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Change Sandbox Size
         * @throws {RequiredError}
         */
        objectsSandboxBatchChangesizePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxBatchChangesizePost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Set Sandbox Entitlements
         * @throws {RequiredError}
         */
        objectsSandboxEntitlementsSetPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxEntitlementsSetPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Sandboxes
         * @throws {RequiredError}
         */
        objectsSandboxGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Sandbox
         * @throws {RequiredError}
         */
        objectsSandboxNameDelete(name: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxNameDelete(name, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create or Refresh Sandbox
         * @throws {RequiredError}
         */
        objectsSandboxPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Sandbox Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotApiNameActionsUpdatePost(apiName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxSnapshotApiNameActionsUpdatePost(apiName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Upgrade Sandbox Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotApiNameActionsUpgradePost(apiName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxSnapshotApiNameActionsUpgradePost(apiName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Sandbox Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotApiNameDelete(apiName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxSnapshotApiNameDelete(apiName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Sandbox Snapshots
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxSnapshotGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Sandbox Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxSnapshotPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxSnapshotPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Refresh Sandbox from Snapshot
         * @throws {RequiredError}
         */
        objectsSandboxVaultIdActionsRefreshPost(vaultId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxVaultIdActionsRefreshPost(vaultId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Sandbox Details by ID
         * @throws {RequiredError}
         */
        objectsSandboxVaultIdGet(vaultId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSandboxVaultIdGet(vaultId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Security Policies
         * @throws {RequiredError}
         */
        objectsSecuritypoliciesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSecuritypoliciesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Security Policy
         * @throws {RequiredError}
         */
        objectsSecuritypoliciesSecurityPolicyNameGet(securityPolicyName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsSecuritypoliciesSecurityPolicyNameGet(securityPolicyName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Users
         * @throws {RequiredError}
         */
        objectsUsersGet(vaults?: string, excludeVaultMembership?: string, excludeAppLicensing?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersGet(vaults, excludeVaultMembership, excludeAppLicensing, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve User
         * @throws {RequiredError}
         */
        objectsUsersIdGet(id: string, excludeVaultMembership?: string, excludeAppLicensing?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersIdGet(id, excludeVaultMembership, excludeAppLicensing, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve User Permissions
         * @throws {RequiredError}
         */
        objectsUsersIdPermissionsGet(id: string, filter?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersIdPermissionsGet(id, filter, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Single User
         * @throws {RequiredError}
         */
        objectsUsersIdPut(id: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersIdPut(id, authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Validate Session User
         * @throws {RequiredError}
         */
        objectsUsersMeGet(excludeVaultMembership?: string, excludeAppLicensing?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersMeGet(excludeVaultMembership, excludeAppLicensing, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Change My Password
         * @throws {RequiredError}
         */
        objectsUsersMePasswordPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersMePasswordPost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve My User Permissions
         * @throws {RequiredError}
         */
        objectsUsersMePermissionsGet(filter?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersMePermissionsGet(filter, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update My User
         * @throws {RequiredError}
         */
        objectsUsersMePut(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersMePut(authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Single User
         * @throws {RequiredError}
         */
        objectsUsersPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Multiple Users
         * @throws {RequiredError}
         */
        objectsUsersPut(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersPut(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Disable User
         * @throws {RequiredError}
         */
        objectsUsersUserIdDelete(userId: string, domain?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersUserIdDelete(userId, domain, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Vault Membership
         * @throws {RequiredError}
         */
        objectsUsersUserIdVaultMembershipVaultIdPut(userId: string, vaultId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsUsersUserIdVaultMembershipVaultIdPut(userId, vaultId, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Vault Compare
         * @throws {RequiredError}
         */
        objectsVaultActionsComparePost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsVaultActionsComparePost(authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Vault Configuration Report
         * @throws {RequiredError}
         */
        objectsVaultActionsConfigreportPost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).objectsVaultActionsConfigreportPost(authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Component Definition Query
         * @throws {RequiredError}
         */
        queryComponentsPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).queryComponentsPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Next Page URL
         * @throws {RequiredError}
         */
        queryNextPagePost(nextPage: string, authorization?: string, accept?: string, xVaultAPIDescribeQuery?: boolean, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).queryNextPagePost(nextPage, authorization, accept, xVaultAPIDescribeQuery, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Submitting a Query
         * @throws {RequiredError}
         */
        queryPost(authorization?: string, accept?: string, xVaultAPIDescribeQuery?: boolean, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).queryPost(authorization, accept, xVaultAPIDescribeQuery, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Previous Page URL
         * @throws {RequiredError}
         */
        queryPreviousPagePost(previousPage: string, authorization?: string, accept?: string, xVaultAPIDescribeQuery?: boolean, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).queryPreviousPagePost(previousPage, authorization, accept, xVaultAPIDescribeQuery, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Current User with SCIM
         * @throws {RequiredError}
         */
        scimV2MeGet(attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2MeGet(attributes, excludedAttributes, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Current User with SCIM
         * @throws {RequiredError}
         */
        scimV2MePut(attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2MePut(attributes, excludedAttributes, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All SCIM Resource Types
         * @throws {RequiredError}
         */
        scimV2ResourceTypesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2ResourceTypesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Single SCIM Resource Type
         * @throws {RequiredError}
         */
        scimV2ResourceTypesTypeGet(type: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2ResourceTypesTypeGet(type, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All SCIM Schema Information
         * @throws {RequiredError}
         */
        scimV2SchemasGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2SchemasGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Single SCIM Schema Information
         * @throws {RequiredError}
         */
        scimV2SchemasIdGet(id: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2SchemasIdGet(id, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve SCIM Provider
         * @throws {RequiredError}
         */
        scimV2ServiceProviderConfigGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2ServiceProviderConfigGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve SCIM Resources
         * @throws {RequiredError}
         */
        scimV2TypeGet(type: string, filter?: string, attributes?: string, excludedAttributes?: string, sortBy?: string, sortOrder?: string, startIndex?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2TypeGet(type, filter, attributes, excludedAttributes, sortBy, sortOrder, startIndex, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Single SCIM Resource
         * @throws {RequiredError}
         */
        scimV2TypeIdGet(type: string, id: string, attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2TypeIdGet(type, id, attributes, excludedAttributes, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Users with SCIM
         * @throws {RequiredError}
         */
        scimV2UsersGet(filter?: string, attributes?: string, excludedAttributes?: string, sortBy?: string, sortOrder?: string, count?: string, startIndex?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2UsersGet(filter, attributes, excludedAttributes, sortBy, sortOrder, count, startIndex, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Single User with SCIM
         * @throws {RequiredError}
         */
        scimV2UsersIdGet(id: string, filter?: string, attributes?: string, excludedAttributes?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2UsersIdGet(id, filter, attributes, excludedAttributes, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update User with SCIM
         * @throws {RequiredError}
         */
        scimV2UsersIdPut(id: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2UsersIdPut(id, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create User with SCIM
         * @throws {RequiredError}
         */
        scimV2UsersPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).scimV2UsersPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Signing Certificate
         * @throws {RequiredError}
         */
        servicesCertificateCertIdGet(certId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesCertificateCertIdGet(certId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Disable Configuration Mode
         * @throws {RequiredError}
         */
        servicesConfigurationModeActionsDisablePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesConfigurationModeActionsDisablePost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Enable Configuration Mode
         * @throws {RequiredError}
         */
        servicesConfigurationModeActionsEnablePost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesConfigurationModeActionsEnablePost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Available Direct Data Files
         * @throws {RequiredError}
         */
        servicesDirectdataFilesGet(extractType?: string, startTime?: number, stopTime?: number, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesDirectdataFilesGet(extractType, startTime, stopTime, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Direct Data File
         * @throws {RequiredError}
         */
        servicesDirectdataFilesNameGet(name: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesDirectdataFilesNameGet(name, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Item Content
         * @throws {RequiredError}
         */
        servicesFileStagingItemsContentItemGet(item: string, authorization?: string, accept?: string, range?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingItemsContentItemGet(item, authorization, accept, range, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete File or Folder
         * @throws {RequiredError}
         */
        servicesFileStagingItemsItemDelete(item: string, recursive?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingItemsItemDelete(item, recursive, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List Items at a Path
         * @throws {RequiredError}
         */
        servicesFileStagingItemsItemGet(item: string, recursive?: string, limit?: string, formatResult?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingItemsItemGet(item, recursive, limit, formatResult, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Folder or File
         * @throws {RequiredError}
         */
        servicesFileStagingItemsItemPut(item: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingItemsItemPut(item, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Folder or File
         * @throws {RequiredError}
         */
        servicesFileStagingItemsPost(authorization?: string, accept?: string, contentMD5?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingItemsPost(authorization, accept, contentMD5, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List Upload Sessions
         * @throws {RequiredError}
         */
        servicesFileStagingUploadGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingUploadGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Resumable Upload Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadPost(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingUploadPost(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Abort Upload Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdDelete(uploadSessionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingUploadUploadSessionIdDelete(uploadSessionId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Get Upload Session Details
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdGet(uploadSessionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingUploadUploadSessionIdGet(uploadSessionId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary List File Parts Uploaded to Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdPartsGet(uploadSessionId: string, limit?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingUploadUploadSessionIdPartsGet(uploadSessionId, limit, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Commit Upload Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdPost(uploadSessionId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingUploadUploadSessionIdPost(uploadSessionId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Upload to a Session
         * @throws {RequiredError}
         */
        servicesFileStagingUploadUploadSessionIdPut(uploadSessionId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIFilePartNumber?: string, contentMD5?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesFileStagingUploadUploadSessionIdPut(uploadSessionId, authorization, accept, contentType, xVaultAPIFilePartNumber, contentMD5, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Job Histories
         * @throws {RequiredError}
         */
        servicesJobsHistoriesGet(startDate?: string, endDate?: string, status?: string, limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesJobsHistoriesGet(startDate, endDate, status, limit, offset, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Import Bulk Translation File Job Errors
         * @throws {RequiredError}
         */
        servicesJobsJobIdErrorsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesJobsJobIdErrorsGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Job Status
         * @throws {RequiredError}
         */
        servicesJobsJobIdGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesJobsJobIdGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Import Bulk Translation File Job Summary
         * @throws {RequiredError}
         */
        servicesJobsJobIdSummaryGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesJobsJobIdSummaryGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve SDK Job Tasks
         * @throws {RequiredError}
         */
        servicesJobsJobIdTasksGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesJobsJobIdTasksGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Job Monitors
         * @throws {RequiredError}
         */
        servicesJobsMonitorsGet(startDate?: string, endDate?: string, status?: string, limit?: string, offset?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesJobsMonitorsGet(startDate, endDate, status, limit, offset, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Start Job
         * @throws {RequiredError}
         */
        servicesJobsStartNowJobIdPost(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesJobsStartNowJobIdPost(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Extract Data Files
         * @throws {RequiredError}
         */
        servicesLoaderExtractPost(authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesLoaderExtractPost(authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Load Failure Log Results
         * @throws {RequiredError}
         */
        servicesLoaderJobIdTasksTaskIdFailurelogGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesLoaderJobIdTasksTaskIdFailurelogGet(jobId, taskId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Loader Extract Results
         * @throws {RequiredError}
         */
        servicesLoaderJobIdTasksTaskIdResultsGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesLoaderJobIdTasksTaskIdResultsGet(jobId, taskId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Loader Extract Renditions Results
         * @throws {RequiredError}
         */
        servicesLoaderJobIdTasksTaskIdResultsRenditionsGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesLoaderJobIdTasksTaskIdResultsRenditionsGet(jobId, taskId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Load Success Log Results
         * @throws {RequiredError}
         */
        servicesLoaderJobIdTasksTaskIdSuccesslogGet(jobId: string, taskId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesLoaderJobIdTasksTaskIdSuccesslogGet(jobId, taskId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Load Data Objects
         * @throws {RequiredError}
         */
        servicesLoaderLoadPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesLoaderLoadPost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Validate Package
         * @throws {RequiredError}
         */
        servicesPackageActionsValidatePost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesPackageActionsValidatePost(authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Export Package
         * @throws {RequiredError}
         */
        servicesPackagePost(authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesPackagePost(authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Import Package
         * @throws {RequiredError}
         */
        servicesPackagePut(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesPackagePut(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Queues
         * @throws {RequiredError}
         */
        servicesQueuesGet(authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesQueuesGet(authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Disable Delivery
         * @throws {RequiredError}
         */
        servicesQueuesQueueNameActionsDisableDeliveryPut(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesQueuesQueueNameActionsDisableDeliveryPut(queueName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Enable Delivery
         * @throws {RequiredError}
         */
        servicesQueuesQueueNameActionsEnableDeliveryPut(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesQueuesQueueNameActionsEnableDeliveryPut(queueName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Reset Queue
         * @throws {RequiredError}
         */
        servicesQueuesQueueNameActionsResetPut(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesQueuesQueueNameActionsResetPut(queueName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Queue Status
         * @throws {RequiredError}
         */
        servicesQueuesQueueNameGet(queueName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesQueuesQueueNameGet(queueName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Validate Imported Package
         * @throws {RequiredError}
         */
        servicesVobjectVaultPackageVPackageIdActionsValidatePost(packageId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).servicesVobjectVaultPackageVPackageIdActionsValidatePost(packageId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary End Session
         * @throws {RequiredError}
         */
        sessionDelete(accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).sessionDelete(accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Single Client Code Distribution
         * @throws {RequiredError}
         */
        uicodeDistributionsDistributionNameCodeGet(distributionName: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).uicodeDistributionsDistributionNameCodeGet(distributionName, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Single Client Code Distribution
         * @throws {RequiredError}
         */
        uicodeDistributionsDistributionNameDelete(distributionName: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).uicodeDistributionsDistributionNameDelete(distributionName, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Single Client Code Distribution Metadata
         * @throws {RequiredError}
         */
        uicodeDistributionsDistributionNameGet(distributionName: string, accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).uicodeDistributionsDistributionNameGet(distributionName, accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve All Client Code Distribution Metadata
         * @throws {RequiredError}
         */
        uicodeDistributionsGet(accept?: string, authorization?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).uicodeDistributionsGet(accept, authorization, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Add or Replace Single Client Code Distribution
         * @throws {RequiredError}
         */
        uicodeDistributionsPost(accept?: string, authorization?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).uicodeDistributionsPost(accept, authorization, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Deploy Package
         * @throws {RequiredError}
         */
        vobjectVaultPackageVPackageIdActionsDeployPost(packageId: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectVaultPackageVPackageIdActionsDeployPost(packageId, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Package Deploy Results
         * @throws {RequiredError}
         */
        vobjectVaultPackageVPackageIdActionsDeployResultsGet(packageId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectVaultPackageVPackageIdActionsDeployResultsGet(packageId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Results of Cascade Delete Job
         * @throws {RequiredError}
         */
        vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet(objectName: string, jobStatus: string, jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet(objectName, jobStatus, jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Results of Deep Copy Job
         * @throws {RequiredError}
         */
        vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet(objectName: string, jobStatus: string, jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsDeepcopyResultsObjectNameJobStatusJobIdGet(objectName, jobStatus, jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create a Placeholder from an EDL Item
         * @throws {RequiredError}
         */
        vobjectsEdlItemVActionsCreateplaceholderPost(authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsEdlItemVActionsCreateplaceholderPost(authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Merge Records Job Log
         * @throws {RequiredError}
         */
        vobjectsMergesJobIdLogGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsMergesJobIdLogGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Record Merge Results
         * @throws {RequiredError}
         */
        vobjectsMergesJobIdResultsGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsMergesJobIdResultsGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Record Merge Status
         * @throws {RequiredError}
         */
        vobjectsMergesJobIdStatusGet(jobId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsMergesJobIdStatusGet(jobId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Object Action on Multiple Records
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsActionNamePost(objectName: string, actionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameActionsActionNamePost(objectName, actionName, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Change Object Type
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsChangetypePost(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameActionsChangetypePost(objectName, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Record Merge
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsMergePost(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, vobjectsObjectNameActionsMergePostRequestInner?: Array<VobjectsObjectNameActionsMergePostRequestInner>, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameActionsMergePost(objectName, authorization, contentType, accept, xVaultAPIClientID, vobjectsObjectNameActionsMergePostRequestInner, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Roll-up Field Recalculation Status
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsRecalculaterollupsGet(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameActionsRecalculaterollupsGet(objectName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Recalculate Roll-up Fields
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsRecalculaterollupsPost(objectName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameActionsRecalculaterollupsPost(objectName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Corporate Currency Fields
         * @throws {RequiredError}
         */
        vobjectsObjectNameActionsUpdatecorporatecurrencyPut(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameActionsUpdatecorporatecurrencyPut(objectName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Multiple Object Record Attachments
         * @throws {RequiredError}
         */
        vobjectsObjectNameAttachmentsBatchDelete(objectName: string, idParam?: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameAttachmentsBatchDelete(objectName, idParam, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Multiple Object Record Attachments
         * @throws {RequiredError}
         */
        vobjectsObjectNameAttachmentsBatchPost(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameAttachmentsBatchPost(objectName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Multiple Object Record Attachment Descriptions
         * @throws {RequiredError}
         */
        vobjectsObjectNameAttachmentsBatchPut(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameAttachmentsBatchPut(objectName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNameDelete(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameDelete(objectName, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Record Roles
         * @throws {RequiredError}
         */
        vobjectsObjectNameIdRolesRoleNameGet(objectName: string, id: string, roleName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameIdRolesRoleNameGet(objectName, id, roleName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object User Actions Details
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsActionNameGet(objectName: string, objectRecordId: string, actionName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdActionsActionNameGet(objectName, objectRecordId, actionName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Initiate Object Action on a Single Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsActionNamePost(objectName: string, objectRecordId: string, actionName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdActionsActionNamePost(objectName, objectRecordId, actionName, authorization, contentType, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Cascade Delete Object Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsCascadedeletePost(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdActionsCascadedeletePost(objectName, objectRecordId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Deep Copy Object Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsDeepcopyPost(objectName: string, objectRecordId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdActionsDeepcopyPost(objectName, objectRecordId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Record User Actions
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdActionsGet(objectName: string, objectRecordId: string, loc?: boolean, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdActionsGet(objectName, objectRecordId, loc, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Attachment Field File
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet(objectName: string, objectRecordId: string, attachmentFieldName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet(objectName, objectRecordId, attachmentFieldName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Attachment Field File
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost(objectName: string, objectRecordId: string, attachmentFieldName: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost(objectName, objectRecordId, attachmentFieldName, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download All Attachment Field Files
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet(objectName, objectRecordId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Object Record Attachment
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete(objectName, objectRecordId, attachmentId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Record Attachment Metadata
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet(objectName, objectRecordId, attachmentId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Object Record Attachment Description
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut(objectName, objectRecordId, attachmentId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Delete Object Record Attachment Version
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(objectName, objectRecordId, attachmentId, attachmentVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download Object Record Attachment File
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(objectName, objectRecordId, attachmentId, attachmentVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Record Attachment Version Metadata
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(objectName, objectRecordId, attachmentId, attachmentVersion, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Restore Object Record Attachment Version
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(objectName: string, objectRecordId: string, attachmentId: string, attachmentVersion: string, restore?: boolean, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(objectName, objectRecordId, attachmentId, attachmentVersion, restore, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Record Attachment Versions
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet(objectName: string, objectRecordId: string, attachmentId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet(objectName, objectRecordId, attachmentId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Download All Object Record Attachment Files
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsFileGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsFileGet(objectName, objectRecordId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Record Attachments
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsGet(objectName, objectRecordId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create Object Record Attachment
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAttachmentsPost(objectName: string, objectRecordId: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAttachmentsPost(objectName, objectRecordId, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Complete Audit History for a Single Object Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdAudittrailGet(objectName: string, objectRecordId: string, startDate?: string, endDate?: string, formatResult?: string, limit?: string, offset?: string, events?: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdAudittrailGet(objectName, objectRecordId, startDate, endDate, formatResult, limit, offset, events, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Object Record
         * @throws {RequiredError}
         */
        vobjectsObjectNameObjectRecordIdGet(objectName: string, objectRecordId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameObjectRecordIdGet(objectName, objectRecordId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Create & Upsert Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNamePost(objectName: string, idParam?: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPINoTriggers?: boolean, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNamePost(objectName, idParam, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPINoTriggers, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Update Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNamePut(objectName: string, authorization?: string, contentType?: string, accept?: string, xVaultAPIMigrationMode?: boolean, xVaultAPINoTriggers?: boolean, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNamePut(objectName, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPINoTriggers, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Remove Users & Groups from Roles on Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNameRolesDelete(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameRolesDelete(objectName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Assign Users & Groups to Roles on Object Records
         * @throws {RequiredError}
         */
        vobjectsObjectNameRolesPost(objectName: string, authorization?: string, accept?: string, contentType?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsObjectNameRolesPost(objectName, authorization, accept, contentType, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
        /**
         * 
         * @summary Retrieve Outbound Package Dependencies
         * @throws {RequiredError}
         */
        vobjectsOutboundPackageVPackageIdDependenciesGet(packageId: string, authorization?: string, accept?: string, xVaultAPIClientID?: string, options?: RequestOptions = {}): Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).vobjectsOutboundPackageVPackageIdDependenciesGet(packageId, authorization, accept, xVaultAPIClientID, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    DefaultApi: DefaultApiType,
 }
