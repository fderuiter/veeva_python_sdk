/**
 * Veeva Vault API v25.1
 * The latest GA version of the Vault REST API.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "OpenAPIDefaultApiOperations.h"

#include "OpenAPIModule.h"
#include "OpenAPIHelpers.h"

#include "Dom/JsonObject.h"
#include "Templates/SharedPointer.h"
#include "HttpModule.h"
#include "PlatformHttp.h"

namespace OpenAPI
{

FString OpenAPIDefaultApi::ApiGetRequest::ComputePath() const
{
	FString Path(TEXT("/api/"));
	return Path;
}

void OpenAPIDefaultApi::ApiGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ApiGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ApiGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("component_type_and_record_name"), FStringFormatArg(ToUrlString(ComponentTypeAndRecordName)) } };

	FString Path = FString::Format(TEXT("/api/mdl/components/{component_type_and_record_name}/files"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ApiMdlComponentsComponentTypeAndRecordNameFilesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ApiMdlComponentsComponentTypeAndRecordNameFilesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ApiMdlComponentsComponentTypeAndRecordNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("component_type_and_record_name"), FStringFormatArg(ToUrlString(ComponentTypeAndRecordName)) } };

	FString Path = FString::Format(TEXT("/api/mdl/components/{component_type_and_record_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ApiMdlComponentsComponentTypeAndRecordNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ApiMdlComponentsComponentTypeAndRecordNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ApiMdlComponentsComponentTypeAndRecordNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ApiMdlExecuteAsyncJobIdResultsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/api/mdl/execute_async/{job_id}/results"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ApiMdlExecuteAsyncJobIdResultsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ApiMdlExecuteAsyncJobIdResultsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ApiMdlExecuteAsyncJobIdResultsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ApiMdlExecuteAsyncPostRequest::ComputePath() const
{
	FString Path(TEXT("/api/mdl/execute_async"));
	return Path;
}

void OpenAPIDefaultApi::ApiMdlExecuteAsyncPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ApiMdlExecuteAsyncPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ApiMdlExecuteAsyncPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ApiMdlExecutePostRequest::ComputePath() const
{
	FString Path(TEXT("/api/mdl/execute"));
	return Path;
}

void OpenAPIDefaultApi::ApiMdlExecutePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ApiMdlExecutePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ApiMdlExecutePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ApiMdlFilesPostRequest::ComputePath() const
{
	FString Path(TEXT("/api/mdl/files"));
	return Path;
}

void OpenAPIDefaultApi::ApiMdlFilesPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ApiMdlFilesPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ApiMdlFilesPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::AudittrailAuditTrailTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("audit_trail_type"), FStringFormatArg(ToUrlString(AuditTrailType)) } };

	FString Path = FString::Format(TEXT("/audittrail/{audit_trail_type}"), PathParams);

	TArray<FString> QueryParams;
	if(StartDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("start_date=")) + ToUrlString(StartDate.GetValue()));
	}
	if(EndDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_date=")) + ToUrlString(EndDate.GetValue()));
	}
	if(AllDates.IsSet())
	{
		QueryParams.Add(FString(TEXT("all_dates=")) + ToUrlString(AllDates.GetValue()));
	}
	if(FormatResult.IsSet())
	{
		QueryParams.Add(FString(TEXT("format_result=")) + ToUrlString(FormatResult.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	if(Objects.IsSet())
	{
		QueryParams.Add(FString(TEXT("objects=")) + ToUrlString(Objects.GetValue()));
	}
	if(Events.IsSet())
	{
		QueryParams.Add(FString(TEXT("events=")) + ToUrlString(Events.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::AudittrailAuditTrailTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::AudittrailAuditTrailTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::AudittrailAuditTrailTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::AuthDiscoveryPostRequest::ComputePath() const
{
	FString Path(TEXT("/auth/discovery"));
	return Path;
}

void OpenAPIDefaultApi::AuthDiscoveryPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::AuthDiscoveryPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::AuthDiscoveryPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::AuthOauthSessionOathOidcProfileIdPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("oath_oidc_profile_id"), FStringFormatArg(ToUrlString(OathOidcProfileId)) } };

	FString Path = FString::Format(TEXT("/auth/oauth/session/{oath_oidc_profile_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::AuthOauthSessionOathOidcProfileIdPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::AuthOauthSessionOathOidcProfileIdPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::AuthOauthSessionOathOidcProfileIdPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::AuthPostRequest::ComputePath() const
{
	FString Path(TEXT("/auth"));
	return Path;
}

void OpenAPIDefaultApi::AuthPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::AuthPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::AuthPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeClassNameDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("class_name"), FStringFormatArg(ToUrlString(ClassName)) } };

	FString Path = FString::Format(TEXT("/code/{class_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CodeClassNameDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::CodeClassNameDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeClassNameDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeClassNameDisablePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("class_name"), FStringFormatArg(ToUrlString(ClassName)) } };

	FString Path = FString::Format(TEXT("/code/{class_name}/disable"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CodeClassNameDisablePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::CodeClassNameDisablePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeClassNameDisablePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeClassNameEnablePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("class_name"), FStringFormatArg(ToUrlString(ClassName)) } };

	FString Path = FString::Format(TEXT("/code/{class_name}/enable"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CodeClassNameEnablePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::CodeClassNameEnablePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeClassNameEnablePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeClassNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("class_name"), FStringFormatArg(ToUrlString(ClassName)) } };

	FString Path = FString::Format(TEXT("/code/{class_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CodeClassNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::CodeClassNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeClassNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeProfilerGetRequest::ComputePath() const
{
	FString Path(TEXT("/code/profiler"));
	return Path;
}

void OpenAPIDefaultApi::CodeProfilerGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::CodeProfilerGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeProfilerGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeProfilerPostRequest::ComputePath() const
{
	FString Path(TEXT("/code/profiler"));
	return Path;
}

void OpenAPIDefaultApi::CodeProfilerPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::CodeProfilerPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeProfilerPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeProfilerSessionNameActionsEndPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("session_name"), FStringFormatArg(ToUrlString(SessionName)) } };

	FString Path = FString::Format(TEXT("/code/profiler/{session_name}/actions/end"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CodeProfilerSessionNameActionsEndPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::CodeProfilerSessionNameActionsEndPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeProfilerSessionNameActionsEndPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeProfilerSessionNameDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("session_name"), FStringFormatArg(ToUrlString(SessionName)) } };

	FString Path = FString::Format(TEXT("/code/profiler/{session_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CodeProfilerSessionNameDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::CodeProfilerSessionNameDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeProfilerSessionNameDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeProfilerSessionNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("session_name"), FStringFormatArg(ToUrlString(SessionName)) } };

	FString Path = FString::Format(TEXT("/code/profiler/{session_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CodeProfilerSessionNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::CodeProfilerSessionNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeProfilerSessionNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodeProfilerSessionNameResultsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("session_name"), FStringFormatArg(ToUrlString(SessionName)) } };

	FString Path = FString::Format(TEXT("/code/profiler/{session_name}/results"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CodeProfilerSessionNameResultsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::CodeProfilerSessionNameResultsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodeProfilerSessionNameResultsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CodePutRequest::ComputePath() const
{
	FString Path(TEXT("/code"));
	return Path;
}

void OpenAPIDefaultApi::CodePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::CodePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CodePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("edl_hierarchy_or_template"), FStringFormatArg(ToUrlString(EdlHierarchyOrTemplate)) } };

	FString Path = FString::Format(TEXT("/composites/trees/{edl_hierarchy_or_template}/actions/listnodes"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CompositesTreesEdlHierarchyOrTemplateGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("edl_hierarchy_or_template"), FStringFormatArg(ToUrlString(EdlHierarchyOrTemplate)) } };

	FString Path = FString::Format(TEXT("/composites/trees/{edl_hierarchy_or_template}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CompositesTreesEdlHierarchyOrTemplateGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::CompositesTreesEdlHierarchyOrTemplateGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CompositesTreesEdlHierarchyOrTemplateGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("parent_node_id"), FStringFormatArg(ToUrlString(ParentNodeId)) } };

	FString Path = FString::Format(TEXT("/composites/trees/edl_hierarchy__v/{parent_node_id}/children"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::CompositesTreesEdlHierarchyVParentNodeIdChildrenGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CompositesTreesEdlHierarchyVParentNodeIdChildrenGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::CompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("parent_node_id"), FStringFormatArg(ToUrlString(ParentNodeId)) } };

	FString Path = FString::Format(TEXT("/composites/trees/edl_hierarchy__v/{parent_node_id}/children"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::CompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::CompositesTreesEdlHierarchyVParentNodeIdChildrenPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::CompositesTreesEdlHierarchyVParentNodeIdChildrenPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ConfigurationComponentTypeAndRecordNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("component_type_and_record_name"), FStringFormatArg(ToUrlString(ComponentTypeAndRecordName)) } };

	FString Path = FString::Format(TEXT("/configuration/{component_type_and_record_name}"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ConfigurationComponentTypeAndRecordNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ConfigurationComponentTypeAndRecordNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ConfigurationComponentTypeAndRecordNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ConfigurationComponentTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("component_type"), FStringFormatArg(ToUrlString(ComponentType)) } };

	FString Path = FString::Format(TEXT("/configuration/{component_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ConfigurationComponentTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ConfigurationComponentTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ConfigurationComponentTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ConfigurationObjectNameAndObjectTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name_and_object_type"), FStringFormatArg(ToUrlString(ObjectNameAndObjectType)) } };

	FString Path = FString::Format(TEXT("/configuration/{object_name_and_object_type}"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ConfigurationObjectNameAndObjectTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ConfigurationObjectNameAndObjectTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ConfigurationObjectNameAndObjectTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ConfigurationObjecttypeGetRequest::ComputePath() const
{
	FString Path(TEXT("/configuration/Objecttype"));
	return Path;
}

void OpenAPIDefaultApi::ConfigurationObjecttypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ConfigurationObjecttypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ConfigurationObjecttypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ConfigurationRoleAssignmentRuleDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/configuration/role_assignment_rule"));
	return Path;
}

void OpenAPIDefaultApi::ConfigurationRoleAssignmentRuleDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ConfigurationRoleAssignmentRuleDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ConfigurationRoleAssignmentRuleDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ConfigurationRoleAssignmentRuleGetRequest::ComputePath() const
{
	FString Path(TEXT("/configuration/role_assignment_rule"));
	TArray<FString> QueryParams;
	if(LifecycleV.IsSet())
	{
		QueryParams.Add(FString(TEXT("lifecycle__v=")) + ToUrlString(LifecycleV.GetValue()));
	}
	if(RoleV.IsSet())
	{
		QueryParams.Add(FString(TEXT("role__v=")) + ToUrlString(RoleV.GetValue()));
	}
	if(ProductV.IsSet())
	{
		QueryParams.Add(FString(TEXT("product__v=")) + ToUrlString(ProductV.GetValue()));
	}
	if(CountryV.IsSet())
	{
		QueryParams.Add(FString(TEXT("country__v=")) + ToUrlString(CountryV.GetValue()));
	}
	if(StudyV.IsSet())
	{
		QueryParams.Add(FString(TEXT("study__v=")) + ToUrlString(StudyV.GetValue()));
	}
	if(StudyCountryV.IsSet())
	{
		QueryParams.Add(FString(TEXT("study_country__v=")) + ToUrlString(StudyCountryV.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ConfigurationRoleAssignmentRuleGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ConfigurationRoleAssignmentRuleGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ConfigurationRoleAssignmentRuleGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ConfigurationRoleAssignmentRulePostRequest::ComputePath() const
{
	FString Path(TEXT("/configuration/role_assignment_rule"));
	return Path;
}

void OpenAPIDefaultApi::ConfigurationRoleAssignmentRulePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ConfigurationRoleAssignmentRulePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ConfigurationRoleAssignmentRulePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ConfigurationRoleAssignmentRulePutRequest::ComputePath() const
{
	FString Path(TEXT("/configuration/role_assignment_rule"));
	return Path;
}

void OpenAPIDefaultApi::ConfigurationRoleAssignmentRulePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ConfigurationRoleAssignmentRulePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ConfigurationRoleAssignmentRulePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::DelegationLoginPostRequest::ComputePath() const
{
	FString Path(TEXT("/delegation/login"));
	return Path;
}

void OpenAPIDefaultApi::DelegationLoginPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::DelegationLoginPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::DelegationLoginPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::DelegationVaultsGetRequest::ComputePath() const
{
	FString Path(TEXT("/delegation/vaults"));
	return Path;
}

void OpenAPIDefaultApi::DelegationVaultsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::DelegationVaultsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::DelegationVaultsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::KeepAlivePostRequest::ComputePath() const
{
	FString Path(TEXT("/keep-alive"));
	return Path;
}

void OpenAPIDefaultApi::KeepAlivePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::KeepAlivePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::KeepAlivePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::LimitsGetRequest::ComputePath() const
{
	FString Path(TEXT("/limits"));
	return Path;
}

void OpenAPIDefaultApi::LimitsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::LimitsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::LimitsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::LogsApiUsageGetRequest::ComputePath() const
{
	FString Path(TEXT("/logs/api_usage"));
	TArray<FString> QueryParams;
	if(Date.IsSet())
	{
		QueryParams.Add(FString(TEXT("date=")) + ToUrlString(Date.GetValue()));
	}
	if(LogFormat.IsSet())
	{
		QueryParams.Add(FString(TEXT("log_format=")) + ToUrlString(LogFormat.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::LogsApiUsageGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::LogsApiUsageGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::LogsApiUsageGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::LogsCodeDebugGetRequest::ComputePath() const
{
	FString Path(TEXT("/logs/code/debug"));
	TArray<FString> QueryParams;
	if(UserId.IsSet())
	{
		QueryParams.Add(FString(TEXT("user_id=")) + ToUrlString(UserId.GetValue()));
	}
	if(IncludeInactive.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_inactive=")) + ToUrlString(IncludeInactive.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::LogsCodeDebugGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::LogsCodeDebugGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::LogsCodeDebugGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::LogsCodeDebugIdActionsResetDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/logs/code/debug/{id}/actions/reset"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::LogsCodeDebugIdActionsResetDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::LogsCodeDebugIdActionsResetDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::LogsCodeDebugIdActionsResetDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::LogsCodeDebugIdActionsResetPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/logs/code/debug/{id}/actions/reset"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::LogsCodeDebugIdActionsResetPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::LogsCodeDebugIdActionsResetPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::LogsCodeDebugIdActionsResetPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::LogsCodeDebugIdFilesGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/logs/code/debug/{id}/files"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::LogsCodeDebugIdFilesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::LogsCodeDebugIdFilesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::LogsCodeDebugIdFilesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::LogsCodeDebugIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/logs/code/debug/{id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::LogsCodeDebugIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::LogsCodeDebugIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::LogsCodeDebugIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::LogsCodeDebugPostRequest::ComputePath() const
{
	FString Path(TEXT("/logs/code/debug"));
	return Path;
}

void OpenAPIDefaultApi::LogsCodeDebugPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::LogsCodeDebugPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::LogsCodeDebugPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::LogsCodeRuntimeGetRequest::ComputePath() const
{
	FString Path(TEXT("/logs/code/runtime"));
	TArray<FString> QueryParams;
	if(Date.IsSet())
	{
		QueryParams.Add(FString(TEXT("date=")) + ToUrlString(Date.GetValue()));
	}
	if(LogFormat.IsSet())
	{
		QueryParams.Add(FString(TEXT("log_format=")) + ToUrlString(LogFormat.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::LogsCodeRuntimeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::LogsCodeRuntimeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::LogsCodeRuntimeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MessagesMessageTypeActionsImportPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("message_type"), FStringFormatArg(ToUrlString(MessageType)) } };

	FString Path = FString::Format(TEXT("/messages/{message_type}/actions/import"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MessagesMessageTypeActionsImportPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::MessagesMessageTypeActionsImportPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MessagesMessageTypeActionsImportPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MessagesMessageTypeLanguageLangActionsExportPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("message_type"), FStringFormatArg(ToUrlString(MessageType)) },
	{ TEXT("lang"), FStringFormatArg(ToUrlString(Lang)) } };

	FString Path = FString::Format(TEXT("/messages/{message_type}/language/{lang}/actions/export"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MessagesMessageTypeLanguageLangActionsExportPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::MessagesMessageTypeLanguageLangActionsExportPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MessagesMessageTypeLanguageLangActionsExportPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataAudittrailAuditTrailTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("audit_trail_type"), FStringFormatArg(ToUrlString(AuditTrailType)) } };

	FString Path = FString::Format(TEXT("/metadata/audittrail/{audit_trail_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataAudittrailAuditTrailTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataAudittrailAuditTrailTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataAudittrailAuditTrailTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataAudittrailGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/audittrail"));
	return Path;
}

void OpenAPIDefaultApi::MetadataAudittrailGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataAudittrailGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataAudittrailGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataComponentsComponentTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("component_type"), FStringFormatArg(ToUrlString(ComponentType)) } };

	FString Path = FString::Format(TEXT("/metadata/components/{component_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataComponentsComponentTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataComponentsComponentTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataComponentsComponentTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataComponentsGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/components"));
	return Path;
}

void OpenAPIDefaultApi::MetadataComponentsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataComponentsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataComponentsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsBindersTemplatesBindernodesGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/binders/templates/bindernodes"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsBindersTemplatesBindernodesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsBindersTemplatesBindernodesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsBindersTemplatesBindernodesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsBindersTemplatesGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/binders/templates"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsBindersTemplatesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsBindersTemplatesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsBindersTemplatesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("placemark_type"), FStringFormatArg(ToUrlString(PlacemarkType)) } };

	FString Path = FString::Format(TEXT("/metadata/objects/documents/annotations/placemarks/types/{placemark_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("reference_type"), FStringFormatArg(ToUrlString(ReferenceType)) } };

	FString Path = FString::Format(TEXT("/metadata/objects/documents/annotations/references/types/{reference_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("annotation_type"), FStringFormatArg(ToUrlString(AnnotationType)) } };

	FString Path = FString::Format(TEXT("/metadata/objects/documents/annotations/types/{annotation_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("event_type"), FStringFormatArg(ToUrlString(EventType)) },
	{ TEXT("event_subtype"), FStringFormatArg(ToUrlString(EventSubtype)) } };

	FString Path = FString::Format(TEXT("/metadata/objects/documents/events/{event_type}/types/{event_subtype}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsEventsGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/documents/events"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsEventsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsEventsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsEventsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsLockGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/documents/lock"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsLockGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsLockGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsLockGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsPropertiesFindCommonPostRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/documents/properties/find_common"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsPropertiesFindCommonPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsPropertiesFindCommonPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsPropertiesFindCommonPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsPropertiesGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/documents/properties"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsPropertiesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsPropertiesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsPropertiesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsTemplatesGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/documents/templates"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTemplatesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTemplatesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsTemplatesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsTypesGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/documents/types"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsTypesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("type"), FStringFormatArg(ToUrlString(Type)) } };

	FString Path = FString::Format(TEXT("/metadata/objects/documents/types/{type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeRelationshipsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("type"), FStringFormatArg(ToUrlString(Type)) } };

	FString Path = FString::Format(TEXT("/metadata/objects/documents/types/{type}/relationships"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeRelationshipsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeRelationshipsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeRelationshipsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("type"), FStringFormatArg(ToUrlString(Type)) },
	{ TEXT("subtype"), FStringFormatArg(ToUrlString(Subtype)) },
	{ TEXT("classification"), FStringFormatArg(ToUrlString(Classification)) } };

	FString Path = FString::Format(TEXT("/metadata/objects/documents/types/{type}/subtypes/{subtype}/classifications/{classification}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("type"), FStringFormatArg(ToUrlString(Type)) },
	{ TEXT("subtype"), FStringFormatArg(ToUrlString(Subtype)) } };

	FString Path = FString::Format(TEXT("/metadata/objects/documents/types/{type}/subtypes/{subtype}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsGroupsGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/groups"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsGroupsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsGroupsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsGroupsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsSecuritypoliciesGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/securitypolicies"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsSecuritypoliciesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsSecuritypoliciesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsSecuritypoliciesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataObjectsUsersGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/objects/users"));
	return Path;
}

void OpenAPIDefaultApi::MetadataObjectsUsersGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataObjectsUsersGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataObjectsUsersGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/query/archived_documents/relationships/document_signature__sysr"));
	return Path;
}

void OpenAPIDefaultApi::MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/query/documents/relationships/document_signature__sysr"));
	return Path;
}

void OpenAPIDefaultApi::MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataVobjectsGetRequest::ComputePath() const
{
	FString Path(TEXT("/metadata/vobjects"));
	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::MetadataVobjectsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataVobjectsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataVobjectsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataVobjectsObjectNameActionsCanceldeploymentPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/metadata/vobjects/{object_name}/actions/canceldeployment"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataVobjectsObjectNameActionsCanceldeploymentPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::MetadataVobjectsObjectNameActionsCanceldeploymentPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataVobjectsObjectNameActionsCanceldeploymentPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_field_name"), FStringFormatArg(ToUrlString(ObjectFieldName)) } };

	FString Path = FString::Format(TEXT("/metadata/vobjects/{object_name}/fields/{object_field_name}"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::MetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataVobjectsObjectNameFieldsObjectFieldNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataVobjectsObjectNameFieldsObjectFieldNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataVobjectsObjectNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/metadata/vobjects/{object_name}"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::MetadataVobjectsObjectNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataVobjectsObjectNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataVobjectsObjectNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataVobjectsObjectNamePageLayoutsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/metadata/vobjects/{object_name}/page_layouts"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataVobjectsObjectNamePageLayoutsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataVobjectsObjectNamePageLayoutsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataVobjectsObjectNamePageLayoutsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::MetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("layout_name"), FStringFormatArg(ToUrlString(LayoutName)) } };

	FString Path = FString::Format(TEXT("/metadata/vobjects/{object_name}/page_layouts/{layout_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::MetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::MetadataVobjectsObjectNamePageLayoutsLayoutNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::MetadataVobjectsObjectNamePageLayoutsLayoutNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::NotificationsHistoriesGetRequest::ComputePath() const
{
	FString Path(TEXT("/notifications/histories"));
	TArray<FString> QueryParams;
	if(StartDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("start_date=")) + ToUrlString(StartDate.GetValue()));
	}
	if(EndDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_date=")) + ToUrlString(EndDate.GetValue()));
	}
	if(AllDates.IsSet())
	{
		QueryParams.Add(FString(TEXT("all_dates=")) + ToUrlString(AllDates.GetValue()));
	}
	if(FormatResult.IsSet())
	{
		QueryParams.Add(FString(TEXT("format_result=")) + ToUrlString(FormatResult.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::NotificationsHistoriesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::NotificationsHistoriesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::NotificationsHistoriesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectWorkflowActionsActionGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("action"), FStringFormatArg(ToUrlString(Action)) } };

	FString Path = FString::Format(TEXT("/object/workflow/actions/{action}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectWorkflowActionsActionGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectWorkflowActionsActionGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectWorkflowActionsActionGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectWorkflowActionsActionPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("action"), FStringFormatArg(ToUrlString(Action)) } };

	FString Path = FString::Format(TEXT("/object/workflow/actions/{action}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectWorkflowActionsActionPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectWorkflowActionsActionPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectWorkflowActionsActionPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectWorkflowActionsCanceltasksPostRequest::ComputePath() const
{
	FString Path(TEXT("/object/workflow/actions/canceltasks"));
	return Path;
}

void OpenAPIDefaultApi::ObjectWorkflowActionsCanceltasksPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectWorkflowActionsCanceltasksPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectWorkflowActionsCanceltasksPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectWorkflowActionsCancelworkflowsPostRequest::ComputePath() const
{
	FString Path(TEXT("/object/workflow/actions/cancelworkflows"));
	return Path;
}

void OpenAPIDefaultApi::ObjectWorkflowActionsCancelworkflowsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectWorkflowActionsCancelworkflowsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectWorkflowActionsCancelworkflowsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectWorkflowActionsGetRequest::ComputePath() const
{
	FString Path(TEXT("/object/workflow/actions"));
	return Path;
}

void OpenAPIDefaultApi::ObjectWorkflowActionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectWorkflowActionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectWorkflowActionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectWorkflowActionsReassigntasksPostRequest::ComputePath() const
{
	FString Path(TEXT("/object/workflow/actions/reassigntasks"));
	return Path;
}

void OpenAPIDefaultApi::ObjectWorkflowActionsReassigntasksPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectWorkflowActionsReassigntasksPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectWorkflowActionsReassigntasksPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectWorkflowActionsReplaceworkflowownerPostRequest::ComputePath() const
{
	FString Path(TEXT("/object/workflow/actions/replaceworkflowowner"));
	return Path;
}

void OpenAPIDefaultApi::ObjectWorkflowActionsReplaceworkflowownerPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectWorkflowActionsReplaceworkflowownerPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectWorkflowActionsReplaceworkflowownerPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersActionsExportJobIdResultsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/actions/export/{job_id}/results"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersActionsExportJobIdResultsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersActionsExportJobIdResultsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersActionsExportJobIdResultsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdActionsExportPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/actions/export"), PathParams);

	TArray<FString> QueryParams;
	if(Source.IsSet())
	{
		QueryParams.Add(FString(TEXT("source=")) + ToUrlString(Source.GetValue()));
	}
	if(Renditiontype.IsSet())
	{
		QueryParams.Add(FString(TEXT("renditiontype=")) + ToUrlString(Renditiontype.GetValue()));
	}
	if(Docversion.IsSet())
	{
		QueryParams.Add(FString(TEXT("docversion=")) + ToUrlString(Docversion.GetValue()));
	}
	if(Attachments.IsSet())
	{
		QueryParams.Add(FString(TEXT("attachments=")) + ToUrlString(Attachments.GetValue()));
	}
	if(_Export.IsSet())
	{
		QueryParams.Add(FString(TEXT("export=")) + ToUrlString(_Export.GetValue()));
	}
	if(Docfield.IsSet())
	{
		QueryParams.Add(FString(TEXT("docfield=")) + ToUrlString(Docfield.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdActionsExportPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdActionsExportPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdActionsExportPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdActionsPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/actions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdActionsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdActionsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdActionsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdBindingRulePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/binding_rule"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdBindingRulePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdBindingRulePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdBindingRulePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("node_id"), FStringFormatArg(ToUrlString(NodeId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/documents/{node_id}/binding_rule"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/documents"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsSectionIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("section_id"), FStringFormatArg(ToUrlString(SectionId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/documents/{section_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsSectionIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsSectionIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsSectionIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsSectionIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("section_id"), FStringFormatArg(ToUrlString(SectionId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/documents/{section_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsSectionIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsSectionIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdDocumentsSectionIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}"), PathParams);

	TArray<FString> QueryParams;
	if(Depth.IsSet())
	{
		QueryParams.Add(FString(TEXT("depth=")) + ToUrlString(Depth.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("role_name_and_user_or_group"), FStringFormatArg(ToUrlString(RoleNameAndUserOrGroup)) },
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/roles/{role_name_and_user_or_group}/{id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("node_id"), FStringFormatArg(ToUrlString(NodeId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/sections/{node_id}/binding_rule"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsNodeIdBindingRulePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsNodeIdBindingRulePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsNodeIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("node_id"), FStringFormatArg(ToUrlString(NodeId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/sections/{node_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsNodeIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsNodeIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsNodeIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/sections"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsSectionIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("section_id"), FStringFormatArg(ToUrlString(SectionId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/sections/{section_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsSectionIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsSectionIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsSectionIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsSectionIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("section_id"), FStringFormatArg(ToUrlString(SectionId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/sections/{section_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsSectionIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsSectionIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdSectionsSectionIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/versions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export"), PathParams);

	TArray<FString> QueryParams;
	if(Source.IsSet())
	{
		QueryParams.Add(FString(TEXT("source=")) + ToUrlString(Source.GetValue()));
	}
	if(Renditiontype.IsSet())
	{
		QueryParams.Add(FString(TEXT("renditiontype=")) + ToUrlString(Renditiontype.GetValue()));
	}
	if(Docversion.IsSet())
	{
		QueryParams.Add(FString(TEXT("docversion=")) + ToUrlString(Docversion.GetValue()));
	}
	if(Attachments.IsSet())
	{
		QueryParams.Add(FString(TEXT("attachments=")) + ToUrlString(Attachments.GetValue()));
	}
	if(_Export.IsSet())
	{
		QueryParams.Add(FString(TEXT("export=")) + ToUrlString(_Export.GetValue()));
	}
	if(Docfield.IsSet())
	{
		QueryParams.Add(FString(TEXT("docfield=")) + ToUrlString(Docfield.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("relationship_id"), FStringFormatArg(ToUrlString(RelationshipId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("relationship_id"), FStringFormatArg(ToUrlString(RelationshipId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("binder_id"), FStringFormatArg(ToUrlString(BinderId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("section_id"), FStringFormatArg(ToUrlString(SectionId)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/sections/{section_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersIdRolesGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{id}/roles"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersIdRolesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersIdRolesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersIdRolesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersIdRolesPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{id}/roles"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersIdRolesPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersIdRolesPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersIdRolesPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersIdRolesRoleNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) },
	{ TEXT("role_name"), FStringFormatArg(ToUrlString(RoleName)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{id}/roles/{role_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersIdRolesRoleNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersIdRolesRoleNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersIdRolesRoleNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("name__v"), FStringFormatArg(ToUrlString(NameV)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("name__v"), FStringFormatArg(ToUrlString(NameV)) } };

	FString Path = FString::Format(TEXT("/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersLifecycleActionsPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/binders/lifecycle_actions"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersLifecycleActionsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersLifecycleActionsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersLifecycleActionsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersLifecycleActionsUserActionNamePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_action_name"), FStringFormatArg(ToUrlString(UserActionName)) } };

	FString Path = FString::Format(TEXT("/objects/binders/lifecycle_actions/{user_action_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersLifecycleActionsUserActionNamePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersLifecycleActionsUserActionNamePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersLifecycleActionsUserActionNamePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/binders"));
	TArray<FString> QueryParams;
	if(Async.IsSet())
	{
		QueryParams.Add(FString(TEXT("async=")) + ToUrlString(Async.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersTemplatesGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/binders/templates"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersTemplatesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersTemplatesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersTemplatesPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/binders/templates"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersTemplatesPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersTemplatesPutRequest::ComputePath() const
{
	FString Path(TEXT("/objects/binders/templates"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersTemplatesPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("template_name"), FStringFormatArg(ToUrlString(TemplateName)) } };

	FString Path = FString::Format(TEXT("/objects/binders/templates/{template_name}/bindernodes"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("template_name"), FStringFormatArg(ToUrlString(TemplateName)) } };

	FString Path = FString::Format(TEXT("/objects/binders/templates/{template_name}/bindernodes"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("template_name"), FStringFormatArg(ToUrlString(TemplateName)) } };

	FString Path = FString::Format(TEXT("/objects/binders/templates/{template_name}/bindernodes"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameBindernodesPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("template_name"), FStringFormatArg(ToUrlString(TemplateName)) } };

	FString Path = FString::Format(TEXT("/objects/binders/templates/{template_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("template_name"), FStringFormatArg(ToUrlString(TemplateName)) } };

	FString Path = FString::Format(TEXT("/objects/binders/templates/{template_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsBindersTemplatesTemplateNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDeletionsDocumentsGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/deletions/documents"));
	TArray<FString> QueryParams;
	if(StartDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("start_date=")) + ToUrlString(StartDate.GetValue()));
	}
	if(EndDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_date=")) + ToUrlString(EndDate.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDeletionsDocumentsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDeletionsDocumentsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDeletionsDocumentsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDeletionsVobjectsObjectNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/objects/deletions/vobjects/{object_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDeletionsVobjectsObjectNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDeletionsVobjectsObjectNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDeletionsVobjectsObjectNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsActionsGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/actions"));
	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsActionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsActionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsActionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("lifecycle_and_state_and_action"), FStringFormatArg(ToUrlString(LifecycleAndStateAndAction)) },
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/actions/{lifecycle_and_state_and_action}/{job_id}/results"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsActionsWorkflowNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("workflow_name"), FStringFormatArg(ToUrlString(WorkflowName)) } };

	FString Path = FString::Format(TEXT("/objects/documents/actions/{workflow_name}"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsActionsWorkflowNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsActionsWorkflowNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsActionsWorkflowNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsActionsWorkflowNamePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("workflow_name"), FStringFormatArg(ToUrlString(WorkflowName)) } };

	FString Path = FString::Format(TEXT("/objects/documents/actions/{workflow_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsActionsWorkflowNamePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsActionsWorkflowNamePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsActionsWorkflowNamePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/annotations/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/annotations/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	HttpRequest->SetHeader(TEXT("Authorization"), Authorization);
	HttpRequest->SetHeader(TEXT("Content-Type"), ContentType);
	HttpRequest->SetHeader(TEXT("Accept"), Accept);
	HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID);

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchPutRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/annotations/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsAnnotationsBatchPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsAnnotationsRepliesBatchPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/annotations/replies/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsAnnotationsRepliesBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsAnnotationsRepliesBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsAnnotationsRepliesBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/attachments/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/attachments/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchPutRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/attachments/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsAttachmentsBatchPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/batch/actions/fileextract/{job_id}/results"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsBatchActionsFileextractJobIdResultsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsBatchActionsFileextractJobIdResultsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsBatchActionsFileextractPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/batch/actions/fileextract"));
	TArray<FString> QueryParams;
	if(Source.IsSet())
	{
		QueryParams.Add(FString(TEXT("source=")) + ToUrlString(Source.GetValue()));
	}
	if(Renditions.IsSet())
	{
		QueryParams.Add(FString(TEXT("renditions=")) + ToUrlString(Renditions.GetValue()));
	}
	if(Allversions.IsSet())
	{
		QueryParams.Add(FString(TEXT("allversions=")) + ToUrlString(Allversions.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchActionsFileextractPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchActionsFileextractPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsBatchActionsFileextractPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsBatchActionsReclassifyPutRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/batch/actions/reclassify"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchActionsReclassifyPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchActionsReclassifyPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsBatchActionsReclassifyPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsBatchActionsRerenderPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/batch/actions/rerender"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchActionsRerenderPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchActionsRerenderPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsBatchActionsRerenderPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsBatchDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/batch"));
	TArray<FString> QueryParams;
	if(IdParam.IsSet())
	{
		QueryParams.Add(FString(TEXT("idParam=")) + ToUrlString(IdParam.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsBatchDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsBatchDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsBatchLockDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/batch/lock"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchLockDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsBatchLockDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsBatchLockDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsBatchPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsBatchPutRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsBatchPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsBatchPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAnchorsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/anchors"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAnchorsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAnchorsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAnchorsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAnnotationsFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/annotations/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAnnotationsFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAnnotationsFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAnnotationsFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAnnotationsFilePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/annotations/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAnnotationsFilePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAnnotationsFilePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAnnotationsFilePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/{attachment_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/{attachment_id}/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/{attachment_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/{attachment_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"), PathParams);

	TArray<FString> QueryParams;
	if(Restore.IsSet())
	{
		QueryParams.Add(FString(TEXT("restore=")) + ToUrlString(Restore.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/{attachment_id}/versions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/attachments"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAttachmentsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdAudittrailGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/audittrail"), PathParams);

	TArray<FString> QueryParams;
	if(StartDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("start_date=")) + ToUrlString(StartDate.GetValue()));
	}
	if(EndDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_date=")) + ToUrlString(EndDate.GetValue()));
	}
	if(FormatResult.IsSet())
	{
		QueryParams.Add(FString(TEXT("format_result=")) + ToUrlString(FormatResult.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	if(Events.IsSet())
	{
		QueryParams.Add(FString(TEXT("events=")) + ToUrlString(Events.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAudittrailGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdAudittrailGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdAudittrailGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdEventsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/events"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdEventsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdEventsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdEventsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/file"), PathParams);

	TArray<FString> QueryParams;
	if(LockDocument.IsSet())
	{
		QueryParams.Add(FString(TEXT("lockDocument=")) + ToUrlString(LockDocument.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdLockDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/lock"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdLockDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdLockDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdLockDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdLockGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/lock"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdLockGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdLockGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdLockGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdLockPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/lock"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdLockPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdLockPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdLockPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/{major_version}/{minor_version}/attachments/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}"), PathParams);

	TArray<FString> QueryParams;
	if(SuppressRendition.IsSet())
	{
		QueryParams.Add(FString(TEXT("suppressRendition=")) + ToUrlString(SuppressRendition.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/renditions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("rendition_type"), FStringFormatArg(ToUrlString(RenditionType)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/renditions/{rendition_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("rendition_type"), FStringFormatArg(ToUrlString(RenditionType)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/renditions/{rendition_type}"), PathParams);

	TArray<FString> QueryParams;
	if(SteadyState.IsSet())
	{
		QueryParams.Add(FString(TEXT("steadyState=")) + ToUrlString(SteadyState.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("rendition_type"), FStringFormatArg(ToUrlString(RenditionType)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/renditions/{rendition_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("rendition_type"), FStringFormatArg(ToUrlString(RenditionType)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/renditions/{rendition_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdRenditionsRenditionTypePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("role_name_and_user_or_group"), FStringFormatArg(ToUrlString(RoleNameAndUserOrGroup)) },
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/roles/{role_name_and_user_or_group}/{id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/version/{major_version}/{minor_version}/attachments"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("annotation_id"), FStringFormatArg(ToUrlString(AnnotationId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("annotation_id"), FStringFormatArg(ToUrlString(AnnotationId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}/replies"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations"), PathParams);

	TArray<FString> QueryParams;
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	if(AnnotationTypes.IsSet())
	{
		QueryParams.Add(FString(TEXT("annotation_types=")) + ToUrlString(AnnotationTypes.GetValue()));
	}
	if(PaginationId.IsSet())
	{
		QueryParams.Add(FString(TEXT("pagination_id=")) + ToUrlString(PaginationId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/doc-export-annotations-to-csv"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/events"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/export-video-annotations"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("relationship_id"), FStringFormatArg(ToUrlString(RelationshipId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("relationship_id"), FStringFormatArg(ToUrlString(RelationshipId)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("rendition_type"), FStringFormatArg(ToUrlString(RenditionType)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("rendition_type"), FStringFormatArg(ToUrlString(RenditionType)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("rendition_type"), FStringFormatArg(ToUrlString(RenditionType)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("rendition_type"), FStringFormatArg(ToUrlString(RenditionType)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("doc_id"), FStringFormatArg(ToUrlString(DocId)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/thumbnail"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents"));
	TArray<FString> QueryParams;
	if(NamedFilter.IsSet())
	{
		QueryParams.Add(FString(TEXT("named_filter=")) + ToUrlString(NamedFilter.GetValue()));
	}
	if(Scope.IsSet())
	{
		QueryParams.Add(FString(TEXT("scope=")) + ToUrlString(Scope.GetValue()));
	}
	if(Versionscope.IsSet())
	{
		QueryParams.Add(FString(TEXT("versionscope=")) + ToUrlString(Versionscope.GetValue()));
	}
	if(Search.IsSet())
	{
		QueryParams.Add(FString(TEXT("search=")) + ToUrlString(Search.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Sort.IsSet())
	{
		QueryParams.Add(FString(TEXT("sort=")) + ToUrlString(Sort.GetValue()));
	}
	if(Start.IsSet())
	{
		QueryParams.Add(FString(TEXT("start=")) + ToUrlString(Start.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsIdRolesGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{id}/roles"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsIdRolesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsIdRolesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsIdRolesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsIdRolesPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{id}/roles"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsIdRolesPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsIdRolesPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsIdRolesPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsIdRolesRoleNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) },
	{ TEXT("role_name"), FStringFormatArg(ToUrlString(RoleName)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{id}/roles/{role_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsIdRolesRoleNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsIdRolesRoleNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsIdRolesRoleNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("name__v"), FStringFormatArg(ToUrlString(NameV)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) },
	{ TEXT("major_version"), FStringFormatArg(ToUrlString(MajorVersion)) },
	{ TEXT("minor_version"), FStringFormatArg(ToUrlString(MinorVersion)) },
	{ TEXT("name__v"), FStringFormatArg(ToUrlString(NameV)) } };

	FString Path = FString::Format(TEXT("/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsLifecycleActionsPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/lifecycle_actions"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsLifecycleActionsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsLifecycleActionsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsLifecycleActionsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsLifecycleActionsUserActionNamePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_action_name"), FStringFormatArg(ToUrlString(UserActionName)) } };

	FString Path = FString::Format(TEXT("/objects/documents/lifecycle_actions/{user_action_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsLifecycleActionsUserActionNamePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsLifecycleActionsUserActionNamePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsLifecycleActionsUserActionNamePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsRelationshipsBatchDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/relationships/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsRelationshipsBatchDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsRelationshipsBatchDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsRelationshipsBatchDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsRelationshipsBatchPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/relationships/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsRelationshipsBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsRelationshipsBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsRelationshipsBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsRenditionsBatchDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/renditions/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsRenditionsBatchDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsRenditionsBatchDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsRenditionsBatchDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsRenditionsBatchPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/renditions/batch"));
	TArray<FString> QueryParams;
	if(IdParam.IsSet())
	{
		QueryParams.Add(FString(TEXT("idParam=")) + ToUrlString(IdParam.GetValue()));
	}
	if(LargeSizeAsset.IsSet())
	{
		QueryParams.Add(FString(TEXT("largeSizeAsset=")) + ToUrlString(LargeSizeAsset.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsRenditionsBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsRenditionsBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsRenditionsBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsRolesBatchDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/roles/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsRolesBatchDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsRolesBatchDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsRolesBatchDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsRolesBatchPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/roles/batch"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsRolesBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsRolesBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsRolesBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsTemplatesGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/templates"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsTemplatesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsTemplatesPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/templates"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsTemplatesPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsTemplatesPutRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/templates"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsTemplatesPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("template_name"), FStringFormatArg(ToUrlString(TemplateName)) } };

	FString Path = FString::Format(TEXT("/objects/documents/templates/{template_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("template_name"), FStringFormatArg(ToUrlString(TemplateName)) } };

	FString Path = FString::Format(TEXT("/objects/documents/templates/{template_name}/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("template_name"), FStringFormatArg(ToUrlString(TemplateName)) } };

	FString Path = FString::Format(TEXT("/objects/documents/templates/{template_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNamePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("template_name"), FStringFormatArg(ToUrlString(TemplateName)) } };

	FString Path = FString::Format(TEXT("/objects/documents/templates/{template_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNamePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNamePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsTemplatesTemplateNamePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsTokensPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/tokens"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsTokensPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsTokensPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsTokensPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchActionsFileextractPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/versions/batch/actions/fileextract"));
	TArray<FString> QueryParams;
	if(Source.IsSet())
	{
		QueryParams.Add(FString(TEXT("source=")) + ToUrlString(Source.GetValue()));
	}
	if(Renditions.IsSet())
	{
		QueryParams.Add(FString(TEXT("renditions=")) + ToUrlString(Renditions.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchActionsFileextractPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchActionsFileextractPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchActionsFileextractPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/versions/batch"));
	TArray<FString> QueryParams;
	if(IdParam.IsSet())
	{
		QueryParams.Add(FString(TEXT("idParam=")) + ToUrlString(IdParam.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/documents/versions/batch"));
	TArray<FString> QueryParams;
	if(IdParam.IsSet())
	{
		QueryParams.Add(FString(TEXT("idParam=")) + ToUrlString(IdParam.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDocumentsVersionsBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDomainGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/domain"));
	TArray<FString> QueryParams;
	if(IncludeApplication.IsSet())
	{
		QueryParams.Add(FString(TEXT("include_application=")) + ToUrlString(IncludeApplication.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsDomainGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDomainGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDomainGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsDomainsGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/domains"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsDomainsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsDomainsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsDomainsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsEdlMatchedDocumentsBatchActionsAddPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/edl_matched_documents/batch/actions/add"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsEdlMatchedDocumentsBatchActionsAddPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsEdlMatchedDocumentsBatchActionsAddPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsEdlMatchedDocumentsBatchActionsAddPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/edl_matched_documents/batch/actions/remove"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsEdlMatchedDocumentsBatchActionsRemovePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsEdlMatchedDocumentsBatchActionsRemovePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsGroupsAutoGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/groups/auto"));
	TArray<FString> QueryParams;
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsGroupsAutoGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsGroupsAutoGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsGroupsAutoGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsGroupsGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/groups"));
	TArray<FString> QueryParams;
	if(IncludeImplied.IsSet())
	{
		QueryParams.Add(FString(TEXT("includeImplied=")) + ToUrlString(IncludeImplied.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsGroupsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsGroupsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsGroupsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsGroupsGroupIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("group_id"), FStringFormatArg(ToUrlString(GroupId)) } };

	FString Path = FString::Format(TEXT("/objects/groups/{group_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsGroupsGroupIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsGroupsGroupIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsGroupsGroupIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsGroupsGroupIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("group_id"), FStringFormatArg(ToUrlString(GroupId)) } };

	FString Path = FString::Format(TEXT("/objects/groups/{group_id}"), PathParams);

	TArray<FString> QueryParams;
	if(IncludeImplied.IsSet())
	{
		QueryParams.Add(FString(TEXT("includeImplied=")) + ToUrlString(IncludeImplied.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsGroupsGroupIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsGroupsGroupIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsGroupsGroupIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsGroupsGroupIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("group_id"), FStringFormatArg(ToUrlString(GroupId)) } };

	FString Path = FString::Format(TEXT("/objects/groups/{group_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsGroupsGroupIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsGroupsGroupIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsGroupsGroupIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsGroupsPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/groups"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsGroupsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsGroupsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsGroupsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsLicensesGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/licenses"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsLicensesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsLicensesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsLicensesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsActionsGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/objectworkflows/actions"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsActionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsActionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsActionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsActionsWorkflowNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("workflow_name"), FStringFormatArg(ToUrlString(WorkflowName)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/actions/{workflow_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsActionsWorkflowNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsActionsWorkflowNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsActionsWorkflowNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsActionsWorkflowNamePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("workflow_name"), FStringFormatArg(ToUrlString(WorkflowName)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/actions/{workflow_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsActionsWorkflowNamePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsActionsWorkflowNamePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsActionsWorkflowNamePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/objectworkflows"));
	TArray<FString> QueryParams;
	if(ObjectV.IsSet())
	{
		QueryParams.Add(FString(TEXT("object__v=")) + ToUrlString(ObjectV.GetValue()));
	}
	if(RecordIdV.IsSet())
	{
		QueryParams.Add(FString(TEXT("record_id__v=")) + ToUrlString(RecordIdV.GetValue()));
	}
	if(Participant.IsSet())
	{
		QueryParams.Add(FString(TEXT("participant=")) + ToUrlString(Participant.GetValue()));
	}
	if(StatusV.IsSet())
	{
		QueryParams.Add(FString(TEXT("status__v=")) + ToUrlString(StatusV.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/objectworkflows/tasks"));
	TArray<FString> QueryParams;
	if(ObjectV.IsSet())
	{
		QueryParams.Add(FString(TEXT("object__v=")) + ToUrlString(ObjectV.GetValue()));
	}
	if(RecordIdV.IsSet())
	{
		QueryParams.Add(FString(TEXT("record_id__v=")) + ToUrlString(RecordIdV.GetValue()));
	}
	if(AssigneeV.IsSet())
	{
		QueryParams.Add(FString(TEXT("assignee__v=")) + ToUrlString(AssigneeV.GetValue()));
	}
	if(StatusV.IsSet())
	{
		QueryParams.Add(FString(TEXT("status__v=")) + ToUrlString(StatusV.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/accept"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/cancel"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsCancelPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsCancelPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/complete"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsCompletePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsCompletePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/mdwaccept"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/mdwcomplete"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/mdwmanagecontent"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/mdwreassign"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/reassign"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsReassignPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsReassignPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) },
	{ TEXT("task_action"), FStringFormatArg(ToUrlString(TaskAction)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/{task_action}"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/undoaccept"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}/actions/updateduedate"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/tasks/{task_id}"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsTasksTaskIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("workflow_id"), FStringFormatArg(ToUrlString(WorkflowId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/{workflow_id}/actions"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("workflow_id"), FStringFormatArg(ToUrlString(WorkflowId)) },
	{ TEXT("workflow_action"), FStringFormatArg(ToUrlString(WorkflowAction)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/{workflow_id}/actions/{workflow_action}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("workflow_id"), FStringFormatArg(ToUrlString(WorkflowId)) },
	{ TEXT("workflow_action"), FStringFormatArg(ToUrlString(WorkflowAction)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/{workflow_id}/actions/{workflow_action}"), PathParams);

	TArray<FString> QueryParams;
	if(DocumentsSys.IsSet())
	{
		QueryParams.Add(FString(TEXT("documents__sys=")) + ToUrlString(DocumentsSys.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("workflow_id"), FStringFormatArg(ToUrlString(WorkflowId)) } };

	FString Path = FString::Format(TEXT("/objects/objectworkflows/{workflow_id}"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsObjectworkflowsWorkflowIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsPicklistsGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/picklists"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsPicklistsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsPicklistsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsPicklistsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsPicklistsPicklistNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("picklist_name"), FStringFormatArg(ToUrlString(PicklistName)) } };

	FString Path = FString::Format(TEXT("/objects/picklists/{picklist_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsPicklistsPicklistNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("picklist_name"), FStringFormatArg(ToUrlString(PicklistName)) },
	{ TEXT("picklist_value_name"), FStringFormatArg(ToUrlString(PicklistValueName)) } };

	FString Path = FString::Format(TEXT("/objects/picklists/{picklist_name}/{picklist_value_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePicklistValueNameDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePicklistValueNameDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePicklistValueNamePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("picklist_name"), FStringFormatArg(ToUrlString(PicklistName)) },
	{ TEXT("picklist_value_name"), FStringFormatArg(ToUrlString(PicklistValueName)) } };

	FString Path = FString::Format(TEXT("/objects/picklists/{picklist_name}/{picklist_value_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePicklistValueNamePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePicklistValueNamePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePicklistValueNamePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("picklist_name"), FStringFormatArg(ToUrlString(PicklistName)) } };

	FString Path = FString::Format(TEXT("/objects/picklists/{picklist_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("picklist_name"), FStringFormatArg(ToUrlString(PicklistName)) } };

	FString Path = FString::Format(TEXT("/objects/picklists/{picklist_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsPicklistsPicklistNamePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxActionsBuildproductionPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/sandbox/actions/buildproduction"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxActionsBuildproductionPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxActionsBuildproductionPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxActionsBuildproductionPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxActionsPromoteproductionPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/sandbox/actions/promoteproduction"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxActionsPromoteproductionPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxActionsPromoteproductionPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxActionsPromoteproductionPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxActionsRecheckusagePostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/sandbox/actions/recheckusage"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxActionsRecheckusagePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxActionsRecheckusagePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxActionsRecheckusagePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxBatchChangesizePostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/sandbox/batch/changesize"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxBatchChangesizePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxBatchChangesizePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxBatchChangesizePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxEntitlementsSetPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/sandbox/entitlements/set"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxEntitlementsSetPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxEntitlementsSetPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxEntitlementsSetPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/sandbox"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsSandboxGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxNameDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("name"), FStringFormatArg(ToUrlString(Name)) } };

	FString Path = FString::Format(TEXT("/objects/sandbox/{name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxNameDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsSandboxNameDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxNameDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/sandbox"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameActionsUpdatePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("api_name"), FStringFormatArg(ToUrlString(ApiName)) } };

	FString Path = FString::Format(TEXT("/objects/sandbox/snapshot/{api_name}/actions/update"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameActionsUpdatePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameActionsUpdatePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameActionsUpdatePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameActionsUpgradePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("api_name"), FStringFormatArg(ToUrlString(ApiName)) } };

	FString Path = FString::Format(TEXT("/objects/sandbox/snapshot/{api_name}/actions/upgrade"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameActionsUpgradePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameActionsUpgradePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameActionsUpgradePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("api_name"), FStringFormatArg(ToUrlString(ApiName)) } };

	FString Path = FString::Format(TEXT("/objects/sandbox/snapshot/{api_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxSnapshotApiNameDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxSnapshotGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/sandbox/snapshot"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxSnapshotGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxSnapshotPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/sandbox/snapshot"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxSnapshotPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxSnapshotPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxVaultIdActionsRefreshPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("vault_id"), FStringFormatArg(ToUrlString(VaultId)) } };

	FString Path = FString::Format(TEXT("/objects/sandbox/{vault_id}/actions/refresh"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxVaultIdActionsRefreshPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsSandboxVaultIdActionsRefreshPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxVaultIdActionsRefreshPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSandboxVaultIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("vault_id"), FStringFormatArg(ToUrlString(VaultId)) } };

	FString Path = FString::Format(TEXT("/objects/sandbox/{vault_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsSandboxVaultIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsSandboxVaultIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSandboxVaultIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSecuritypoliciesGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/securitypolicies"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsSecuritypoliciesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsSecuritypoliciesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSecuritypoliciesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsSecuritypoliciesSecurityPolicyNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("security_policy_name"), FStringFormatArg(ToUrlString(SecurityPolicyName)) } };

	FString Path = FString::Format(TEXT("/objects/securitypolicies/{security_policy_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsSecuritypoliciesSecurityPolicyNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsSecuritypoliciesSecurityPolicyNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsSecuritypoliciesSecurityPolicyNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/users/"));
	TArray<FString> QueryParams;
	if(Vaults.IsSet())
	{
		QueryParams.Add(FString(TEXT("vaults=")) + ToUrlString(Vaults.GetValue()));
	}
	if(ExcludeVaultMembership.IsSet())
	{
		QueryParams.Add(FString(TEXT("exclude_vault_membership=")) + ToUrlString(ExcludeVaultMembership.GetValue()));
	}
	if(ExcludeAppLicensing.IsSet())
	{
		QueryParams.Add(FString(TEXT("exclude_app_licensing=")) + ToUrlString(ExcludeAppLicensing.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsUsersGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/objects/users/{id}"), PathParams);

	TArray<FString> QueryParams;
	if(ExcludeVaultMembership.IsSet())
	{
		QueryParams.Add(FString(TEXT("exclude_vault_membership=")) + ToUrlString(ExcludeVaultMembership.GetValue()));
	}
	if(ExcludeAppLicensing.IsSet())
	{
		QueryParams.Add(FString(TEXT("exclude_app_licensing=")) + ToUrlString(ExcludeAppLicensing.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsUsersIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersIdPermissionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/objects/users/{id}/permissions"), PathParams);

	TArray<FString> QueryParams;
	if(Filter.IsSet())
	{
		QueryParams.Add(FString(TEXT("filter=")) + ToUrlString(Filter.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersIdPermissionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsUsersIdPermissionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersIdPermissionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/objects/users/{id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsUsersIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersMeGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/users/me"));
	TArray<FString> QueryParams;
	if(ExcludeVaultMembership.IsSet())
	{
		QueryParams.Add(FString(TEXT("exclude_vault_membership=")) + ToUrlString(ExcludeVaultMembership.GetValue()));
	}
	if(ExcludeAppLicensing.IsSet())
	{
		QueryParams.Add(FString(TEXT("exclude_app_licensing=")) + ToUrlString(ExcludeAppLicensing.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersMeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsUsersMeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersMeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersMePasswordPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/users/me/password"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersMePasswordPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsUsersMePasswordPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersMePasswordPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersMePermissionsGetRequest::ComputePath() const
{
	FString Path(TEXT("/objects/users/me/permissions"));
	TArray<FString> QueryParams;
	if(Filter.IsSet())
	{
		QueryParams.Add(FString(TEXT("filter=")) + ToUrlString(Filter.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersMePermissionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsUsersMePermissionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersMePermissionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersMePutRequest::ComputePath() const
{
	FString Path(TEXT("/objects/users/me"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersMePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsUsersMePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersMePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/users"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsUsersPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersPutRequest::ComputePath() const
{
	FString Path(TEXT("/objects/users"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsUsersPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersUserIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_id"), FStringFormatArg(ToUrlString(UserId)) } };

	FString Path = FString::Format(TEXT("/objects/users/{user_id}"), PathParams);

	TArray<FString> QueryParams;
	if(Domain.IsSet())
	{
		QueryParams.Add(FString(TEXT("domain=")) + ToUrlString(Domain.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersUserIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ObjectsUsersUserIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersUserIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsUsersUserIdVaultMembershipVaultIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("user_id"), FStringFormatArg(ToUrlString(UserId)) },
	{ TEXT("vault_id"), FStringFormatArg(ToUrlString(VaultId)) } };

	FString Path = FString::Format(TEXT("/objects/users/{user_id}/vault_membership/{vault_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ObjectsUsersUserIdVaultMembershipVaultIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsUsersUserIdVaultMembershipVaultIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsUsersUserIdVaultMembershipVaultIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsVaultActionsComparePostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/vault/actions/compare"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsVaultActionsComparePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsVaultActionsComparePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsVaultActionsComparePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ObjectsVaultActionsConfigreportPostRequest::ComputePath() const
{
	FString Path(TEXT("/objects/vault/actions/configreport"));
	return Path;
}

void OpenAPIDefaultApi::ObjectsVaultActionsConfigreportPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ObjectsVaultActionsConfigreportPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ObjectsVaultActionsConfigreportPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::QueryComponentsPostRequest::ComputePath() const
{
	FString Path(TEXT("/query/components"));
	return Path;
}

void OpenAPIDefaultApi::QueryComponentsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::QueryComponentsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::QueryComponentsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::QueryNextPagePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("next_page"), FStringFormatArg(ToUrlString(NextPage)) } };

	FString Path = FString::Format(TEXT("/query/{next_page}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::QueryNextPagePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIDescribeQuery.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-DescribeQuery"), XVaultAPIDescribeQuery.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::QueryNextPagePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::QueryNextPagePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::QueryPostRequest::ComputePath() const
{
	FString Path(TEXT("/query"));
	return Path;
}

void OpenAPIDefaultApi::QueryPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIDescribeQuery.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-DescribeQuery"), XVaultAPIDescribeQuery.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::QueryPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::QueryPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::QueryPreviousPagePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("previous_page"), FStringFormatArg(ToUrlString(PreviousPage)) } };

	FString Path = FString::Format(TEXT("/query/{previous_page}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::QueryPreviousPagePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIDescribeQuery.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-DescribeQuery"), XVaultAPIDescribeQuery.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::QueryPreviousPagePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::QueryPreviousPagePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2MeGetRequest::ComputePath() const
{
	FString Path(TEXT("/scim/v2/Me"));
	TArray<FString> QueryParams;
	if(Attributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("attributes=")) + ToUrlString(Attributes.GetValue()));
	}
	if(ExcludedAttributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("excludedAttributes=")) + ToUrlString(ExcludedAttributes.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ScimV2MeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2MeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2MeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2MePutRequest::ComputePath() const
{
	FString Path(TEXT("/scim/v2/Me"));
	TArray<FString> QueryParams;
	if(Attributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("attributes=")) + ToUrlString(Attributes.GetValue()));
	}
	if(ExcludedAttributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("excludedAttributes=")) + ToUrlString(ExcludedAttributes.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ScimV2MePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ScimV2MePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2MePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2ResourceTypesGetRequest::ComputePath() const
{
	FString Path(TEXT("/scim/v2/ResourceTypes"));
	return Path;
}

void OpenAPIDefaultApi::ScimV2ResourceTypesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2ResourceTypesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2ResourceTypesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2ResourceTypesTypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("type"), FStringFormatArg(ToUrlString(Type)) } };

	FString Path = FString::Format(TEXT("/scim/v2/ResourceTypes/{type}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ScimV2ResourceTypesTypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2ResourceTypesTypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2ResourceTypesTypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2SchemasGetRequest::ComputePath() const
{
	FString Path(TEXT("/scim/v2/Schemas"));
	return Path;
}

void OpenAPIDefaultApi::ScimV2SchemasGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2SchemasGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2SchemasGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2SchemasIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/scim/v2/Schemas/{id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ScimV2SchemasIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2SchemasIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2SchemasIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2ServiceProviderConfigGetRequest::ComputePath() const
{
	FString Path(TEXT("/scim/v2/ServiceProviderConfig"));
	return Path;
}

void OpenAPIDefaultApi::ScimV2ServiceProviderConfigGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2ServiceProviderConfigGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2ServiceProviderConfigGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2TypeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("type"), FStringFormatArg(ToUrlString(Type)) } };

	FString Path = FString::Format(TEXT("/scim/v2/{type}"), PathParams);

	TArray<FString> QueryParams;
	if(Filter.IsSet())
	{
		QueryParams.Add(FString(TEXT("filter=")) + ToUrlString(Filter.GetValue()));
	}
	if(Attributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("attributes=")) + ToUrlString(Attributes.GetValue()));
	}
	if(ExcludedAttributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("excludedAttributes=")) + ToUrlString(ExcludedAttributes.GetValue()));
	}
	if(SortBy.IsSet())
	{
		QueryParams.Add(FString(TEXT("sortBy=")) + ToUrlString(SortBy.GetValue()));
	}
	if(SortOrder.IsSet())
	{
		QueryParams.Add(FString(TEXT("sortOrder=")) + ToUrlString(SortOrder.GetValue()));
	}
	if(StartIndex.IsSet())
	{
		QueryParams.Add(FString(TEXT("startIndex=")) + ToUrlString(StartIndex.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ScimV2TypeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2TypeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2TypeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2TypeIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("type"), FStringFormatArg(ToUrlString(Type)) },
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/scim/v2/{type}/{id}"), PathParams);

	TArray<FString> QueryParams;
	if(Attributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("attributes=")) + ToUrlString(Attributes.GetValue()));
	}
	if(ExcludedAttributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("excludedAttributes=")) + ToUrlString(ExcludedAttributes.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ScimV2TypeIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2TypeIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2TypeIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2UsersGetRequest::ComputePath() const
{
	FString Path(TEXT("/scim/v2/Users"));
	TArray<FString> QueryParams;
	if(Filter.IsSet())
	{
		QueryParams.Add(FString(TEXT("filter=")) + ToUrlString(Filter.GetValue()));
	}
	if(Attributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("attributes=")) + ToUrlString(Attributes.GetValue()));
	}
	if(ExcludedAttributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("excludedAttributes=")) + ToUrlString(ExcludedAttributes.GetValue()));
	}
	if(SortBy.IsSet())
	{
		QueryParams.Add(FString(TEXT("sortBy=")) + ToUrlString(SortBy.GetValue()));
	}
	if(SortOrder.IsSet())
	{
		QueryParams.Add(FString(TEXT("sortOrder=")) + ToUrlString(SortOrder.GetValue()));
	}
	if(Count.IsSet())
	{
		QueryParams.Add(FString(TEXT("count=")) + ToUrlString(Count.GetValue()));
	}
	if(StartIndex.IsSet())
	{
		QueryParams.Add(FString(TEXT("startIndex=")) + ToUrlString(StartIndex.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ScimV2UsersGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2UsersGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2UsersGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2UsersIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/scim/v2/Users/{id}"), PathParams);

	TArray<FString> QueryParams;
	if(Filter.IsSet())
	{
		QueryParams.Add(FString(TEXT("filter=")) + ToUrlString(Filter.GetValue()));
	}
	if(Attributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("attributes=")) + ToUrlString(Attributes.GetValue()));
	}
	if(ExcludedAttributes.IsSet())
	{
		QueryParams.Add(FString(TEXT("excludedAttributes=")) + ToUrlString(ExcludedAttributes.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ScimV2UsersIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ScimV2UsersIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2UsersIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2UsersIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) } };

	FString Path = FString::Format(TEXT("/scim/v2/Users/{id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ScimV2UsersIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ScimV2UsersIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2UsersIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ScimV2UsersPostRequest::ComputePath() const
{
	FString Path(TEXT("/scim/v2/Users"));
	return Path;
}

void OpenAPIDefaultApi::ScimV2UsersPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ScimV2UsersPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ScimV2UsersPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesCertificateCertIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("cert_id"), FStringFormatArg(ToUrlString(CertId)) } };

	FString Path = FString::Format(TEXT("/services/certificate/{cert_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesCertificateCertIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesCertificateCertIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesCertificateCertIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesConfigurationModeActionsDisablePostRequest::ComputePath() const
{
	FString Path(TEXT("/services/configuration_mode/actions/disable"));
	return Path;
}

void OpenAPIDefaultApi::ServicesConfigurationModeActionsDisablePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesConfigurationModeActionsDisablePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesConfigurationModeActionsDisablePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesConfigurationModeActionsEnablePostRequest::ComputePath() const
{
	FString Path(TEXT("/services/configuration_mode/actions/enable"));
	return Path;
}

void OpenAPIDefaultApi::ServicesConfigurationModeActionsEnablePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesConfigurationModeActionsEnablePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesConfigurationModeActionsEnablePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesDirectdataFilesGetRequest::ComputePath() const
{
	FString Path(TEXT("/services/directdata/files"));
	TArray<FString> QueryParams;
	if(ExtractType.IsSet())
	{
		QueryParams.Add(FString(TEXT("extract_type=")) + ToUrlString(ExtractType.GetValue()));
	}
	if(StartTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("start_time=")) + ToUrlString(StartTime.GetValue()));
	}
	if(StopTime.IsSet())
	{
		QueryParams.Add(FString(TEXT("stop_time=")) + ToUrlString(StopTime.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ServicesDirectdataFilesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesDirectdataFilesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesDirectdataFilesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesDirectdataFilesNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("name"), FStringFormatArg(ToUrlString(Name)) } };

	FString Path = FString::Format(TEXT("/services/directdata/files/{name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesDirectdataFilesNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesDirectdataFilesNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesDirectdataFilesNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingItemsContentItemGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("item"), FStringFormatArg(ToUrlString(Item)) } };

	FString Path = FString::Format(TEXT("/services/file_staging/items/content/{item}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingItemsContentItemGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Range.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Range"), Range.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesFileStagingItemsContentItemGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingItemsContentItemGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingItemsItemDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("item"), FStringFormatArg(ToUrlString(Item)) } };

	FString Path = FString::Format(TEXT("/services/file_staging/items/{item}"), PathParams);

	TArray<FString> QueryParams;
	if(Recursive.IsSet())
	{
		QueryParams.Add(FString(TEXT("recursive=")) + ToUrlString(Recursive.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingItemsItemDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesFileStagingItemsItemDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingItemsItemDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingItemsItemGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("item"), FStringFormatArg(ToUrlString(Item)) } };

	FString Path = FString::Format(TEXT("/services/file_staging/items/{item}"), PathParams);

	TArray<FString> QueryParams;
	if(Recursive.IsSet())
	{
		QueryParams.Add(FString(TEXT("recursive=")) + ToUrlString(Recursive.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(FormatResult.IsSet())
	{
		QueryParams.Add(FString(TEXT("format_result=")) + ToUrlString(FormatResult.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingItemsItemGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesFileStagingItemsItemGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingItemsItemGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingItemsItemPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("item"), FStringFormatArg(ToUrlString(Item)) } };

	FString Path = FString::Format(TEXT("/services/file_staging/items/{item}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingItemsItemPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesFileStagingItemsItemPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingItemsItemPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingItemsPostRequest::ComputePath() const
{
	FString Path(TEXT("/services/file_staging/items"));
	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingItemsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentMD5.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-MD5"), ContentMD5.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesFileStagingItemsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingItemsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingUploadGetRequest::ComputePath() const
{
	FString Path(TEXT("/services/file_staging/upload/"));
	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingUploadGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesFileStagingUploadGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingUploadGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingUploadPostRequest::ComputePath() const
{
	FString Path(TEXT("/services/file_staging/upload"));
	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingUploadPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesFileStagingUploadPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingUploadPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("upload_session_id"), FStringFormatArg(ToUrlString(UploadSessionId)) } };

	FString Path = FString::Format(TEXT("/services/file_staging/upload/{upload_session_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("upload_session_id"), FStringFormatArg(ToUrlString(UploadSessionId)) } };

	FString Path = FString::Format(TEXT("/services/file_staging/upload/{upload_session_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPartsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("upload_session_id"), FStringFormatArg(ToUrlString(UploadSessionId)) } };

	FString Path = FString::Format(TEXT("/services/file_staging/upload/{upload_session_id}/parts"), PathParams);

	TArray<FString> QueryParams;
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPartsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPartsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPartsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("upload_session_id"), FStringFormatArg(ToUrlString(UploadSessionId)) } };

	FString Path = FString::Format(TEXT("/services/file_staging/upload/{upload_session_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("upload_session_id"), FStringFormatArg(ToUrlString(UploadSessionId)) } };

	FString Path = FString::Format(TEXT("/services/file_staging/upload/{upload_session_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIFilePartNumber.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-FilePartNumber"), XVaultAPIFilePartNumber.GetValue());
	}
	if (ContentMD5.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-MD5"), ContentMD5.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesFileStagingUploadUploadSessionIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesJobsHistoriesGetRequest::ComputePath() const
{
	FString Path(TEXT("/services/jobs/histories"));
	TArray<FString> QueryParams;
	if(StartDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("start_date=")) + ToUrlString(StartDate.GetValue()));
	}
	if(EndDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_date=")) + ToUrlString(EndDate.GetValue()));
	}
	if(Status.IsSet())
	{
		QueryParams.Add(FString(TEXT("status=")) + ToUrlString(Status.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ServicesJobsHistoriesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesJobsHistoriesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesJobsHistoriesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesJobsJobIdErrorsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/services/jobs/{job_id}/errors"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesJobsJobIdErrorsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesJobsJobIdErrorsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesJobsJobIdErrorsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesJobsJobIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/services/jobs/{job_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesJobsJobIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesJobsJobIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesJobsJobIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesJobsJobIdSummaryGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/services/jobs/{job_id}/summary"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesJobsJobIdSummaryGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesJobsJobIdSummaryGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesJobsJobIdSummaryGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesJobsJobIdTasksGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/services/jobs/{job_id}/tasks"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesJobsJobIdTasksGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesJobsJobIdTasksGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesJobsJobIdTasksGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesJobsMonitorsGetRequest::ComputePath() const
{
	FString Path(TEXT("/services/jobs/monitors"));
	TArray<FString> QueryParams;
	if(StartDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("start_date=")) + ToUrlString(StartDate.GetValue()));
	}
	if(EndDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_date=")) + ToUrlString(EndDate.GetValue()));
	}
	if(Status.IsSet())
	{
		QueryParams.Add(FString(TEXT("status=")) + ToUrlString(Status.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::ServicesJobsMonitorsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesJobsMonitorsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesJobsMonitorsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesJobsStartNowJobIdPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/services/jobs/start_now/{job_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesJobsStartNowJobIdPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesJobsStartNowJobIdPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesJobsStartNowJobIdPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesLoaderExtractPostRequest::ComputePath() const
{
	FString Path(TEXT("/services/loader/extract"));
	return Path;
}

void OpenAPIDefaultApi::ServicesLoaderExtractPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesLoaderExtractPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesLoaderExtractPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdFailurelogGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) },
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/services/loader/{job_id}/tasks/{task_id}/failurelog"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdFailurelogGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdFailurelogGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdFailurelogGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdResultsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) },
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/services/loader/{job_id}/tasks/{task_id}/results"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdResultsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdResultsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdResultsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) },
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/services/loader/{job_id}/tasks/{task_id}/results/renditions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) },
	{ TEXT("task_id"), FStringFormatArg(ToUrlString(TaskId)) } };

	FString Path = FString::Format(TEXT("/services/loader/{job_id}/tasks/{task_id}/successlog"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdSuccesslogGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesLoaderJobIdTasksTaskIdSuccesslogGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesLoaderLoadPostRequest::ComputePath() const
{
	FString Path(TEXT("/services/loader/load"));
	return Path;
}

void OpenAPIDefaultApi::ServicesLoaderLoadPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesLoaderLoadPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesLoaderLoadPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesPackageActionsValidatePostRequest::ComputePath() const
{
	FString Path(TEXT("/services/package/actions/validate"));
	return Path;
}

void OpenAPIDefaultApi::ServicesPackageActionsValidatePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesPackageActionsValidatePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesPackageActionsValidatePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesPackagePostRequest::ComputePath() const
{
	FString Path(TEXT("/services/package"));
	return Path;
}

void OpenAPIDefaultApi::ServicesPackagePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesPackagePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesPackagePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesPackagePutRequest::ComputePath() const
{
	FString Path(TEXT("/services/package"));
	return Path;
}

void OpenAPIDefaultApi::ServicesPackagePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesPackagePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesPackagePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesQueuesGetRequest::ComputePath() const
{
	FString Path(TEXT("/services/queues"));
	return Path;
}

void OpenAPIDefaultApi::ServicesQueuesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesQueuesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesQueuesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesQueuesQueueNameActionsDisableDeliveryPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("queue_name"), FStringFormatArg(ToUrlString(QueueName)) } };

	FString Path = FString::Format(TEXT("/services/queues/{queue_name}/actions/disable_delivery"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesQueuesQueueNameActionsDisableDeliveryPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesQueuesQueueNameActionsDisableDeliveryPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesQueuesQueueNameActionsDisableDeliveryPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesQueuesQueueNameActionsEnableDeliveryPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("queue_name"), FStringFormatArg(ToUrlString(QueueName)) } };

	FString Path = FString::Format(TEXT("/services/queues/{queue_name}/actions/enable_delivery"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesQueuesQueueNameActionsEnableDeliveryPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesQueuesQueueNameActionsEnableDeliveryPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesQueuesQueueNameActionsEnableDeliveryPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesQueuesQueueNameActionsResetPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("queue_name"), FStringFormatArg(ToUrlString(QueueName)) } };

	FString Path = FString::Format(TEXT("/services/queues/{queue_name}/actions/reset"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesQueuesQueueNameActionsResetPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesQueuesQueueNameActionsResetPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesQueuesQueueNameActionsResetPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesQueuesQueueNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("queue_name"), FStringFormatArg(ToUrlString(QueueName)) } };

	FString Path = FString::Format(TEXT("/services/queues/{queue_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesQueuesQueueNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::ServicesQueuesQueueNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesQueuesQueueNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::ServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("package_id"), FStringFormatArg(ToUrlString(PackageId)) } };

	FString Path = FString::Format(TEXT("/services/vobject/vault_package__v/{package_id}/actions/validate"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::ServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::ServicesVobjectVaultPackageVPackageIdActionsValidatePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::ServicesVobjectVaultPackageVPackageIdActionsValidatePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::SessionDeleteRequest::ComputePath() const
{
	FString Path(TEXT("/session"));
	return Path;
}

void OpenAPIDefaultApi::SessionDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::SessionDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::SessionDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::UicodeDistributionsDistributionNameCodeGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("distribution_name"), FStringFormatArg(ToUrlString(DistributionName)) } };

	FString Path = FString::Format(TEXT("/uicode/distributions/{distribution_name}/code"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::UicodeDistributionsDistributionNameCodeGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::UicodeDistributionsDistributionNameCodeGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::UicodeDistributionsDistributionNameCodeGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::UicodeDistributionsDistributionNameDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("distribution_name"), FStringFormatArg(ToUrlString(DistributionName)) } };

	FString Path = FString::Format(TEXT("/uicode/distributions/{distribution_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::UicodeDistributionsDistributionNameDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::UicodeDistributionsDistributionNameDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::UicodeDistributionsDistributionNameDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::UicodeDistributionsDistributionNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("distribution_name"), FStringFormatArg(ToUrlString(DistributionName)) } };

	FString Path = FString::Format(TEXT("/uicode/distributions/{distribution_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::UicodeDistributionsDistributionNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::UicodeDistributionsDistributionNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::UicodeDistributionsDistributionNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::UicodeDistributionsGetRequest::ComputePath() const
{
	FString Path(TEXT("/uicode/distributions"));
	return Path;
}

void OpenAPIDefaultApi::UicodeDistributionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::UicodeDistributionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::UicodeDistributionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::UicodeDistributionsPostRequest::ComputePath() const
{
	FString Path(TEXT("/uicode/distributions"));
	return Path;
}

void OpenAPIDefaultApi::UicodeDistributionsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::UicodeDistributionsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::UicodeDistributionsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectVaultPackageVPackageIdActionsDeployPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("package_id"), FStringFormatArg(ToUrlString(PackageId)) } };

	FString Path = FString::Format(TEXT("/vobject/vault_package__v/{package_id}/actions/deploy"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectVaultPackageVPackageIdActionsDeployPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectVaultPackageVPackageIdActionsDeployPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectVaultPackageVPackageIdActionsDeployPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectVaultPackageVPackageIdActionsDeployResultsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("package_id"), FStringFormatArg(ToUrlString(PackageId)) } };

	FString Path = FString::Format(TEXT("/vobject/vault_package__v/{package_id}/actions/deploy/results"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectVaultPackageVPackageIdActionsDeployResultsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectVaultPackageVPackageIdActionsDeployResultsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectVaultPackageVPackageIdActionsDeployResultsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("job_status"), FStringFormatArg(ToUrlString(JobStatus)) },
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/vobjects/cascadedelete/results/{object_name}/{job_status}/{job_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("job_status"), FStringFormatArg(ToUrlString(JobStatus)) },
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/vobjects/deepcopy/results/{object_name}/{job_status}/{job_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsEdlItemVActionsCreateplaceholderPostRequest::ComputePath() const
{
	FString Path(TEXT("/vobjects/edl_item__v/actions/createplaceholder"));
	return Path;
}

void OpenAPIDefaultApi::VobjectsEdlItemVActionsCreateplaceholderPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsEdlItemVActionsCreateplaceholderPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsEdlItemVActionsCreateplaceholderPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsMergesJobIdLogGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/vobjects/merges/{job_id}/log"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsMergesJobIdLogGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsMergesJobIdLogGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsMergesJobIdLogGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsMergesJobIdResultsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/vobjects/merges/{job_id}/results"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsMergesJobIdResultsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsMergesJobIdResultsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsMergesJobIdResultsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsMergesJobIdStatusGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("job_id"), FStringFormatArg(ToUrlString(JobId)) } };

	FString Path = FString::Format(TEXT("/vobjects/merges/{job_id}/status"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsMergesJobIdStatusGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsMergesJobIdStatusGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsMergesJobIdStatusGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameActionsActionNamePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("action_name"), FStringFormatArg(ToUrlString(ActionName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/actions/{action_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsActionNamePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsActionNamePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameActionsActionNamePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameActionsChangetypePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/actions/changetype"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsChangetypePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsChangetypePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameActionsChangetypePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameActionsMergePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/actions/merge"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsMergePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		if (OpenAPIVobjectsObjectNameActionsMergePostRequestInner.IsSet())
		{
			WriteJsonValue(Writer, OpenAPIVobjectsObjectNameActionsMergePostRequestInner.GetValue());
		}
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIVobjectsObjectNameActionsMergePostRequestInner) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIVobjectsObjectNameActionsMergePostRequestInner) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsMergePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameActionsMergePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameActionsRecalculaterollupsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/actions/recalculaterollups"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsRecalculaterollupsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameActionsRecalculaterollupsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameActionsRecalculaterollupsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameActionsRecalculaterollupsPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/actions/recalculaterollups"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsRecalculaterollupsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsRecalculaterollupsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameActionsRecalculaterollupsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/actions/updatecorporatecurrency"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameActionsUpdatecorporatecurrencyPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameActionsUpdatecorporatecurrencyPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/attachments/batch"), PathParams);

	TArray<FString> QueryParams;
	if(IdParam.IsSet())
	{
		QueryParams.Add(FString(TEXT("idParam=")) + ToUrlString(IdParam.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/attachments/batch"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/attachments/batch"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameAttachmentsBatchPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameIdRolesRoleNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("id"), FStringFormatArg(ToUrlString(Id)) },
	{ TEXT("role_name"), FStringFormatArg(ToUrlString(RoleName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{id}/roles/{role_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameIdRolesRoleNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameIdRolesRoleNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameIdRolesRoleNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsActionNameGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("action_name"), FStringFormatArg(ToUrlString(ActionName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/actions/{action_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsActionNameGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsActionNameGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsActionNameGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsActionNamePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("action_name"), FStringFormatArg(ToUrlString(ActionName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/actions/{action_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsActionNamePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsActionNamePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsActionNamePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/actions/cascadedelete"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsCascadedeletePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsCascadedeletePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/actions/deepcopy"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsDeepcopyPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsDeepcopyPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/actions"), PathParams);

	TArray<FString> QueryParams;
	if(Loc.IsSet())
	{
		QueryParams.Add(FString(TEXT("loc=")) + ToUrlString(Loc.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdActionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_field_name"), FStringFormatArg(ToUrlString(AttachmentFieldName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_field_name"), FStringFormatArg(ToUrlString(AttachmentFieldName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachment_fields/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) },
	{ TEXT("attachment_version"), FStringFormatArg(ToUrlString(AttachmentVersion)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"), PathParams);

	TArray<FString> QueryParams;
	if(Restore.IsSet())
	{
		QueryParams.Add(FString(TEXT("restore=")) + ToUrlString(Restore.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) },
	{ TEXT("attachment_id"), FStringFormatArg(ToUrlString(AttachmentId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments/file"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsFileGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsFileGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/attachments"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAttachmentsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAudittrailGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}/audittrail"), PathParams);

	TArray<FString> QueryParams;
	if(StartDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("start_date=")) + ToUrlString(StartDate.GetValue()));
	}
	if(EndDate.IsSet())
	{
		QueryParams.Add(FString(TEXT("end_date=")) + ToUrlString(EndDate.GetValue()));
	}
	if(FormatResult.IsSet())
	{
		QueryParams.Add(FString(TEXT("format_result=")) + ToUrlString(FormatResult.GetValue()));
	}
	if(Limit.IsSet())
	{
		QueryParams.Add(FString(TEXT("limit=")) + ToUrlString(Limit.GetValue()));
	}
	if(Offset.IsSet())
	{
		QueryParams.Add(FString(TEXT("offset=")) + ToUrlString(Offset.GetValue()));
	}
	if(Events.IsSet())
	{
		QueryParams.Add(FString(TEXT("events=")) + ToUrlString(Events.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAudittrailGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAudittrailGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdAudittrailGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) },
	{ TEXT("object_record_id"), FStringFormatArg(ToUrlString(ObjectRecordId)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/{object_record_id}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameObjectRecordIdGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNamePostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}"), PathParams);

	TArray<FString> QueryParams;
	if(IdParam.IsSet())
	{
		QueryParams.Add(FString(TEXT("idParam=")) + ToUrlString(IdParam.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNamePostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPINoTriggers.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-NoTriggers"), XVaultAPINoTriggers.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNamePostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNamePostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNamePutRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNamePutRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("PUT"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIMigrationMode.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-MigrationMode"), XVaultAPIMigrationMode.GetValue());
	}
	if (XVaultAPINoTriggers.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-NoTriggers"), XVaultAPINoTriggers.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNamePutResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNamePutResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameRolesDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/roles"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameRolesDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("DELETE"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsObjectNameRolesDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameRolesDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsObjectNameRolesPostRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("object_name"), FStringFormatArg(ToUrlString(ObjectName)) } };

	FString Path = FString::Format(TEXT("/vobjects/{object_name}/roles"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsObjectNameRolesPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("POST"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (ContentType.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Content-Type"), ContentType.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPIDefaultApi::VobjectsObjectNameRolesPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsObjectNameRolesPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPIDefaultApi::VobjectsOutboundPackageVPackageIdDependenciesGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("package_id"), FStringFormatArg(ToUrlString(PackageId)) } };

	FString Path = FString::Format(TEXT("/vobjects/outbound_package__v/{package_id}/dependencies"), PathParams);

	return Path;
}

void OpenAPIDefaultApi::VobjectsOutboundPackageVPackageIdDependenciesGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = {  };

	HttpRequest->SetVerb(TEXT("GET"));

	// Header parameters
	if (Authorization.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Authorization"), Authorization.GetValue());
	}
	if (Accept.IsSet())
	{
		HttpRequest->SetHeader(TEXT("Accept"), Accept.GetValue());
	}
	if (XVaultAPIClientID.IsSet())
	{
		HttpRequest->SetHeader(TEXT("X-VaultAPI-ClientID"), XVaultAPIClientID.GetValue());
	}

}

void OpenAPIDefaultApi::VobjectsOutboundPackageVPackageIdDependenciesGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	}
}

bool OpenAPIDefaultApi::VobjectsOutboundPackageVPackageIdDependenciesGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

}
