/*
 * Veeva Vault API v25.1
 *
 * The latest GA version of the Vault REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`api_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_mdl_components_component_type_and_record_name_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiMdlComponentsComponentTypeAndRecordNameFilesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_mdl_components_component_type_and_record_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiMdlComponentsComponentTypeAndRecordNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_mdl_execute_async_job_id_results_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiMdlExecuteAsyncJobIdResultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_mdl_execute_async_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiMdlExecuteAsyncPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_mdl_execute_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiMdlExecutePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`api_mdl_files_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ApiMdlFilesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`audittrail_audit_trail_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AudittrailAuditTrailTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_discovery_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthDiscoveryPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_oauth_session_oath_oidc_profile_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthOauthSessionOathOidcProfileIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_class_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeClassNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_class_name_disable_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeClassNameDisablePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_class_name_enable_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeClassNameEnablePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_class_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeClassNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_profiler_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeProfilerGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_profiler_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeProfilerPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_profiler_session_name_actions_end_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeProfilerSessionNameActionsEndPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_profiler_session_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeProfilerSessionNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_profiler_session_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeProfilerSessionNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_profiler_session_name_results_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodeProfilerSessionNameResultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`code_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CodePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`composites_trees_edl_hierarchy_or_template_actions_listnodes_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`composites_trees_edl_hierarchy_or_template_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompositesTreesEdlHierarchyOrTemplateGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`composites_trees_edl_hierarchy_v_parent_node_id_children_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompositesTreesEdlHierarchyVParentNodeIdChildrenGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`composites_trees_edl_hierarchy_v_parent_node_id_children_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompositesTreesEdlHierarchyVParentNodeIdChildrenPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_component_type_and_record_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationComponentTypeAndRecordNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_component_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationComponentTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_object_name_and_object_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationObjectNameAndObjectTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_objecttype_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationObjecttypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_role_assignment_rule_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationRoleAssignmentRuleDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_role_assignment_rule_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationRoleAssignmentRuleGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_role_assignment_rule_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationRoleAssignmentRulePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`configuration_role_assignment_rule_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigurationRoleAssignmentRulePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegation_login_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegationLoginPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delegation_vaults_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DelegationVaultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`keep_alive_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum KeepAlivePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`limits_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LimitsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logs_api_usage_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogsApiUsageGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logs_code_debug_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogsCodeDebugGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logs_code_debug_id_actions_reset_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogsCodeDebugIdActionsResetDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logs_code_debug_id_actions_reset_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogsCodeDebugIdActionsResetPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logs_code_debug_id_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogsCodeDebugIdFilesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logs_code_debug_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogsCodeDebugIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logs_code_debug_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogsCodeDebugPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logs_code_runtime_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogsCodeRuntimeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`messages_message_type_actions_import_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MessagesMessageTypeActionsImportPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`messages_message_type_language_lang_actions_export_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MessagesMessageTypeLanguageLangActionsExportPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_audittrail_audit_trail_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataAudittrailAuditTrailTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_audittrail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataAudittrailGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_components_component_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataComponentsComponentTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_components_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataComponentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_binders_templates_bindernodes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsBindersTemplatesBindernodesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_binders_templates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsBindersTemplatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_annotations_placemarks_types_placemark_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_annotations_references_types_reference_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_annotations_types_annotation_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_events_event_type_types_event_subtype_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsEventsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_lock_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsLockGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_properties_find_common_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsPropertiesFindCommonPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_properties_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsPropertiesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_templates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsTemplatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_types_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsTypesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_types_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsTypesTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_types_type_relationships_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsTypesTypeRelationshipsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_types_type_subtypes_subtype_classifications_classification_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_documents_types_type_subtypes_subtype_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsGroupsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_securitypolicies_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsSecuritypoliciesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_objects_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataObjectsUsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_query_archived_documents_relationships_document_signature_sysr_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_query_documents_relationships_document_signature_sysr_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_vobjects_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataVobjectsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_vobjects_object_name_actions_canceldeployment_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataVobjectsObjectNameActionsCanceldeploymentPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_vobjects_object_name_fields_object_field_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataVobjectsObjectNameFieldsObjectFieldNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_vobjects_object_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataVobjectsObjectNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_vobjects_object_name_page_layouts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataVobjectsObjectNamePageLayoutsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_vobjects_object_name_page_layouts_layout_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataVobjectsObjectNamePageLayoutsLayoutNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`notifications_histories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum NotificationsHistoriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_workflow_actions_action_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectWorkflowActionsActionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_workflow_actions_action_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectWorkflowActionsActionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_workflow_actions_canceltasks_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectWorkflowActionsCanceltasksPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_workflow_actions_cancelworkflows_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectWorkflowActionsCancelworkflowsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_workflow_actions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectWorkflowActionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_workflow_actions_reassigntasks_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectWorkflowActionsReassigntasksPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`object_workflow_actions_replaceworkflowowner_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectWorkflowActionsReplaceworkflowownerPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_actions_export_job_id_results_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersActionsExportJobIdResultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_actions_export_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdActionsExportPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_actions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdActionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_binding_rule_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdBindingRulePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_documents_node_id_binding_rule_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_documents_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdDocumentsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_documents_section_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdDocumentsSectionIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_documents_section_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdDocumentsSectionIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_roles_role_name_and_user_or_group_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_sections_node_id_binding_rule_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdSectionsNodeIdBindingRulePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_sections_node_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdSectionsNodeIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_sections_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdSectionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_sections_section_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdSectionsSectionIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_sections_section_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdSectionsSectionIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdVersionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_versions_major_version_minor_version_actions_export_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_versions_major_version_minor_version_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_versions_major_version_minor_version_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_versions_major_version_minor_version_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_versions_major_version_minor_version_relationships_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_versions_major_version_minor_version_relationships_relationship_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_versions_major_version_minor_version_relationships_relationship_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_binder_id_versions_major_version_minor_version_sections_section_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_id_roles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersIdRolesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_id_roles_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersIdRolesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_id_roles_role_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersIdRolesRoleNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_id_versions_major_version_minor_version_lifecycle_actions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_id_versions_major_version_minor_version_lifecycle_actions_name_v_entry_requirements_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_id_versions_major_version_minor_version_lifecycle_actions_name_v_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_lifecycle_actions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersLifecycleActionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_lifecycle_actions_user_action_name_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersLifecycleActionsUserActionNamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_templates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersTemplatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_templates_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersTemplatesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_templates_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersTemplatesPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_templates_template_name_bindernodes_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersTemplatesTemplateNameBindernodesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_templates_template_name_bindernodes_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersTemplatesTemplateNameBindernodesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_templates_template_name_bindernodes_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersTemplatesTemplateNameBindernodesPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_templates_template_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersTemplatesTemplateNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_binders_templates_template_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsBindersTemplatesTemplateNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_deletions_documents_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDeletionsDocumentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_deletions_vobjects_object_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDeletionsVobjectsObjectNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_actions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsActionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_actions_lifecycle_and_state_and_action_job_id_results_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_actions_workflow_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsActionsWorkflowNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_actions_workflow_name_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsActionsWorkflowNamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_annotations_batch_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsAnnotationsBatchDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_annotations_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsAnnotationsBatchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_annotations_batch_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsAnnotationsBatchPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_annotations_replies_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsAnnotationsRepliesBatchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_attachments_batch_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsAttachmentsBatchDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_attachments_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsAttachmentsBatchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_attachments_batch_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsAttachmentsBatchPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_batch_actions_fileextract_job_id_results_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsBatchActionsFileextractJobIdResultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_batch_actions_fileextract_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsBatchActionsFileextractPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_batch_actions_reclassify_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsBatchActionsReclassifyPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_batch_actions_rerender_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsBatchActionsRerenderPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_batch_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsBatchDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_batch_lock_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsBatchLockDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsBatchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_batch_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsBatchPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_anchors_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAnchorsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_annotations_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAnnotationsFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_annotations_file_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAnnotationsFilePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_attachment_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_attachment_id_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_attachment_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsAttachmentIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_attachment_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsAttachmentIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_attachment_id_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_attachments_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAttachmentsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_audittrail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdAudittrailGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_events_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdEventsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_lock_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdLockDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_lock_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdLockGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_lock_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdLockPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_major_version_minor_version_attachments_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_renditions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdRenditionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_renditions_rendition_type_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_renditions_rendition_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdRenditionsRenditionTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_renditions_rendition_type_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdRenditionsRenditionTypePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_renditions_rendition_type_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdRenditionsRenditionTypePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_roles_role_name_and_user_or_group_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_version_major_version_minor_version_attachments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_annotations_annotation_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_annotations_annotation_id_replies_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_annotations_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_annotations_file_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_annotations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_attachments_attachment_id_versions_attachment_version_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_attachments_attachment_id_versions_attachment_version_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_doc_export_annotations_to_csv_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_events_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_export_video_annotations_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_relationships_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_relationships_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_relationships_relationship_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_relationships_relationship_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_renditions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_doc_id_versions_major_version_minor_version_thumbnail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_id_roles_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsIdRolesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_id_roles_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsIdRolesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_id_roles_role_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsIdRolesRoleNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_id_versions_major_version_minor_version_lifecycle_actions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_id_versions_major_version_minor_version_lifecycle_actions_name_v_entry_requirements_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_id_versions_major_version_minor_version_lifecycle_actions_name_v_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_lifecycle_actions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsLifecycleActionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_lifecycle_actions_user_action_name_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsLifecycleActionsUserActionNamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_relationships_batch_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsRelationshipsBatchDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_relationships_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsRelationshipsBatchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_renditions_batch_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsRenditionsBatchDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_renditions_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsRenditionsBatchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_roles_batch_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsRolesBatchDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_roles_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsRolesBatchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_templates_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsTemplatesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_templates_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsTemplatesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_templates_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsTemplatesPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_templates_template_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsTemplatesTemplateNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_templates_template_name_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsTemplatesTemplateNameFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_templates_template_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsTemplatesTemplateNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_templates_template_name_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsTemplatesTemplateNamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_tokens_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsTokensPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_versions_batch_actions_fileextract_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsVersionsBatchActionsFileextractPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_versions_batch_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsVersionsBatchDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_documents_versions_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDocumentsVersionsBatchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_domain_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDomainGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_domains_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsDomainsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_edl_matched_documents_batch_actions_add_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsEdlMatchedDocumentsBatchActionsAddPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_edl_matched_documents_batch_actions_remove_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsEdlMatchedDocumentsBatchActionsRemovePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_groups_auto_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsGroupsAutoGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_groups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsGroupsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_groups_group_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsGroupsGroupIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_groups_group_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsGroupsGroupIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_groups_group_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsGroupsGroupIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_groups_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsGroupsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_licenses_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsLicensesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_actions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsActionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_actions_workflow_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsActionsWorkflowNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_actions_workflow_name_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsActionsWorkflowNamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_accept_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsCancelPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsCompletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_mdwaccept_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_mdwcomplete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_mdwmanagecontent_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_mdwreassign_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_reassign_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsReassignPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_task_action_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_undoaccept_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_actions_updateduedate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_tasks_task_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsTasksTaskIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_workflow_id_actions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsWorkflowIdActionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_workflow_id_actions_workflow_action_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_workflow_id_actions_workflow_action_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_objectworkflows_workflow_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsObjectworkflowsWorkflowIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_picklists_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsPicklistsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_picklists_picklist_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsPicklistsPicklistNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_picklists_picklist_name_picklist_value_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsPicklistsPicklistNamePicklistValueNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_picklists_picklist_name_picklist_value_name_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsPicklistsPicklistNamePicklistValueNamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_picklists_picklist_name_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsPicklistsPicklistNamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_picklists_picklist_name_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsPicklistsPicklistNamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_actions_buildproduction_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxActionsBuildproductionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_actions_promoteproduction_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxActionsPromoteproductionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_actions_recheckusage_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxActionsRecheckusagePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_batch_changesize_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxBatchChangesizePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_entitlements_set_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxEntitlementsSetPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_snapshot_api_name_actions_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxSnapshotApiNameActionsUpdatePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_snapshot_api_name_actions_upgrade_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxSnapshotApiNameActionsUpgradePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_snapshot_api_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxSnapshotApiNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_snapshot_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxSnapshotGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_snapshot_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxSnapshotPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_vault_id_actions_refresh_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxVaultIdActionsRefreshPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_sandbox_vault_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSandboxVaultIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_securitypolicies_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSecuritypoliciesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_securitypolicies_security_policy_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsSecuritypoliciesSecurityPolicyNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_id_permissions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersIdPermissionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersMeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_me_password_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersMePasswordPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_me_permissions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersMePermissionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_me_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersMePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_user_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersUserIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_users_user_id_vault_membership_vault_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsUsersUserIdVaultMembershipVaultIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_vault_actions_compare_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsVaultActionsComparePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`objects_vault_actions_configreport_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ObjectsVaultActionsConfigreportPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_components_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryComponentsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_next_page_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryNextPagePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`query_previous_page_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum QueryPreviousPagePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_me_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2MeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_me_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2MePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_resource_types_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2ResourceTypesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_resource_types_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2ResourceTypesTypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_schemas_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2SchemasGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_schemas_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2SchemasIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_service_provider_config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2ServiceProviderConfigGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_type_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2TypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_type_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2TypeIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_users_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2UsersGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_users_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2UsersIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_users_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2UsersIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scim_v2_users_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScimV2UsersPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_certificate_cert_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesCertificateCertIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_configuration_mode_actions_disable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesConfigurationModeActionsDisablePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_configuration_mode_actions_enable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesConfigurationModeActionsEnablePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_directdata_files_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesDirectdataFilesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_directdata_files_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesDirectdataFilesNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_items_content_item_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingItemsContentItemGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_items_item_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingItemsItemDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_items_item_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingItemsItemGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_items_item_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingItemsItemPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_items_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingItemsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_upload_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingUploadGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_upload_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingUploadPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_upload_upload_session_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingUploadUploadSessionIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_upload_upload_session_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingUploadUploadSessionIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_upload_upload_session_id_parts_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingUploadUploadSessionIdPartsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_upload_upload_session_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingUploadUploadSessionIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_file_staging_upload_upload_session_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesFileStagingUploadUploadSessionIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_jobs_histories_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesJobsHistoriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_jobs_job_id_errors_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesJobsJobIdErrorsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_jobs_job_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesJobsJobIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_jobs_job_id_summary_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesJobsJobIdSummaryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_jobs_job_id_tasks_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesJobsJobIdTasksGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_jobs_monitors_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesJobsMonitorsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_jobs_start_now_job_id_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesJobsStartNowJobIdPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_loader_extract_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesLoaderExtractPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_loader_job_id_tasks_task_id_failurelog_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesLoaderJobIdTasksTaskIdFailurelogGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_loader_job_id_tasks_task_id_results_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesLoaderJobIdTasksTaskIdResultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_loader_job_id_tasks_task_id_results_renditions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_loader_job_id_tasks_task_id_successlog_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesLoaderJobIdTasksTaskIdSuccesslogGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_loader_load_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesLoaderLoadPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_package_actions_validate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesPackageActionsValidatePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_package_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesPackagePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_package_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesPackagePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_queues_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesQueuesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_queues_queue_name_actions_disable_delivery_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesQueuesQueueNameActionsDisableDeliveryPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_queues_queue_name_actions_enable_delivery_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesQueuesQueueNameActionsEnableDeliveryPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_queues_queue_name_actions_reset_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesQueuesQueueNameActionsResetPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_queues_queue_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesQueuesQueueNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`services_vobject_vault_package_v_package_id_actions_validate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ServicesVobjectVaultPackageVPackageIdActionsValidatePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uicode_distributions_distribution_name_code_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UicodeDistributionsDistributionNameCodeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uicode_distributions_distribution_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UicodeDistributionsDistributionNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uicode_distributions_distribution_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UicodeDistributionsDistributionNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uicode_distributions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UicodeDistributionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`uicode_distributions_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UicodeDistributionsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobject_vault_package_v_package_id_actions_deploy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectVaultPackageVPackageIdActionsDeployPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobject_vault_package_v_package_id_actions_deploy_results_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectVaultPackageVPackageIdActionsDeployResultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_cascadedelete_results_object_name_job_status_job_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_deepcopy_results_object_name_job_status_job_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_edl_item_v_actions_createplaceholder_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsEdlItemVActionsCreateplaceholderPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_merges_job_id_log_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsMergesJobIdLogGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_merges_job_id_results_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsMergesJobIdResultsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_merges_job_id_status_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsMergesJobIdStatusGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_actions_action_name_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameActionsActionNamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_actions_changetype_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameActionsChangetypePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_actions_merge_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameActionsMergePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_actions_recalculaterollups_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameActionsRecalculaterollupsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_actions_recalculaterollups_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameActionsRecalculaterollupsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_actions_updatecorporatecurrency_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameActionsUpdatecorporatecurrencyPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_attachments_batch_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameAttachmentsBatchDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_attachments_batch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameAttachmentsBatchPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_attachments_batch_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameAttachmentsBatchPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_id_roles_role_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameIdRolesRoleNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_actions_action_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdActionsActionNameGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_actions_action_name_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdActionsActionNamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_actions_cascadedelete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdActionsCascadedeletePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_actions_deepcopy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdActionsDeepcopyPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_actions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdActionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachment_fields_attachment_field_name_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachment_fields_attachment_field_name_file_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachment_fields_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_attachment_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_attachment_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_attachment_id_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_attachment_id_versions_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_file_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsFileGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_attachments_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAttachmentsPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_audittrail_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdAudittrailGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_object_record_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameObjectRecordIdGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNamePostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNamePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_roles_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameRolesDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_object_name_roles_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsObjectNameRolesPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vobjects_outbound_package_v_package_id_dependencies_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VobjectsOutboundPackageVPackageIdDependenciesGetError {
    UnknownValue(serde_json::Value),
}


pub async fn api_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ApiGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/api/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_mdl_components_component_type_and_record_name_files_get(configuration: &configuration::Configuration, component_type_and_record_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ApiMdlComponentsComponentTypeAndRecordNameFilesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_component_type_and_record_name = component_type_and_record_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/api/mdl/components/{component_type_and_record_name}/files", configuration.base_path, component_type_and_record_name=crate::apis::urlencode(p_component_type_and_record_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiMdlComponentsComponentTypeAndRecordNameFilesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_mdl_components_component_type_and_record_name_get(configuration: &configuration::Configuration, component_type_and_record_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ApiMdlComponentsComponentTypeAndRecordNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_component_type_and_record_name = component_type_and_record_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/api/mdl/components/{component_type_and_record_name}", configuration.base_path, component_type_and_record_name=crate::apis::urlencode(p_component_type_and_record_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiMdlComponentsComponentTypeAndRecordNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_mdl_execute_async_job_id_results_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ApiMdlExecuteAsyncJobIdResultsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/api/mdl/execute_async/{job_id}/results", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiMdlExecuteAsyncJobIdResultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_mdl_execute_async_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ApiMdlExecuteAsyncPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/api/mdl/execute_async", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiMdlExecuteAsyncPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_mdl_execute_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ApiMdlExecutePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/api/mdl/execute", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiMdlExecutePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn api_mdl_files_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ApiMdlFilesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/api/mdl/files", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ApiMdlFilesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn audittrail_audit_trail_type_get(configuration: &configuration::Configuration, audit_trail_type: &str, start_date: Option<&str>, end_date: Option<&str>, all_dates: Option<&str>, format_result: Option<&str>, limit: Option<&str>, offset: Option<&str>, objects: Option<&str>, events: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<AudittrailAuditTrailTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_audit_trail_type = audit_trail_type;
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_all_dates = all_dates;
    let p_format_result = format_result;
    let p_limit = limit;
    let p_offset = offset;
    let p_objects = objects;
    let p_events = events;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/audittrail/{audit_trail_type}", configuration.base_path, audit_trail_type=crate::apis::urlencode(p_audit_trail_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_all_dates {
        req_builder = req_builder.query(&[("all_dates", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format_result {
        req_builder = req_builder.query(&[("format_result", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_objects {
        req_builder = req_builder.query(&[("objects", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_events {
        req_builder = req_builder.query(&[("events", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AudittrailAuditTrailTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn auth_discovery_post(configuration: &configuration::Configuration, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<AuthDiscoveryPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/auth/discovery", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthDiscoveryPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn auth_oauth_session_oath_oidc_profile_id_post(configuration: &configuration::Configuration, oath_oidc_profile_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<AuthOauthSessionOathOidcProfileIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_oath_oidc_profile_id = oath_oidc_profile_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/auth/oauth/session/{oath_oidc_profile_id}", configuration.base_path, oath_oidc_profile_id=crate::apis::urlencode(p_oath_oidc_profile_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthOauthSessionOathOidcProfileIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn auth_post(configuration: &configuration::Configuration, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<AuthPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/auth", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_class_name_delete(configuration: &configuration::Configuration, class_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeClassNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_class_name = class_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/{class_name}", configuration.base_path, class_name=crate::apis::urlencode(p_class_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeClassNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_class_name_disable_put(configuration: &configuration::Configuration, class_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeClassNameDisablePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_class_name = class_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/{class_name}/disable", configuration.base_path, class_name=crate::apis::urlencode(p_class_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeClassNameDisablePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_class_name_enable_put(configuration: &configuration::Configuration, class_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeClassNameEnablePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_class_name = class_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/{class_name}/enable", configuration.base_path, class_name=crate::apis::urlencode(p_class_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeClassNameEnablePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_class_name_get(configuration: &configuration::Configuration, class_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeClassNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_class_name = class_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/{class_name}", configuration.base_path, class_name=crate::apis::urlencode(p_class_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeClassNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_profiler_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeProfilerGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/profiler", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeProfilerGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_profiler_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeProfilerPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/profiler", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeProfilerPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_profiler_session_name_actions_end_post(configuration: &configuration::Configuration, session_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeProfilerSessionNameActionsEndPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_name = session_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/profiler/{session_name}/actions/end", configuration.base_path, session_name=crate::apis::urlencode(p_session_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeProfilerSessionNameActionsEndPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_profiler_session_name_delete(configuration: &configuration::Configuration, session_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeProfilerSessionNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_name = session_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/profiler/{session_name}", configuration.base_path, session_name=crate::apis::urlencode(p_session_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeProfilerSessionNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_profiler_session_name_get(configuration: &configuration::Configuration, session_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeProfilerSessionNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_name = session_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/profiler/{session_name}", configuration.base_path, session_name=crate::apis::urlencode(p_session_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeProfilerSessionNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_profiler_session_name_results_get(configuration: &configuration::Configuration, session_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodeProfilerSessionNameResultsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_session_name = session_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code/profiler/{session_name}/results", configuration.base_path, session_name=crate::apis::urlencode(p_session_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodeProfilerSessionNameResultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn code_put(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CodePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/code", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CodePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn composites_trees_edl_hierarchy_or_template_actions_listnodes_post(configuration: &configuration::Configuration, edl_hierarchy_or_template: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_edl_hierarchy_or_template = edl_hierarchy_or_template;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/composites/trees/{edl_hierarchy_or_template}/actions/listnodes", configuration.base_path, edl_hierarchy_or_template=crate::apis::urlencode(p_edl_hierarchy_or_template));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn composites_trees_edl_hierarchy_or_template_get(configuration: &configuration::Configuration, edl_hierarchy_or_template: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CompositesTreesEdlHierarchyOrTemplateGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_edl_hierarchy_or_template = edl_hierarchy_or_template;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/composites/trees/{edl_hierarchy_or_template}", configuration.base_path, edl_hierarchy_or_template=crate::apis::urlencode(p_edl_hierarchy_or_template));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CompositesTreesEdlHierarchyOrTemplateGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn composites_trees_edl_hierarchy_v_parent_node_id_children_get(configuration: &configuration::Configuration, parent_node_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CompositesTreesEdlHierarchyVParentNodeIdChildrenGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_parent_node_id = parent_node_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/composites/trees/edl_hierarchy__v/{parent_node_id}/children", configuration.base_path, parent_node_id=crate::apis::urlencode(p_parent_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CompositesTreesEdlHierarchyVParentNodeIdChildrenGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn composites_trees_edl_hierarchy_v_parent_node_id_children_put(configuration: &configuration::Configuration, parent_node_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<CompositesTreesEdlHierarchyVParentNodeIdChildrenPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_parent_node_id = parent_node_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/composites/trees/edl_hierarchy__v/{parent_node_id}/children", configuration.base_path, parent_node_id=crate::apis::urlencode(p_parent_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CompositesTreesEdlHierarchyVParentNodeIdChildrenPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn configuration_component_type_and_record_name_get(configuration: &configuration::Configuration, component_type_and_record_name: &str, loc: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ConfigurationComponentTypeAndRecordNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_component_type_and_record_name = component_type_and_record_name;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/configuration/{component_type_and_record_name}", configuration.base_path, component_type_and_record_name=crate::apis::urlencode(p_component_type_and_record_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationComponentTypeAndRecordNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn configuration_component_type_get(configuration: &configuration::Configuration, component_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ConfigurationComponentTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_component_type = component_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/configuration/{component_type}", configuration.base_path, component_type=crate::apis::urlencode(p_component_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationComponentTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn configuration_object_name_and_object_type_get(configuration: &configuration::Configuration, object_name_and_object_type: &str, loc: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ConfigurationObjectNameAndObjectTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name_and_object_type = object_name_and_object_type;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/configuration/{object_name_and_object_type}", configuration.base_path, object_name_and_object_type=crate::apis::urlencode(p_object_name_and_object_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationObjectNameAndObjectTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn configuration_objecttype_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ConfigurationObjecttypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/configuration/Objecttype", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationObjecttypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn configuration_role_assignment_rule_delete(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ConfigurationRoleAssignmentRuleDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/configuration/role_assignment_rule", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationRoleAssignmentRuleDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn configuration_role_assignment_rule_get(configuration: &configuration::Configuration, lifecycle__v: Option<&str>, role__v: Option<&str>, product__v: Option<&str>, country__v: Option<&str>, study__v: Option<&str>, study_country__v: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ConfigurationRoleAssignmentRuleGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_lifecycle__v = lifecycle__v;
    let p_role__v = role__v;
    let p_product__v = product__v;
    let p_country__v = country__v;
    let p_study__v = study__v;
    let p_study_country__v = study_country__v;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/configuration/role_assignment_rule", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_lifecycle__v {
        req_builder = req_builder.query(&[("lifecycle__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_role__v {
        req_builder = req_builder.query(&[("role__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_product__v {
        req_builder = req_builder.query(&[("product__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_country__v {
        req_builder = req_builder.query(&[("country__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_study__v {
        req_builder = req_builder.query(&[("study__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_study_country__v {
        req_builder = req_builder.query(&[("study_country__v", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationRoleAssignmentRuleGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn configuration_role_assignment_rule_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ConfigurationRoleAssignmentRulePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/configuration/role_assignment_rule", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationRoleAssignmentRulePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn configuration_role_assignment_rule_put(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ConfigurationRoleAssignmentRulePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/configuration/role_assignment_rule", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigurationRoleAssignmentRulePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delegation_login_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<DelegationLoginPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/delegation/login", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DelegationLoginPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delegation_vaults_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<DelegationVaultsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/delegation/vaults", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DelegationVaultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn keep_alive_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<KeepAlivePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/keep-alive", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<KeepAlivePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn limits_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<LimitsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/limits", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LimitsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logs_api_usage_get(configuration: &configuration::Configuration, date: Option<&str>, log_format: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<LogsApiUsageGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_date = date;
    let p_log_format = log_format;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/logs/api_usage", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_log_format {
        req_builder = req_builder.query(&[("log_format", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogsApiUsageGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logs_code_debug_get(configuration: &configuration::Configuration, user_id: Option<&str>, include_inactive: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<LogsCodeDebugGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_include_inactive = include_inactive;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/logs/code/debug", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_user_id {
        req_builder = req_builder.query(&[("user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_inactive {
        req_builder = req_builder.query(&[("include_inactive", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogsCodeDebugGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logs_code_debug_id_actions_reset_delete(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<LogsCodeDebugIdActionsResetDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/logs/code/debug/{id}/actions/reset", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogsCodeDebugIdActionsResetDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logs_code_debug_id_actions_reset_post(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<LogsCodeDebugIdActionsResetPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/logs/code/debug/{id}/actions/reset", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogsCodeDebugIdActionsResetPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logs_code_debug_id_files_get(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<LogsCodeDebugIdFilesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/logs/code/debug/{id}/files", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogsCodeDebugIdFilesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logs_code_debug_id_get(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<LogsCodeDebugIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/logs/code/debug/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogsCodeDebugIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logs_code_debug_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<LogsCodeDebugPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/logs/code/debug", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogsCodeDebugPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn logs_code_runtime_get(configuration: &configuration::Configuration, date: Option<&str>, log_format: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<LogsCodeRuntimeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_date = date;
    let p_log_format = log_format;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/logs/code/runtime", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_date {
        req_builder = req_builder.query(&[("date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_log_format {
        req_builder = req_builder.query(&[("log_format", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogsCodeRuntimeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn messages_message_type_actions_import_post(configuration: &configuration::Configuration, message_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MessagesMessageTypeActionsImportPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_message_type = message_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/messages/{message_type}/actions/import", configuration.base_path, message_type=crate::apis::urlencode(p_message_type));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MessagesMessageTypeActionsImportPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn messages_message_type_language_lang_actions_export_post(configuration: &configuration::Configuration, message_type: &str, lang: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MessagesMessageTypeLanguageLangActionsExportPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_message_type = message_type;
    let p_lang = lang;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/messages/{message_type}/language/{lang}/actions/export", configuration.base_path, message_type=crate::apis::urlencode(p_message_type), lang=crate::apis::urlencode(p_lang));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MessagesMessageTypeLanguageLangActionsExportPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_audittrail_audit_trail_type_get(configuration: &configuration::Configuration, audit_trail_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataAudittrailAuditTrailTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_audit_trail_type = audit_trail_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/audittrail/{audit_trail_type}", configuration.base_path, audit_trail_type=crate::apis::urlencode(p_audit_trail_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataAudittrailAuditTrailTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_audittrail_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataAudittrailGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/audittrail", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataAudittrailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_components_component_type_get(configuration: &configuration::Configuration, component_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataComponentsComponentTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_component_type = component_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/components/{component_type}", configuration.base_path, component_type=crate::apis::urlencode(p_component_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataComponentsComponentTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_components_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataComponentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/components", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataComponentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_binders_templates_bindernodes_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsBindersTemplatesBindernodesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/binders/templates/bindernodes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsBindersTemplatesBindernodesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_binders_templates_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsBindersTemplatesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/binders/templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsBindersTemplatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_annotations_placemarks_types_placemark_type_get(configuration: &configuration::Configuration, placemark_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_placemark_type = placemark_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/annotations/placemarks/types/{placemark_type}", configuration.base_path, placemark_type=crate::apis::urlencode(p_placemark_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_annotations_references_types_reference_type_get(configuration: &configuration::Configuration, reference_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_reference_type = reference_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/annotations/references/types/{reference_type}", configuration.base_path, reference_type=crate::apis::urlencode(p_reference_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_annotations_types_annotation_type_get(configuration: &configuration::Configuration, annotation_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_annotation_type = annotation_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/annotations/types/{annotation_type}", configuration.base_path, annotation_type=crate::apis::urlencode(p_annotation_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_events_event_type_types_event_subtype_get(configuration: &configuration::Configuration, event_type: &str, event_subtype: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_event_type = event_type;
    let p_event_subtype = event_subtype;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/events/{event_type}/types/{event_subtype}", configuration.base_path, event_type=crate::apis::urlencode(p_event_type), event_subtype=crate::apis::urlencode(p_event_subtype));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_events_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsEventsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/events", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsEventsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_lock_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsLockGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/lock", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsLockGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_properties_find_common_post(configuration: &configuration::Configuration, content_type: Option<&str>, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsPropertiesFindCommonPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_content_type = content_type;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/properties/find_common", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsPropertiesFindCommonPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_properties_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsPropertiesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/properties", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsPropertiesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_templates_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsTemplatesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsTemplatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_types_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsTypesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/types", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsTypesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_types_type_get(configuration: &configuration::Configuration, r#type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsTypesTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/types/{type}", configuration.base_path, type=crate::apis::urlencode(p_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsTypesTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_types_type_relationships_get(configuration: &configuration::Configuration, r#type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsTypesTypeRelationshipsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/types/{type}/relationships", configuration.base_path, type=crate::apis::urlencode(p_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsTypesTypeRelationshipsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_types_type_subtypes_subtype_classifications_classification_get(configuration: &configuration::Configuration, r#type: &str, subtype: &str, classification: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_subtype = subtype;
    let p_classification = classification;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/types/{type}/subtypes/{subtype}/classifications/{classification}", configuration.base_path, type=crate::apis::urlencode(p_type), subtype=crate::apis::urlencode(p_subtype), classification=crate::apis::urlencode(p_classification));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_documents_types_type_subtypes_subtype_get(configuration: &configuration::Configuration, r#type: &str, subtype: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_subtype = subtype;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/documents/types/{type}/subtypes/{subtype}", configuration.base_path, type=crate::apis::urlencode(p_type), subtype=crate::apis::urlencode(p_subtype));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_groups_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsGroupsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsGroupsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_securitypolicies_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsSecuritypoliciesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/securitypolicies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsSecuritypoliciesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_objects_users_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataObjectsUsersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/objects/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataObjectsUsersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_query_archived_documents_relationships_document_signature_sysr_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/query/archived_documents/relationships/document_signature__sysr", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_query_documents_relationships_document_signature_sysr_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/query/documents/relationships/document_signature__sysr", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_vobjects_get(configuration: &configuration::Configuration, loc: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataVobjectsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/vobjects", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataVobjectsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_vobjects_object_name_actions_canceldeployment_post(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataVobjectsObjectNameActionsCanceldeploymentPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/vobjects/{object_name}/actions/canceldeployment", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataVobjectsObjectNameActionsCanceldeploymentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_vobjects_object_name_fields_object_field_name_get(configuration: &configuration::Configuration, object_name: &str, object_field_name: &str, loc: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataVobjectsObjectNameFieldsObjectFieldNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_field_name = object_field_name;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/vobjects/{object_name}/fields/{object_field_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_field_name=crate::apis::urlencode(p_object_field_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataVobjectsObjectNameFieldsObjectFieldNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_vobjects_object_name_get(configuration: &configuration::Configuration, object_name: &str, loc: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataVobjectsObjectNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/vobjects/{object_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataVobjectsObjectNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_vobjects_object_name_page_layouts_get(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataVobjectsObjectNamePageLayoutsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/vobjects/{object_name}/page_layouts", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataVobjectsObjectNamePageLayoutsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn metadata_vobjects_object_name_page_layouts_layout_name_get(configuration: &configuration::Configuration, object_name: &str, layout_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<MetadataVobjectsObjectNamePageLayoutsLayoutNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_layout_name = layout_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/metadata/vobjects/{object_name}/page_layouts/{layout_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), layout_name=crate::apis::urlencode(p_layout_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<MetadataVobjectsObjectNamePageLayoutsLayoutNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn notifications_histories_get(configuration: &configuration::Configuration, start_date: Option<&str>, end_date: Option<&str>, all_dates: Option<bool>, format_result: Option<&str>, limit: Option<&str>, offset: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<NotificationsHistoriesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_all_dates = all_dates;
    let p_format_result = format_result;
    let p_limit = limit;
    let p_offset = offset;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/notifications/histories", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_all_dates {
        req_builder = req_builder.query(&[("all_dates", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format_result {
        req_builder = req_builder.query(&[("format_result", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<NotificationsHistoriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_workflow_actions_action_get(configuration: &configuration::Configuration, action: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectWorkflowActionsActionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_action = action;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/object/workflow/actions/{action}", configuration.base_path, action=crate::apis::urlencode(p_action));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectWorkflowActionsActionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_workflow_actions_action_post(configuration: &configuration::Configuration, action: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectWorkflowActionsActionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_action = action;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/object/workflow/actions/{action}", configuration.base_path, action=crate::apis::urlencode(p_action));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectWorkflowActionsActionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_workflow_actions_canceltasks_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectWorkflowActionsCanceltasksPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/object/workflow/actions/canceltasks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectWorkflowActionsCanceltasksPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_workflow_actions_cancelworkflows_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectWorkflowActionsCancelworkflowsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/object/workflow/actions/cancelworkflows", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectWorkflowActionsCancelworkflowsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_workflow_actions_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectWorkflowActionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/object/workflow/actions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectWorkflowActionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_workflow_actions_reassigntasks_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectWorkflowActionsReassigntasksPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/object/workflow/actions/reassigntasks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectWorkflowActionsReassigntasksPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn object_workflow_actions_replaceworkflowowner_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectWorkflowActionsReplaceworkflowownerPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/object/workflow/actions/replaceworkflowowner", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectWorkflowActionsReplaceworkflowownerPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_actions_export_job_id_results_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersActionsExportJobIdResultsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/actions/export/{job_id}/results", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersActionsExportJobIdResultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_actions_export_post(configuration: &configuration::Configuration, binder_id: &str, source: Option<bool>, renditiontype: Option<&str>, docversion: Option<&str>, attachments: Option<&str>, export: Option<&str>, docfield: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdActionsExportPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_source = source;
    let p_renditiontype = renditiontype;
    let p_docversion = docversion;
    let p_attachments = attachments;
    let p_export = export;
    let p_docfield = docfield;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/actions/export", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_source {
        req_builder = req_builder.query(&[("source", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_renditiontype {
        req_builder = req_builder.query(&[("renditiontype", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_docversion {
        req_builder = req_builder.query(&[("docversion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attachments {
        req_builder = req_builder.query(&[("attachments", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_export {
        req_builder = req_builder.query(&[("export", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_docfield {
        req_builder = req_builder.query(&[("docfield", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdActionsExportPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_actions_post(configuration: &configuration::Configuration, binder_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdActionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/actions", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdActionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_binding_rule_put(configuration: &configuration::Configuration, binder_id: &str, content_type: Option<&str>, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdBindingRulePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/binding_rule", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdBindingRulePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_delete(configuration: &configuration::Configuration, binder_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_documents_node_id_binding_rule_put(configuration: &configuration::Configuration, binder_id: &str, node_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_node_id = node_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/documents/{node_id}/binding_rule", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), node_id=crate::apis::urlencode(p_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_documents_post(configuration: &configuration::Configuration, binder_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdDocumentsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/documents", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdDocumentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_documents_section_id_delete(configuration: &configuration::Configuration, binder_id: &str, section_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdDocumentsSectionIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_section_id = section_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/documents/{section_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), section_id=crate::apis::urlencode(p_section_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdDocumentsSectionIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_documents_section_id_put(configuration: &configuration::Configuration, binder_id: &str, section_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdDocumentsSectionIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_section_id = section_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/documents/{section_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), section_id=crate::apis::urlencode(p_section_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdDocumentsSectionIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_get(configuration: &configuration::Configuration, binder_id: &str, depth: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_depth = depth;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_depth {
        req_builder = req_builder.query(&[("depth", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_post(configuration: &configuration::Configuration, binder_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_put(configuration: &configuration::Configuration, binder_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_roles_role_name_and_user_or_group_id_delete(configuration: &configuration::Configuration, binder_id: &str, role_name_and_user_or_group: &str, id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_role_name_and_user_or_group = role_name_and_user_or_group;
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/roles/{role_name_and_user_or_group}/{id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), role_name_and_user_or_group=crate::apis::urlencode(p_role_name_and_user_or_group), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_sections_node_id_binding_rule_put(configuration: &configuration::Configuration, binder_id: &str, node_id: &str, content_type: Option<&str>, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdSectionsNodeIdBindingRulePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_node_id = node_id;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/sections/{node_id}/binding_rule", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), node_id=crate::apis::urlencode(p_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdSectionsNodeIdBindingRulePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_sections_node_id_put(configuration: &configuration::Configuration, binder_id: &str, node_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdSectionsNodeIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_node_id = node_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/sections/{node_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), node_id=crate::apis::urlencode(p_node_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdSectionsNodeIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_sections_post(configuration: &configuration::Configuration, binder_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdSectionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/sections", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdSectionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_sections_section_id_delete(configuration: &configuration::Configuration, binder_id: &str, section_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdSectionsSectionIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_section_id = section_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/sections/{section_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), section_id=crate::apis::urlencode(p_section_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdSectionsSectionIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_sections_section_id_get(configuration: &configuration::Configuration, binder_id: &str, section_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdSectionsSectionIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_section_id = section_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/sections/{section_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), section_id=crate::apis::urlencode(p_section_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdSectionsSectionIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_versions_get(configuration: &configuration::Configuration, binder_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdVersionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/versions", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdVersionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_versions_major_version_minor_version_actions_export_post(configuration: &configuration::Configuration, binder_id: &str, major_version: &str, minor_version: &str, source: Option<bool>, renditiontype: Option<&str>, docversion: Option<&str>, attachments: Option<&str>, export: Option<&str>, docfield: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_source = source;
    let p_renditiontype = renditiontype;
    let p_docversion = docversion;
    let p_attachments = attachments;
    let p_export = export;
    let p_docfield = docfield;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_source {
        req_builder = req_builder.query(&[("source", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_renditiontype {
        req_builder = req_builder.query(&[("renditiontype", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_docversion {
        req_builder = req_builder.query(&[("docversion", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attachments {
        req_builder = req_builder.query(&[("attachments", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_export {
        req_builder = req_builder.query(&[("export", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_docfield {
        req_builder = req_builder.query(&[("docfield", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_versions_major_version_minor_version_delete(configuration: &configuration::Configuration, binder_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_versions_major_version_minor_version_get(configuration: &configuration::Configuration, binder_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_versions_major_version_minor_version_put(configuration: &configuration::Configuration, binder_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_versions_major_version_minor_version_relationships_post(configuration: &configuration::Configuration, binder_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_versions_major_version_minor_version_relationships_relationship_id_delete(configuration: &configuration::Configuration, binder_id: &str, major_version: &str, minor_version: &str, relationship_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_relationship_id = relationship_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), relationship_id=crate::apis::urlencode(p_relationship_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_versions_major_version_minor_version_relationships_relationship_id_get(configuration: &configuration::Configuration, binder_id: &str, major_version: &str, minor_version: &str, relationship_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_relationship_id = relationship_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), relationship_id=crate::apis::urlencode(p_relationship_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_binder_id_versions_major_version_minor_version_sections_section_id_get(configuration: &configuration::Configuration, binder_id: &str, major_version: &str, minor_version: &str, section_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_binder_id = binder_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_section_id = section_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/sections/{section_id}", configuration.base_path, binder_id=crate::apis::urlencode(p_binder_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), section_id=crate::apis::urlencode(p_section_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_id_roles_get(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersIdRolesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{id}/roles", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersIdRolesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_id_roles_post(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersIdRolesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{id}/roles", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersIdRolesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_id_roles_role_name_get(configuration: &configuration::Configuration, id: &str, role_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersIdRolesRoleNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_role_name = role_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{id}/roles/{role_name}", configuration.base_path, id=crate::apis::urlencode(p_id), role_name=crate::apis::urlencode(p_role_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersIdRolesRoleNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_id_versions_major_version_minor_version_lifecycle_actions_get(configuration: &configuration::Configuration, id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions", configuration.base_path, id=crate::apis::urlencode(p_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_id_versions_major_version_minor_version_lifecycle_actions_name_v_entry_requirements_get(configuration: &configuration::Configuration, id: &str, major_version: &str, minor_version: &str, name__v: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_name__v = name__v;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements", configuration.base_path, id=crate::apis::urlencode(p_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), name__v=crate::apis::urlencode(p_name__v));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_id_versions_major_version_minor_version_lifecycle_actions_name_v_put(configuration: &configuration::Configuration, id: &str, major_version: &str, minor_version: &str, name__v: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_name__v = name__v;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}", configuration.base_path, id=crate::apis::urlencode(p_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), name__v=crate::apis::urlencode(p_name__v));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_lifecycle_actions_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersLifecycleActionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/lifecycle_actions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersLifecycleActionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_lifecycle_actions_user_action_name_put(configuration: &configuration::Configuration, user_action_name: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersLifecycleActionsUserActionNamePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_action_name = user_action_name;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/lifecycle_actions/{user_action_name}", configuration.base_path, user_action_name=crate::apis::urlencode(p_user_action_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersLifecycleActionsUserActionNamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_post(configuration: &configuration::Configuration, r#async: Option<bool>, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_async = r#async;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_async {
        req_builder = req_builder.query(&[("async", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_templates_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersTemplatesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersTemplatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_templates_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersTemplatesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersTemplatesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_templates_put(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersTemplatesPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersTemplatesPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_templates_template_name_bindernodes_get(configuration: &configuration::Configuration, template_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersTemplatesTemplateNameBindernodesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_template_name = template_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/templates/{template_name}/bindernodes", configuration.base_path, template_name=crate::apis::urlencode(p_template_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersTemplatesTemplateNameBindernodesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_templates_template_name_bindernodes_post(configuration: &configuration::Configuration, template_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersTemplatesTemplateNameBindernodesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_template_name = template_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/templates/{template_name}/bindernodes", configuration.base_path, template_name=crate::apis::urlencode(p_template_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersTemplatesTemplateNameBindernodesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_templates_template_name_bindernodes_put(configuration: &configuration::Configuration, template_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersTemplatesTemplateNameBindernodesPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_template_name = template_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/templates/{template_name}/bindernodes", configuration.base_path, template_name=crate::apis::urlencode(p_template_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersTemplatesTemplateNameBindernodesPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_templates_template_name_delete(configuration: &configuration::Configuration, template_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersTemplatesTemplateNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_template_name = template_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/templates/{template_name}", configuration.base_path, template_name=crate::apis::urlencode(p_template_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersTemplatesTemplateNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_binders_templates_template_name_get(configuration: &configuration::Configuration, template_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsBindersTemplatesTemplateNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_template_name = template_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/binders/templates/{template_name}", configuration.base_path, template_name=crate::apis::urlencode(p_template_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsBindersTemplatesTemplateNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_deletions_documents_get(configuration: &configuration::Configuration, start_date: Option<&str>, end_date: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDeletionsDocumentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/deletions/documents", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDeletionsDocumentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_deletions_vobjects_object_name_get(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDeletionsVobjectsObjectNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/deletions/vobjects/{object_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDeletionsVobjectsObjectNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_actions_get(configuration: &configuration::Configuration, loc: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsActionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/actions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsActionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_actions_lifecycle_and_state_and_action_job_id_results_get(configuration: &configuration::Configuration, lifecycle_and_state_and_action: &str, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_lifecycle_and_state_and_action = lifecycle_and_state_and_action;
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/actions/{lifecycle_and_state_and_action}/{job_id}/results", configuration.base_path, lifecycle_and_state_and_action=crate::apis::urlencode(p_lifecycle_and_state_and_action), job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_actions_workflow_name_get(configuration: &configuration::Configuration, workflow_name: &str, loc: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsActionsWorkflowNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow_name = workflow_name;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/actions/{workflow_name}", configuration.base_path, workflow_name=crate::apis::urlencode(p_workflow_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsActionsWorkflowNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_actions_workflow_name_post(configuration: &configuration::Configuration, workflow_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsActionsWorkflowNamePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow_name = workflow_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/actions/{workflow_name}", configuration.base_path, workflow_name=crate::apis::urlencode(p_workflow_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsActionsWorkflowNamePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_annotations_batch_delete(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsAnnotationsBatchDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/annotations/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsAnnotationsBatchDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_annotations_batch_post(configuration: &configuration::Configuration, authorization: &str, content_type: &str, accept: &str, x_vault_api_client_id: &str) -> Result<(), Error<ObjectsDocumentsAnnotationsBatchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/annotations/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("Authorization", p_authorization.to_string());
    req_builder = req_builder.header("Content-Type", p_content_type.to_string());
    req_builder = req_builder.header("Accept", p_accept.to_string());
    req_builder = req_builder.header("X-VaultAPI-ClientID", p_x_vault_api_client_id.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsAnnotationsBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_annotations_batch_put(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsAnnotationsBatchPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/annotations/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsAnnotationsBatchPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_annotations_replies_batch_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsAnnotationsRepliesBatchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/annotations/replies/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsAnnotationsRepliesBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_attachments_batch_delete(configuration: &configuration::Configuration, accept: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsAttachmentsBatchDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept = accept;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/attachments/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsAttachmentsBatchDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_attachments_batch_post(configuration: &configuration::Configuration, accept: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsAttachmentsBatchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept = accept;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/attachments/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsAttachmentsBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_attachments_batch_put(configuration: &configuration::Configuration, accept: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsAttachmentsBatchPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept = accept;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/attachments/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsAttachmentsBatchPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_batch_actions_fileextract_job_id_results_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsBatchActionsFileextractJobIdResultsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/batch/actions/fileextract/{job_id}/results", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsBatchActionsFileextractJobIdResultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_batch_actions_fileextract_post(configuration: &configuration::Configuration, source: Option<bool>, renditions: Option<bool>, allversions: Option<bool>, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsBatchActionsFileextractPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_source = source;
    let p_renditions = renditions;
    let p_allversions = allversions;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/batch/actions/fileextract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_source {
        req_builder = req_builder.query(&[("source", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_renditions {
        req_builder = req_builder.query(&[("renditions", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_allversions {
        req_builder = req_builder.query(&[("allversions", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsBatchActionsFileextractPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_batch_actions_reclassify_put(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_migration_mode: Option<bool>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsBatchActionsReclassifyPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/batch/actions/reclassify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsBatchActionsReclassifyPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_batch_actions_rerender_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsBatchActionsRerenderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/batch/actions/rerender", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsBatchActionsRerenderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_batch_delete(configuration: &configuration::Configuration, id_param: Option<&str>, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsBatchDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id_param = id_param;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_id_param {
        req_builder = req_builder.query(&[("idParam", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsBatchDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_batch_lock_delete(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsBatchLockDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/batch/lock", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsBatchLockDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_batch_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_migration_mode: Option<bool>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsBatchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_batch_put(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_migration_mode: Option<bool>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsBatchPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsBatchPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_anchors_get(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAnchorsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/anchors", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAnchorsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_annotations_file_get(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAnnotationsFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/annotations/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAnnotationsFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_annotations_file_post(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAnnotationsFilePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/annotations/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAnnotationsFilePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_attachment_id_delete(configuration: &configuration::Configuration, doc_id: &str, attachment_id: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_attachment_id = attachment_id;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/{attachment_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), attachment_id=crate::apis::urlencode(p_attachment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_attachment_id_file_get(configuration: &configuration::Configuration, doc_id: &str, attachment_id: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_attachment_id = attachment_id;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/{attachment_id}/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), attachment_id=crate::apis::urlencode(p_attachment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_attachment_id_get(configuration: &configuration::Configuration, doc_id: &str, attachment_id: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsAttachmentIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_attachment_id = attachment_id;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/{attachment_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), attachment_id=crate::apis::urlencode(p_attachment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsAttachmentIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_attachment_id_put(configuration: &configuration::Configuration, doc_id: &str, attachment_id: &str, accept: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsAttachmentIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_attachment_id = attachment_id;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/{attachment_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), attachment_id=crate::apis::urlencode(p_attachment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsAttachmentIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_delete(configuration: &configuration::Configuration, doc_id: &str, attachment_id: &str, attachment_version: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_file_get(configuration: &configuration::Configuration, doc_id: &str, attachment_id: &str, attachment_version: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_get(configuration: &configuration::Configuration, doc_id: &str, attachment_id: &str, attachment_version: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_post(configuration: &configuration::Configuration, doc_id: &str, attachment_id: &str, attachment_version: &str, restore: Option<bool>, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_restore = restore;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_restore {
        req_builder = req_builder.query(&[("restore", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_attachment_id_versions_get(configuration: &configuration::Configuration, doc_id: &str, attachment_id: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_attachment_id = attachment_id;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/{attachment_id}/versions", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), attachment_id=crate::apis::urlencode(p_attachment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_file_get(configuration: &configuration::Configuration, doc_id: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_get(configuration: &configuration::Configuration, doc_id: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_attachments_post(configuration: &configuration::Configuration, doc_id: &str, accept: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAttachmentsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/attachments", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAttachmentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_audittrail_get(configuration: &configuration::Configuration, doc_id: &str, start_date: Option<&str>, end_date: Option<&str>, format_result: Option<&str>, limit: Option<&str>, offset: Option<&str>, events: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdAudittrailGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_format_result = format_result;
    let p_limit = limit;
    let p_offset = offset;
    let p_events = events;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/audittrail", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format_result {
        req_builder = req_builder.query(&[("format_result", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_events {
        req_builder = req_builder.query(&[("events", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdAudittrailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_delete(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_events_get(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdEventsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/events", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdEventsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_file_get(configuration: &configuration::Configuration, doc_id: &str, lock_document: Option<bool>, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_lock_document = lock_document;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_lock_document {
        req_builder = req_builder.query(&[("lockDocument", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_get(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_lock_delete(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdLockDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/lock", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdLockDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_lock_get(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdLockGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/lock", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdLockGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_lock_post(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdLockPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/lock", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdLockPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_major_version_minor_version_attachments_file_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/{major_version}/{minor_version}/attachments/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_post(configuration: &configuration::Configuration, doc_id: &str, suppress_rendition: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_suppress_rendition = suppress_rendition;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_suppress_rendition {
        req_builder = req_builder.query(&[("suppressRendition", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_put(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_migration_mode: Option<bool>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_renditions_get(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdRenditionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/renditions", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdRenditionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_renditions_rendition_type_delete(configuration: &configuration::Configuration, doc_id: &str, rendition_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_rendition_type = rendition_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/renditions/{rendition_type}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), rendition_type=crate::apis::urlencode(p_rendition_type));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_renditions_rendition_type_get(configuration: &configuration::Configuration, doc_id: &str, rendition_type: &str, steady_state: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdRenditionsRenditionTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_rendition_type = rendition_type;
    let p_steady_state = steady_state;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/renditions/{rendition_type}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), rendition_type=crate::apis::urlencode(p_rendition_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_steady_state {
        req_builder = req_builder.query(&[("steadyState", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdRenditionsRenditionTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_renditions_rendition_type_post(configuration: &configuration::Configuration, doc_id: &str, rendition_type: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdRenditionsRenditionTypePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_rendition_type = rendition_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/renditions/{rendition_type}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), rendition_type=crate::apis::urlencode(p_rendition_type));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdRenditionsRenditionTypePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_renditions_rendition_type_put(configuration: &configuration::Configuration, doc_id: &str, rendition_type: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdRenditionsRenditionTypePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_rendition_type = rendition_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/renditions/{rendition_type}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), rendition_type=crate::apis::urlencode(p_rendition_type));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdRenditionsRenditionTypePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_roles_role_name_and_user_or_group_id_delete(configuration: &configuration::Configuration, doc_id: &str, role_name_and_user_or_group: &str, id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_role_name_and_user_or_group = role_name_and_user_or_group;
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/roles/{role_name_and_user_or_group}/{id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), role_name_and_user_or_group=crate::apis::urlencode(p_role_name_and_user_or_group), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_version_major_version_minor_version_attachments_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/version/{major_version}/{minor_version}/attachments", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_get(configuration: &configuration::Configuration, doc_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_annotations_annotation_id_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, annotation_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_annotation_id = annotation_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), annotation_id=crate::apis::urlencode(p_annotation_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_annotations_annotation_id_replies_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, annotation_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_annotation_id = annotation_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}/replies", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), annotation_id=crate::apis::urlencode(p_annotation_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_annotations_file_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_annotations_file_post(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_annotations_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, limit: Option<&str>, offset: Option<&str>, annotation_types: Option<&str>, pagination_id: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_limit = limit;
    let p_offset = offset;
    let p_annotation_types = annotation_types;
    let p_pagination_id = pagination_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_annotation_types {
        req_builder = req_builder.query(&[("annotation_types", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pagination_id {
        req_builder = req_builder.query(&[("pagination_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_attachments_attachment_id_versions_attachment_version_file_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, attachment_id: &str, attachment_version: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_attachments_attachment_id_versions_attachment_version_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, attachment_id: &str, attachment_version: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_delete(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_doc_export_annotations_to_csv_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/doc-export-annotations-to-csv", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_events_post(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/events", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_export_video_annotations_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/export-video-annotations", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_file_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/file", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_put(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_migration_mode: Option<bool>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_relationships_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_relationships_post(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_relationships_relationship_id_delete(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, relationship_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_relationship_id = relationship_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), relationship_id=crate::apis::urlencode(p_relationship_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_relationships_relationship_id_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, relationship_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_relationship_id = relationship_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), relationship_id=crate::apis::urlencode(p_relationship_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_renditions_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_delete(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, rendition_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_rendition_type = rendition_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), rendition_type=crate::apis::urlencode(p_rendition_type));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, rendition_type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_rendition_type = rendition_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), rendition_type=crate::apis::urlencode(p_rendition_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_post(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, rendition_type: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_rendition_type = rendition_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), rendition_type=crate::apis::urlencode(p_rendition_type));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_put(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, rendition_type: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_rendition_type = rendition_type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), rendition_type=crate::apis::urlencode(p_rendition_type));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_doc_id_versions_major_version_minor_version_thumbnail_get(configuration: &configuration::Configuration, doc_id: &str, major_version: &str, minor_version: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_doc_id = doc_id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/thumbnail", configuration.base_path, doc_id=crate::apis::urlencode(p_doc_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_get(configuration: &configuration::Configuration, named_filter: Option<&str>, scope: Option<&str>, versionscope: Option<&str>, search: Option<&str>, limit: Option<&str>, sort: Option<&str>, start: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_named_filter = named_filter;
    let p_scope = scope;
    let p_versionscope = versionscope;
    let p_search = search;
    let p_limit = limit;
    let p_sort = sort;
    let p_start = start;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_named_filter {
        req_builder = req_builder.query(&[("named_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_scope {
        req_builder = req_builder.query(&[("scope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_versionscope {
        req_builder = req_builder.query(&[("versionscope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort {
        req_builder = req_builder.query(&[("sort", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_id_roles_get(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsIdRolesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{id}/roles", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsIdRolesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_id_roles_post(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsIdRolesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{id}/roles", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsIdRolesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_id_roles_role_name_get(configuration: &configuration::Configuration, id: &str, role_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsIdRolesRoleNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_role_name = role_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{id}/roles/{role_name}", configuration.base_path, id=crate::apis::urlencode(p_id), role_name=crate::apis::urlencode(p_role_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsIdRolesRoleNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_id_versions_major_version_minor_version_lifecycle_actions_get(configuration: &configuration::Configuration, id: &str, major_version: &str, minor_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions", configuration.base_path, id=crate::apis::urlencode(p_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_id_versions_major_version_minor_version_lifecycle_actions_name_v_entry_requirements_get(configuration: &configuration::Configuration, id: &str, major_version: &str, minor_version: &str, name__v: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_name__v = name__v;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements", configuration.base_path, id=crate::apis::urlencode(p_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), name__v=crate::apis::urlencode(p_name__v));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_id_versions_major_version_minor_version_lifecycle_actions_name_v_put(configuration: &configuration::Configuration, id: &str, major_version: &str, minor_version: &str, name__v: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_major_version = major_version;
    let p_minor_version = minor_version;
    let p_name__v = name__v;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}", configuration.base_path, id=crate::apis::urlencode(p_id), major_version=crate::apis::urlencode(p_major_version), minor_version=crate::apis::urlencode(p_minor_version), name__v=crate::apis::urlencode(p_name__v));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_lifecycle_actions_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsLifecycleActionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/lifecycle_actions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsLifecycleActionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_lifecycle_actions_user_action_name_put(configuration: &configuration::Configuration, user_action_name: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsLifecycleActionsUserActionNamePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_action_name = user_action_name;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/lifecycle_actions/{user_action_name}", configuration.base_path, user_action_name=crate::apis::urlencode(p_user_action_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsLifecycleActionsUserActionNamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_migration_mode: Option<bool>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_relationships_batch_delete(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsRelationshipsBatchDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/relationships/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsRelationshipsBatchDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_relationships_batch_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsRelationshipsBatchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/relationships/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsRelationshipsBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_renditions_batch_delete(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsRenditionsBatchDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/renditions/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsRenditionsBatchDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_renditions_batch_post(configuration: &configuration::Configuration, id_param: Option<&str>, large_size_asset: Option<&str>, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_migration_mode: Option<bool>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsRenditionsBatchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id_param = id_param;
    let p_large_size_asset = large_size_asset;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/renditions/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_id_param {
        req_builder = req_builder.query(&[("idParam", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_large_size_asset {
        req_builder = req_builder.query(&[("largeSizeAsset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsRenditionsBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_roles_batch_delete(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsRolesBatchDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/roles/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsRolesBatchDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_roles_batch_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsRolesBatchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/roles/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsRolesBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_templates_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsTemplatesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsTemplatesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_templates_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsTemplatesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsTemplatesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_templates_put(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsTemplatesPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/templates", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsTemplatesPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_templates_template_name_delete(configuration: &configuration::Configuration, template_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsTemplatesTemplateNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_template_name = template_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/templates/{template_name}", configuration.base_path, template_name=crate::apis::urlencode(p_template_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsTemplatesTemplateNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_templates_template_name_file_get(configuration: &configuration::Configuration, template_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsTemplatesTemplateNameFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_template_name = template_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/templates/{template_name}/file", configuration.base_path, template_name=crate::apis::urlencode(p_template_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsTemplatesTemplateNameFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_templates_template_name_get(configuration: &configuration::Configuration, template_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsTemplatesTemplateNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_template_name = template_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/templates/{template_name}", configuration.base_path, template_name=crate::apis::urlencode(p_template_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsTemplatesTemplateNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_templates_template_name_put(configuration: &configuration::Configuration, template_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsTemplatesTemplateNamePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_template_name = template_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/templates/{template_name}", configuration.base_path, template_name=crate::apis::urlencode(p_template_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsTemplatesTemplateNamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_tokens_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsTokensPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/tokens", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsTokensPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_versions_batch_actions_fileextract_post(configuration: &configuration::Configuration, source: Option<bool>, renditions: Option<bool>, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsVersionsBatchActionsFileextractPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_source = source;
    let p_renditions = renditions;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/versions/batch/actions/fileextract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_source {
        req_builder = req_builder.query(&[("source", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_renditions {
        req_builder = req_builder.query(&[("renditions", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsVersionsBatchActionsFileextractPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_versions_batch_delete(configuration: &configuration::Configuration, id_param: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsVersionsBatchDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id_param = id_param;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/versions/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_id_param {
        req_builder = req_builder.query(&[("idParam", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsVersionsBatchDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_documents_versions_batch_post(configuration: &configuration::Configuration, id_param: Option<&str>, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_migration_mode: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDocumentsVersionsBatchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id_param = id_param;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/documents/versions/batch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_id_param {
        req_builder = req_builder.query(&[("idParam", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDocumentsVersionsBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_domain_get(configuration: &configuration::Configuration, include_application: Option<bool>, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDomainGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_include_application = include_application;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/domain", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_application {
        req_builder = req_builder.query(&[("include_application", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDomainGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_domains_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsDomainsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/domains", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsDomainsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_edl_matched_documents_batch_actions_add_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsEdlMatchedDocumentsBatchActionsAddPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/edl_matched_documents/batch/actions/add", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsEdlMatchedDocumentsBatchActionsAddPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_edl_matched_documents_batch_actions_remove_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsEdlMatchedDocumentsBatchActionsRemovePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/edl_matched_documents/batch/actions/remove", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsEdlMatchedDocumentsBatchActionsRemovePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_groups_auto_get(configuration: &configuration::Configuration, limit: Option<&str>, offset: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsGroupsAutoGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_limit = limit;
    let p_offset = offset;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/groups/auto", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsGroupsAutoGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_groups_get(configuration: &configuration::Configuration, include_implied: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsGroupsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_include_implied = include_implied;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_implied {
        req_builder = req_builder.query(&[("includeImplied", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsGroupsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_groups_group_id_delete(configuration: &configuration::Configuration, group_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsGroupsGroupIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_group_id = group_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/groups/{group_id}", configuration.base_path, group_id=crate::apis::urlencode(p_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsGroupsGroupIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_groups_group_id_get(configuration: &configuration::Configuration, group_id: &str, include_implied: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsGroupsGroupIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_group_id = group_id;
    let p_include_implied = include_implied;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/groups/{group_id}", configuration.base_path, group_id=crate::apis::urlencode(p_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_include_implied {
        req_builder = req_builder.query(&[("includeImplied", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsGroupsGroupIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_groups_group_id_put(configuration: &configuration::Configuration, group_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsGroupsGroupIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_group_id = group_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/groups/{group_id}", configuration.base_path, group_id=crate::apis::urlencode(p_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsGroupsGroupIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_groups_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsGroupsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/groups", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsGroupsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_licenses_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsLicensesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/licenses", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsLicensesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_actions_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsActionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/actions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsActionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_actions_workflow_name_get(configuration: &configuration::Configuration, workflow_name: &str, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsActionsWorkflowNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow_name = workflow_name;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/actions/{workflow_name}", configuration.base_path, workflow_name=crate::apis::urlencode(p_workflow_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsActionsWorkflowNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_actions_workflow_name_post(configuration: &configuration::Configuration, workflow_name: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsActionsWorkflowNamePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow_name = workflow_name;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/actions/{workflow_name}", configuration.base_path, workflow_name=crate::apis::urlencode(p_workflow_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsActionsWorkflowNamePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_get(configuration: &configuration::Configuration, object__v: Option<&str>, record_id__v: Option<&str>, participant: Option<&str>, status__v: Option<&str>, offset: Option<&str>, page_size: Option<&str>, loc: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object__v = object__v;
    let p_record_id__v = record_id__v;
    let p_participant = participant;
    let p_status__v = status__v;
    let p_offset = offset;
    let p_page_size = page_size;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_object__v {
        req_builder = req_builder.query(&[("object__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_record_id__v {
        req_builder = req_builder.query(&[("record_id__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_participant {
        req_builder = req_builder.query(&[("participant", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status__v {
        req_builder = req_builder.query(&[("status__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_get(configuration: &configuration::Configuration, object__v: Option<&str>, record_id__v: Option<&str>, assignee__v: Option<&str>, status__v: Option<&str>, offset: Option<&str>, page_size: Option<&str>, loc: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object__v = object__v;
    let p_record_id__v = record_id__v;
    let p_assignee__v = assignee__v;
    let p_status__v = status__v;
    let p_offset = offset;
    let p_page_size = page_size;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_object__v {
        req_builder = req_builder.query(&[("object__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_record_id__v {
        req_builder = req_builder.query(&[("record_id__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_assignee__v {
        req_builder = req_builder.query(&[("assignee__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status__v {
        req_builder = req_builder.query(&[("status__v", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_accept_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/accept", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_cancel_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsCancelPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/cancel", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_complete_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsCompletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/complete", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_get(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_mdwaccept_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/mdwaccept", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_mdwcomplete_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/mdwcomplete", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_mdwmanagecontent_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/mdwmanagecontent", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_mdwreassign_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/mdwreassign", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_reassign_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsReassignPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/reassign", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsReassignPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_task_action_get(configuration: &configuration::Configuration, task_id: &str, task_action: &str, loc: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_task_action = task_action;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/{task_action}", configuration.base_path, task_id=crate::apis::urlencode(p_task_id), task_action=crate::apis::urlencode(p_task_action));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_undoaccept_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/undoaccept", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_actions_updateduedate_post(configuration: &configuration::Configuration, task_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}/actions/updateduedate", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_tasks_task_id_get(configuration: &configuration::Configuration, task_id: &str, loc: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsTasksTaskIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_task_id = task_id;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/tasks/{task_id}", configuration.base_path, task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsTasksTaskIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_workflow_id_actions_get(configuration: &configuration::Configuration, workflow_id: &str, loc: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsWorkflowIdActionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow_id = workflow_id;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/{workflow_id}/actions", configuration.base_path, workflow_id=crate::apis::urlencode(p_workflow_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsWorkflowIdActionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_workflow_id_actions_workflow_action_get(configuration: &configuration::Configuration, workflow_id: &str, workflow_action: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow_id = workflow_id;
    let p_workflow_action = workflow_action;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/{workflow_id}/actions/{workflow_action}", configuration.base_path, workflow_id=crate::apis::urlencode(p_workflow_id), workflow_action=crate::apis::urlencode(p_workflow_action));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_workflow_id_actions_workflow_action_post(configuration: &configuration::Configuration, workflow_id: &str, workflow_action: &str, documents__sys: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow_id = workflow_id;
    let p_workflow_action = workflow_action;
    let p_documents__sys = documents__sys;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/{workflow_id}/actions/{workflow_action}", configuration.base_path, workflow_id=crate::apis::urlencode(p_workflow_id), workflow_action=crate::apis::urlencode(p_workflow_action));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_documents__sys {
        req_builder = req_builder.query(&[("documents__sys", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_objectworkflows_workflow_id_get(configuration: &configuration::Configuration, workflow_id: &str, loc: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsObjectworkflowsWorkflowIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_workflow_id = workflow_id;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/objectworkflows/{workflow_id}", configuration.base_path, workflow_id=crate::apis::urlencode(p_workflow_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsObjectworkflowsWorkflowIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_picklists_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsPicklistsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/picklists", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsPicklistsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_picklists_picklist_name_get(configuration: &configuration::Configuration, picklist_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsPicklistsPicklistNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_picklist_name = picklist_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/picklists/{picklist_name}", configuration.base_path, picklist_name=crate::apis::urlencode(p_picklist_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsPicklistsPicklistNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_picklists_picklist_name_picklist_value_name_delete(configuration: &configuration::Configuration, picklist_name: &str, picklist_value_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsPicklistsPicklistNamePicklistValueNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_picklist_name = picklist_name;
    let p_picklist_value_name = picklist_value_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/picklists/{picklist_name}/{picklist_value_name}", configuration.base_path, picklist_name=crate::apis::urlencode(p_picklist_name), picklist_value_name=crate::apis::urlencode(p_picklist_value_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsPicklistsPicklistNamePicklistValueNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_picklists_picklist_name_picklist_value_name_put(configuration: &configuration::Configuration, picklist_name: &str, picklist_value_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsPicklistsPicklistNamePicklistValueNamePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_picklist_name = picklist_name;
    let p_picklist_value_name = picklist_value_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/picklists/{picklist_name}/{picklist_value_name}", configuration.base_path, picklist_name=crate::apis::urlencode(p_picklist_name), picklist_value_name=crate::apis::urlencode(p_picklist_value_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsPicklistsPicklistNamePicklistValueNamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_picklists_picklist_name_post(configuration: &configuration::Configuration, picklist_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsPicklistsPicklistNamePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_picklist_name = picklist_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/picklists/{picklist_name}", configuration.base_path, picklist_name=crate::apis::urlencode(p_picklist_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsPicklistsPicklistNamePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_picklists_picklist_name_put(configuration: &configuration::Configuration, picklist_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsPicklistsPicklistNamePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_picklist_name = picklist_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/picklists/{picklist_name}", configuration.base_path, picklist_name=crate::apis::urlencode(p_picklist_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsPicklistsPicklistNamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_actions_buildproduction_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxActionsBuildproductionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/actions/buildproduction", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxActionsBuildproductionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_actions_promoteproduction_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxActionsPromoteproductionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/actions/promoteproduction", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxActionsPromoteproductionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_actions_recheckusage_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxActionsRecheckusagePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/actions/recheckusage", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxActionsRecheckusagePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_batch_changesize_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxBatchChangesizePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/batch/changesize", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxBatchChangesizePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_entitlements_set_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxEntitlementsSetPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/entitlements/set", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxEntitlementsSetPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_name_delete(configuration: &configuration::Configuration, name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/{name}", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_snapshot_api_name_actions_update_post(configuration: &configuration::Configuration, api_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxSnapshotApiNameActionsUpdatePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_name = api_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/snapshot/{api_name}/actions/update", configuration.base_path, api_name=crate::apis::urlencode(p_api_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxSnapshotApiNameActionsUpdatePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_snapshot_api_name_actions_upgrade_post(configuration: &configuration::Configuration, api_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxSnapshotApiNameActionsUpgradePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_name = api_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/snapshot/{api_name}/actions/upgrade", configuration.base_path, api_name=crate::apis::urlencode(p_api_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxSnapshotApiNameActionsUpgradePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_snapshot_api_name_delete(configuration: &configuration::Configuration, api_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxSnapshotApiNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_api_name = api_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/snapshot/{api_name}", configuration.base_path, api_name=crate::apis::urlencode(p_api_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxSnapshotApiNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_snapshot_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxSnapshotGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/snapshot", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxSnapshotGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_snapshot_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxSnapshotPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/snapshot", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxSnapshotPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_vault_id_actions_refresh_post(configuration: &configuration::Configuration, vault_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxVaultIdActionsRefreshPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_vault_id = vault_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/{vault_id}/actions/refresh", configuration.base_path, vault_id=crate::apis::urlencode(p_vault_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxVaultIdActionsRefreshPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_sandbox_vault_id_get(configuration: &configuration::Configuration, vault_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSandboxVaultIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_vault_id = vault_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/sandbox/{vault_id}", configuration.base_path, vault_id=crate::apis::urlencode(p_vault_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSandboxVaultIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_securitypolicies_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSecuritypoliciesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/securitypolicies", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSecuritypoliciesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_securitypolicies_security_policy_name_get(configuration: &configuration::Configuration, security_policy_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsSecuritypoliciesSecurityPolicyNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_security_policy_name = security_policy_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/securitypolicies/{security_policy_name}", configuration.base_path, security_policy_name=crate::apis::urlencode(p_security_policy_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsSecuritypoliciesSecurityPolicyNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_get(configuration: &configuration::Configuration, vaults: Option<&str>, exclude_vault_membership: Option<&str>, exclude_app_licensing: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_vaults = vaults;
    let p_exclude_vault_membership = exclude_vault_membership;
    let p_exclude_app_licensing = exclude_app_licensing;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_vaults {
        req_builder = req_builder.query(&[("vaults", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude_vault_membership {
        req_builder = req_builder.query(&[("exclude_vault_membership", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude_app_licensing {
        req_builder = req_builder.query(&[("exclude_app_licensing", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_id_get(configuration: &configuration::Configuration, id: &str, exclude_vault_membership: Option<&str>, exclude_app_licensing: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_exclude_vault_membership = exclude_vault_membership;
    let p_exclude_app_licensing = exclude_app_licensing;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_exclude_vault_membership {
        req_builder = req_builder.query(&[("exclude_vault_membership", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude_app_licensing {
        req_builder = req_builder.query(&[("exclude_app_licensing", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_id_permissions_get(configuration: &configuration::Configuration, id: &str, filter: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersIdPermissionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_filter = filter;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/{id}/permissions", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersIdPermissionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_id_put(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_me_get(configuration: &configuration::Configuration, exclude_vault_membership: Option<&str>, exclude_app_licensing: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersMeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_exclude_vault_membership = exclude_vault_membership;
    let p_exclude_app_licensing = exclude_app_licensing;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_exclude_vault_membership {
        req_builder = req_builder.query(&[("exclude_vault_membership", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_exclude_app_licensing {
        req_builder = req_builder.query(&[("exclude_app_licensing", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersMeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_me_password_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersMePasswordPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/me/password", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersMePasswordPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_me_permissions_get(configuration: &configuration::Configuration, filter: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersMePermissionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_filter = filter;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/me/permissions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersMePermissionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_me_put(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersMePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersMePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_put(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_user_id_delete(configuration: &configuration::Configuration, user_id: &str, domain: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersUserIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_domain = domain;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/{user_id}", configuration.base_path, user_id=crate::apis::urlencode(p_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_domain {
        req_builder = req_builder.query(&[("domain", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersUserIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_users_user_id_vault_membership_vault_id_put(configuration: &configuration::Configuration, user_id: &str, vault_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsUsersUserIdVaultMembershipVaultIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_id = user_id;
    let p_vault_id = vault_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/users/{user_id}/vault_membership/{vault_id}", configuration.base_path, user_id=crate::apis::urlencode(p_user_id), vault_id=crate::apis::urlencode(p_vault_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsUsersUserIdVaultMembershipVaultIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_vault_actions_compare_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsVaultActionsComparePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/vault/actions/compare", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsVaultActionsComparePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn objects_vault_actions_configreport_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ObjectsVaultActionsConfigreportPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/objects/vault/actions/configreport", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ObjectsVaultActionsConfigreportPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn query_components_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<QueryComponentsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/query/components", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryComponentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn query_next_page_post(configuration: &configuration::Configuration, next_page: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_describe_query: Option<bool>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<QueryNextPagePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_next_page = next_page;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_describe_query = x_vault_api_describe_query;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/query/{next_page}", configuration.base_path, next_page=crate::apis::urlencode(p_next_page));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_describe_query {
        req_builder = req_builder.header("X-VaultAPI-DescribeQuery", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryNextPagePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn query_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_describe_query: Option<bool>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<QueryPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_describe_query = x_vault_api_describe_query;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/query", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_describe_query {
        req_builder = req_builder.header("X-VaultAPI-DescribeQuery", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn query_previous_page_post(configuration: &configuration::Configuration, previous_page: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_describe_query: Option<bool>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<QueryPreviousPagePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_previous_page = previous_page;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_describe_query = x_vault_api_describe_query;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/query/{previous_page}", configuration.base_path, previous_page=crate::apis::urlencode(p_previous_page));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_describe_query {
        req_builder = req_builder.header("X-VaultAPI-DescribeQuery", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<QueryPreviousPagePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_me_get(configuration: &configuration::Configuration, attributes: Option<&str>, excluded_attributes: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2MeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_attributes = attributes;
    let p_excluded_attributes = excluded_attributes;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/Me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_attributes {
        req_builder = req_builder.query(&[("attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_excluded_attributes {
        req_builder = req_builder.query(&[("excludedAttributes", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2MeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_me_put(configuration: &configuration::Configuration, attributes: Option<&str>, excluded_attributes: Option<&str>, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2MePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_attributes = attributes;
    let p_excluded_attributes = excluded_attributes;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/Me", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_attributes {
        req_builder = req_builder.query(&[("attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_excluded_attributes {
        req_builder = req_builder.query(&[("excludedAttributes", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2MePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_resource_types_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2ResourceTypesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/ResourceTypes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2ResourceTypesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_resource_types_type_get(configuration: &configuration::Configuration, r#type: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2ResourceTypesTypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/ResourceTypes/{type}", configuration.base_path, type=crate::apis::urlencode(p_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2ResourceTypesTypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_schemas_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2SchemasGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/Schemas", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2SchemasGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_schemas_id_get(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2SchemasIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/Schemas/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2SchemasIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_service_provider_config_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2ServiceProviderConfigGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/ServiceProviderConfig", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2ServiceProviderConfigGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_type_get(configuration: &configuration::Configuration, r#type: &str, filter: Option<&str>, attributes: Option<&str>, excluded_attributes: Option<&str>, sort_by: Option<&str>, sort_order: Option<&str>, start_index: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2TypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_filter = filter;
    let p_attributes = attributes;
    let p_excluded_attributes = excluded_attributes;
    let p_sort_by = sort_by;
    let p_sort_order = sort_order;
    let p_start_index = start_index;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/{type}", configuration.base_path, type=crate::apis::urlencode(p_type));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attributes {
        req_builder = req_builder.query(&[("attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_excluded_attributes {
        req_builder = req_builder.query(&[("excludedAttributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sortBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sortOrder", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_index {
        req_builder = req_builder.query(&[("startIndex", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2TypeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_type_id_get(configuration: &configuration::Configuration, r#type: &str, id: &str, attributes: Option<&str>, excluded_attributes: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2TypeIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type = r#type;
    let p_id = id;
    let p_attributes = attributes;
    let p_excluded_attributes = excluded_attributes;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/{type}/{id}", configuration.base_path, type=crate::apis::urlencode(p_type), id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_attributes {
        req_builder = req_builder.query(&[("attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_excluded_attributes {
        req_builder = req_builder.query(&[("excludedAttributes", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2TypeIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_users_get(configuration: &configuration::Configuration, filter: Option<&str>, attributes: Option<&str>, excluded_attributes: Option<&str>, sort_by: Option<&str>, sort_order: Option<&str>, count: Option<&str>, start_index: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2UsersGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_filter = filter;
    let p_attributes = attributes;
    let p_excluded_attributes = excluded_attributes;
    let p_sort_by = sort_by;
    let p_sort_order = sort_order;
    let p_count = count;
    let p_start_index = start_index;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/Users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attributes {
        req_builder = req_builder.query(&[("attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_excluded_attributes {
        req_builder = req_builder.query(&[("excludedAttributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sortBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sortOrder", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count {
        req_builder = req_builder.query(&[("count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_index {
        req_builder = req_builder.query(&[("startIndex", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2UsersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_users_id_get(configuration: &configuration::Configuration, id: &str, filter: Option<&str>, attributes: Option<&str>, excluded_attributes: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2UsersIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_filter = filter;
    let p_attributes = attributes;
    let p_excluded_attributes = excluded_attributes;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/Users/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_attributes {
        req_builder = req_builder.query(&[("attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_excluded_attributes {
        req_builder = req_builder.query(&[("excludedAttributes", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2UsersIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_users_id_put(configuration: &configuration::Configuration, id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2UsersIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_id = id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/Users/{id}", configuration.base_path, id=crate::apis::urlencode(p_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2UsersIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn scim_v2_users_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ScimV2UsersPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/scim/v2/Users", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ScimV2UsersPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_certificate_cert_id_get(configuration: &configuration::Configuration, cert_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesCertificateCertIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_cert_id = cert_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/certificate/{cert_id}", configuration.base_path, cert_id=crate::apis::urlencode(p_cert_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesCertificateCertIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_configuration_mode_actions_disable_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesConfigurationModeActionsDisablePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/configuration_mode/actions/disable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesConfigurationModeActionsDisablePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_configuration_mode_actions_enable_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesConfigurationModeActionsEnablePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/configuration_mode/actions/enable", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesConfigurationModeActionsEnablePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_directdata_files_get(configuration: &configuration::Configuration, extract_type: Option<&str>, start_time: Option<i32>, stop_time: Option<i32>, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesDirectdataFilesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_extract_type = extract_type;
    let p_start_time = start_time;
    let p_stop_time = stop_time;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/directdata/files", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_extract_type {
        req_builder = req_builder.query(&[("extract_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_start_time {
        req_builder = req_builder.query(&[("start_time", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_stop_time {
        req_builder = req_builder.query(&[("stop_time", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesDirectdataFilesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_directdata_files_name_get(configuration: &configuration::Configuration, name: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesDirectdataFilesNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/directdata/files/{name}", configuration.base_path, name=crate::apis::urlencode(p_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesDirectdataFilesNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_items_content_item_get(configuration: &configuration::Configuration, item: &str, authorization: Option<&str>, accept: Option<&str>, range: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingItemsContentItemGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_item = item;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_range = range;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/items/content/{item}", configuration.base_path, item=crate::apis::urlencode(p_item));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_range {
        req_builder = req_builder.header("Range", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingItemsContentItemGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_items_item_delete(configuration: &configuration::Configuration, item: &str, recursive: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingItemsItemDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_item = item;
    let p_recursive = recursive;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/items/{item}", configuration.base_path, item=crate::apis::urlencode(p_item));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_recursive {
        req_builder = req_builder.query(&[("recursive", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingItemsItemDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_items_item_get(configuration: &configuration::Configuration, item: &str, recursive: Option<&str>, limit: Option<&str>, format_result: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingItemsItemGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_item = item;
    let p_recursive = recursive;
    let p_limit = limit;
    let p_format_result = format_result;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/items/{item}", configuration.base_path, item=crate::apis::urlencode(p_item));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_recursive {
        req_builder = req_builder.query(&[("recursive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format_result {
        req_builder = req_builder.query(&[("format_result", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingItemsItemGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_items_item_put(configuration: &configuration::Configuration, item: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingItemsItemPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_item = item;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/items/{item}", configuration.base_path, item=crate::apis::urlencode(p_item));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingItemsItemPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_items_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_md5: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingItemsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_md5 = content_md5;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/items", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_md5 {
        req_builder = req_builder.header("Content-MD5", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingItemsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_upload_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingUploadGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/upload/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingUploadGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_upload_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingUploadPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/upload", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingUploadPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_upload_upload_session_id_delete(configuration: &configuration::Configuration, upload_session_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingUploadUploadSessionIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_upload_session_id = upload_session_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/upload/{upload_session_id}", configuration.base_path, upload_session_id=crate::apis::urlencode(p_upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingUploadUploadSessionIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_upload_upload_session_id_get(configuration: &configuration::Configuration, upload_session_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingUploadUploadSessionIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_upload_session_id = upload_session_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/upload/{upload_session_id}", configuration.base_path, upload_session_id=crate::apis::urlencode(p_upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingUploadUploadSessionIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_upload_upload_session_id_parts_get(configuration: &configuration::Configuration, upload_session_id: &str, limit: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingUploadUploadSessionIdPartsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_upload_session_id = upload_session_id;
    let p_limit = limit;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/upload/{upload_session_id}/parts", configuration.base_path, upload_session_id=crate::apis::urlencode(p_upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingUploadUploadSessionIdPartsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_upload_upload_session_id_post(configuration: &configuration::Configuration, upload_session_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingUploadUploadSessionIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_upload_session_id = upload_session_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/upload/{upload_session_id}", configuration.base_path, upload_session_id=crate::apis::urlencode(p_upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingUploadUploadSessionIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_file_staging_upload_upload_session_id_put(configuration: &configuration::Configuration, upload_session_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_file_part_number: Option<&str>, content_md5: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesFileStagingUploadUploadSessionIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_upload_session_id = upload_session_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_file_part_number = x_vault_api_file_part_number;
    let p_content_md5 = content_md5;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/file_staging/upload/{upload_session_id}", configuration.base_path, upload_session_id=crate::apis::urlencode(p_upload_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_file_part_number {
        req_builder = req_builder.header("X-VaultAPI-FilePartNumber", param_value.to_string());
    }
    if let Some(param_value) = p_content_md5 {
        req_builder = req_builder.header("Content-MD5", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesFileStagingUploadUploadSessionIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_jobs_histories_get(configuration: &configuration::Configuration, start_date: Option<&str>, end_date: Option<&str>, status: Option<&str>, limit: Option<&str>, offset: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesJobsHistoriesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_status = status;
    let p_limit = limit;
    let p_offset = offset;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/jobs/histories", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesJobsHistoriesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_jobs_job_id_errors_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesJobsJobIdErrorsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/jobs/{job_id}/errors", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesJobsJobIdErrorsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_jobs_job_id_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesJobsJobIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/jobs/{job_id}", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesJobsJobIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_jobs_job_id_summary_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesJobsJobIdSummaryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/jobs/{job_id}/summary", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesJobsJobIdSummaryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_jobs_job_id_tasks_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesJobsJobIdTasksGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/jobs/{job_id}/tasks", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesJobsJobIdTasksGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_jobs_monitors_get(configuration: &configuration::Configuration, start_date: Option<&str>, end_date: Option<&str>, status: Option<&str>, limit: Option<&str>, offset: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesJobsMonitorsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_status = status;
    let p_limit = limit;
    let p_offset = offset;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/jobs/monitors", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesJobsMonitorsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_jobs_start_now_job_id_post(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesJobsStartNowJobIdPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/jobs/start_now/{job_id}", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesJobsStartNowJobIdPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_loader_extract_post(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesLoaderExtractPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/loader/extract", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesLoaderExtractPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_loader_job_id_tasks_task_id_failurelog_get(configuration: &configuration::Configuration, job_id: &str, task_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesLoaderJobIdTasksTaskIdFailurelogGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/loader/{job_id}/tasks/{task_id}/failurelog", configuration.base_path, job_id=crate::apis::urlencode(p_job_id), task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesLoaderJobIdTasksTaskIdFailurelogGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_loader_job_id_tasks_task_id_results_get(configuration: &configuration::Configuration, job_id: &str, task_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesLoaderJobIdTasksTaskIdResultsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/loader/{job_id}/tasks/{task_id}/results", configuration.base_path, job_id=crate::apis::urlencode(p_job_id), task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesLoaderJobIdTasksTaskIdResultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_loader_job_id_tasks_task_id_results_renditions_get(configuration: &configuration::Configuration, job_id: &str, task_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/loader/{job_id}/tasks/{task_id}/results/renditions", configuration.base_path, job_id=crate::apis::urlencode(p_job_id), task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_loader_job_id_tasks_task_id_successlog_get(configuration: &configuration::Configuration, job_id: &str, task_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesLoaderJobIdTasksTaskIdSuccesslogGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_task_id = task_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/loader/{job_id}/tasks/{task_id}/successlog", configuration.base_path, job_id=crate::apis::urlencode(p_job_id), task_id=crate::apis::urlencode(p_task_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesLoaderJobIdTasksTaskIdSuccesslogGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_loader_load_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesLoaderLoadPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/loader/load", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesLoaderLoadPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_package_actions_validate_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesPackageActionsValidatePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/package/actions/validate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesPackageActionsValidatePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_package_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesPackagePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/package", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesPackagePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_package_put(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesPackagePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/package", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesPackagePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_queues_get(configuration: &configuration::Configuration, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesQueuesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/queues", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesQueuesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_queues_queue_name_actions_disable_delivery_put(configuration: &configuration::Configuration, queue_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesQueuesQueueNameActionsDisableDeliveryPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_queue_name = queue_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/queues/{queue_name}/actions/disable_delivery", configuration.base_path, queue_name=crate::apis::urlencode(p_queue_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesQueuesQueueNameActionsDisableDeliveryPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_queues_queue_name_actions_enable_delivery_put(configuration: &configuration::Configuration, queue_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesQueuesQueueNameActionsEnableDeliveryPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_queue_name = queue_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/queues/{queue_name}/actions/enable_delivery", configuration.base_path, queue_name=crate::apis::urlencode(p_queue_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesQueuesQueueNameActionsEnableDeliveryPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_queues_queue_name_actions_reset_put(configuration: &configuration::Configuration, queue_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesQueuesQueueNameActionsResetPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_queue_name = queue_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/queues/{queue_name}/actions/reset", configuration.base_path, queue_name=crate::apis::urlencode(p_queue_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesQueuesQueueNameActionsResetPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_queues_queue_name_get(configuration: &configuration::Configuration, queue_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesQueuesQueueNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_queue_name = queue_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/queues/{queue_name}", configuration.base_path, queue_name=crate::apis::urlencode(p_queue_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesQueuesQueueNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn services_vobject_vault_package_v_package_id_actions_validate_post(configuration: &configuration::Configuration, package_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<ServicesVobjectVaultPackageVPackageIdActionsValidatePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_id = package_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/services/vobject/vault_package__v/{package_id}/actions/validate", configuration.base_path, package_id=crate::apis::urlencode(p_package_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ServicesVobjectVaultPackageVPackageIdActionsValidatePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn session_delete(configuration: &configuration::Configuration, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<SessionDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn uicode_distributions_distribution_name_code_get(configuration: &configuration::Configuration, distribution_name: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<UicodeDistributionsDistributionNameCodeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_distribution_name = distribution_name;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/uicode/distributions/{distribution_name}/code", configuration.base_path, distribution_name=crate::apis::urlencode(p_distribution_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UicodeDistributionsDistributionNameCodeGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn uicode_distributions_distribution_name_delete(configuration: &configuration::Configuration, distribution_name: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<UicodeDistributionsDistributionNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_distribution_name = distribution_name;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/uicode/distributions/{distribution_name}", configuration.base_path, distribution_name=crate::apis::urlencode(p_distribution_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UicodeDistributionsDistributionNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn uicode_distributions_distribution_name_get(configuration: &configuration::Configuration, distribution_name: &str, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<UicodeDistributionsDistributionNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_distribution_name = distribution_name;
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/uicode/distributions/{distribution_name}", configuration.base_path, distribution_name=crate::apis::urlencode(p_distribution_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UicodeDistributionsDistributionNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn uicode_distributions_get(configuration: &configuration::Configuration, accept: Option<&str>, authorization: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<UicodeDistributionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept = accept;
    let p_authorization = authorization;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/uicode/distributions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UicodeDistributionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn uicode_distributions_post(configuration: &configuration::Configuration, accept: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<UicodeDistributionsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept = accept;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/uicode/distributions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UicodeDistributionsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobject_vault_package_v_package_id_actions_deploy_post(configuration: &configuration::Configuration, package_id: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectVaultPackageVPackageIdActionsDeployPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_id = package_id;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobject/vault_package__v/{package_id}/actions/deploy", configuration.base_path, package_id=crate::apis::urlencode(p_package_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectVaultPackageVPackageIdActionsDeployPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobject_vault_package_v_package_id_actions_deploy_results_get(configuration: &configuration::Configuration, package_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectVaultPackageVPackageIdActionsDeployResultsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_id = package_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobject/vault_package__v/{package_id}/actions/deploy/results", configuration.base_path, package_id=crate::apis::urlencode(p_package_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectVaultPackageVPackageIdActionsDeployResultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_cascadedelete_results_object_name_job_status_job_id_get(configuration: &configuration::Configuration, object_name: &str, job_status: &str, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_job_status = job_status;
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/cascadedelete/results/{object_name}/{job_status}/{job_id}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), job_status=crate::apis::urlencode(p_job_status), job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_deepcopy_results_object_name_job_status_job_id_get(configuration: &configuration::Configuration, object_name: &str, job_status: &str, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_job_status = job_status;
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/deepcopy/results/{object_name}/{job_status}/{job_id}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), job_status=crate::apis::urlencode(p_job_status), job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_edl_item_v_actions_createplaceholder_post(configuration: &configuration::Configuration, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsEdlItemVActionsCreateplaceholderPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/edl_item__v/actions/createplaceholder", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsEdlItemVActionsCreateplaceholderPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_merges_job_id_log_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsMergesJobIdLogGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/merges/{job_id}/log", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsMergesJobIdLogGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_merges_job_id_results_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsMergesJobIdResultsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/merges/{job_id}/results", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsMergesJobIdResultsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_merges_job_id_status_get(configuration: &configuration::Configuration, job_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsMergesJobIdStatusGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_job_id = job_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/merges/{job_id}/status", configuration.base_path, job_id=crate::apis::urlencode(p_job_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsMergesJobIdStatusGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_actions_action_name_post(configuration: &configuration::Configuration, object_name: &str, action_name: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameActionsActionNamePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_action_name = action_name;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/actions/{action_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), action_name=crate::apis::urlencode(p_action_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameActionsActionNamePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_actions_changetype_post(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameActionsChangetypePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/actions/changetype", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameActionsChangetypePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_actions_merge_post(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>, _vobjects__object_name__actions_merge_post_request_inner: Option<Vec<models::VobjectsObjectNameActionsMergePostRequestInner>>) -> Result<(), Error<VobjectsObjectNameActionsMergePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;
    let p__vobjects__object_name__actions_merge_post_request_inner = _vobjects__object_name__actions_merge_post_request_inner;

    let uri_str = format!("{}/vobjects/{object_name}/actions/merge", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }
    req_builder = req_builder.json(&p__vobjects__object_name__actions_merge_post_request_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameActionsMergePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_actions_recalculaterollups_get(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameActionsRecalculaterollupsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/actions/recalculaterollups", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameActionsRecalculaterollupsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_actions_recalculaterollups_post(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameActionsRecalculaterollupsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/actions/recalculaterollups", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameActionsRecalculaterollupsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_actions_updatecorporatecurrency_put(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameActionsUpdatecorporatecurrencyPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/actions/updatecorporatecurrency", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameActionsUpdatecorporatecurrencyPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_attachments_batch_delete(configuration: &configuration::Configuration, object_name: &str, id_param: Option<&str>, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameAttachmentsBatchDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_id_param = id_param;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/attachments/batch", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_id_param {
        req_builder = req_builder.query(&[("idParam", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameAttachmentsBatchDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_attachments_batch_post(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameAttachmentsBatchPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/attachments/batch", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameAttachmentsBatchPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_attachments_batch_put(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameAttachmentsBatchPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/attachments/batch", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameAttachmentsBatchPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_delete(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_id_roles_role_name_get(configuration: &configuration::Configuration, object_name: &str, id: &str, role_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameIdRolesRoleNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_id = id;
    let p_role_name = role_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{id}/roles/{role_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), id=crate::apis::urlencode(p_id), role_name=crate::apis::urlencode(p_role_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameIdRolesRoleNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_actions_action_name_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, action_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdActionsActionNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_action_name = action_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/actions/{action_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), action_name=crate::apis::urlencode(p_action_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdActionsActionNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_actions_action_name_post(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, action_name: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdActionsActionNamePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_action_name = action_name;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/actions/{action_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), action_name=crate::apis::urlencode(p_action_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdActionsActionNamePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_actions_cascadedelete_post(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdActionsCascadedeletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/actions/cascadedelete", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdActionsCascadedeletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_actions_deepcopy_post(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdActionsDeepcopyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/actions/deepcopy", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdActionsDeepcopyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_actions_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, loc: Option<bool>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdActionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_loc = loc;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/actions", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_loc {
        req_builder = req_builder.query(&[("loc", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdActionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachment_fields_attachment_field_name_file_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_field_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_field_name = attachment_field_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_field_name=crate::apis::urlencode(p_attachment_field_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachment_fields_attachment_field_name_file_post(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_field_name: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_field_name = attachment_field_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_field_name=crate::apis::urlencode(p_attachment_field_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachment_fields_file_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachment_fields/file", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_attachment_id_delete(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_id = attachment_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_id=crate::apis::urlencode(p_attachment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_attachment_id_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_id = attachment_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_id=crate::apis::urlencode(p_attachment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_attachment_id_put(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_id = attachment_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_id=crate::apis::urlencode(p_attachment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_delete(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_id: &str, attachment_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_file_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_id: &str, attachment_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}/file", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_id: &str, attachment_version: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_post(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_id: &str, attachment_version: &str, restore: Option<bool>, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_id = attachment_id;
    let p_attachment_version = attachment_version;
    let p_restore = restore;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_id=crate::apis::urlencode(p_attachment_id), attachment_version=crate::apis::urlencode(p_attachment_version));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_restore {
        req_builder = req_builder.query(&[("restore", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_attachment_id_versions_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, attachment_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_attachment_id = attachment_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id), attachment_id=crate::apis::urlencode(p_attachment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_file_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsFileGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments/file", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsFileGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_attachments_post(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAttachmentsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/attachments", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAttachmentsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_audittrail_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, start_date: Option<&str>, end_date: Option<&str>, format_result: Option<&str>, limit: Option<&str>, offset: Option<&str>, events: Option<&str>, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdAudittrailGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_start_date = start_date;
    let p_end_date = end_date;
    let p_format_result = format_result;
    let p_limit = limit;
    let p_offset = offset;
    let p_events = events;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}/audittrail", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_start_date {
        req_builder = req_builder.query(&[("start_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_end_date {
        req_builder = req_builder.query(&[("end_date", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format_result {
        req_builder = req_builder.query(&[("format_result", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_events {
        req_builder = req_builder.query(&[("events", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdAudittrailGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_object_record_id_get(configuration: &configuration::Configuration, object_name: &str, object_record_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameObjectRecordIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_object_record_id = object_record_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/{object_record_id}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name), object_record_id=crate::apis::urlencode(p_object_record_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameObjectRecordIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_post(configuration: &configuration::Configuration, object_name: &str, id_param: Option<&str>, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_migration_mode: Option<bool>, x_vault_api_no_triggers: Option<bool>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNamePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_id_param = id_param;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_no_triggers = x_vault_api_no_triggers;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_id_param {
        req_builder = req_builder.query(&[("idParam", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_no_triggers {
        req_builder = req_builder.header("X-VaultAPI-NoTriggers", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNamePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_put(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, content_type: Option<&str>, accept: Option<&str>, x_vault_api_migration_mode: Option<bool>, x_vault_api_no_triggers: Option<bool>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNamePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_content_type = content_type;
    let p_accept = accept;
    let p_x_vault_api_migration_mode = x_vault_api_migration_mode;
    let p_x_vault_api_no_triggers = x_vault_api_no_triggers;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_migration_mode {
        req_builder = req_builder.header("X-VaultAPI-MigrationMode", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_no_triggers {
        req_builder = req_builder.header("X-VaultAPI-NoTriggers", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNamePutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_roles_delete(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameRolesDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/roles", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameRolesDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_object_name_roles_post(configuration: &configuration::Configuration, object_name: &str, authorization: Option<&str>, accept: Option<&str>, content_type: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsObjectNameRolesPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_object_name = object_name;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_content_type = content_type;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/{object_name}/roles", configuration.base_path, object_name=crate::apis::urlencode(p_object_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_content_type {
        req_builder = req_builder.header("Content-Type", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsObjectNameRolesPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vobjects_outbound_package_v_package_id_dependencies_get(configuration: &configuration::Configuration, package_id: &str, authorization: Option<&str>, accept: Option<&str>, x_vault_api_client_id: Option<&str>) -> Result<(), Error<VobjectsOutboundPackageVPackageIdDependenciesGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_package_id = package_id;
    let p_authorization = authorization;
    let p_accept = accept;
    let p_x_vault_api_client_id = x_vault_api_client_id;

    let uri_str = format!("{}/vobjects/outbound_package__v/{package_id}/dependencies", configuration.base_path, package_id=crate::apis::urlencode(p_package_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_authorization {
        req_builder = req_builder.header("Authorization", param_value.to_string());
    }
    if let Some(param_value) = p_accept {
        req_builder = req_builder.header("Accept", param_value.to_string());
    }
    if let Some(param_value) = p_x_vault_api_client_id {
        req_builder = req_builder.header("X-VaultAPI-ClientID", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VobjectsOutboundPackageVPackageIdDependenciesGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

