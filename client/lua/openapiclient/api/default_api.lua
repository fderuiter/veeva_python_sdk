--[[
  Veeva Vault API v25.1

  The latest GA version of the Vault REST API.

  The version of the OpenAPI document: 1.0.0
  
  Generated by: https://openapi-generator.tech
]]

--package openapiclient

local http_request = require "http.request"
local http_util = require "http.util"
local dkjson = require "dkjson"
local basexx = require "basexx"

-- model import
local openapiclient__vobjects__object_name__actions_merge_post_request_inner = require "openapiclient.model._vobjects__object_name__actions_merge_post_request_inner"

local default_api = {}
local default_api_mt = {
	__name = "default_api";
	__index = default_api;
}

local function new_default_api(authority, basePath, schemes)
	local schemes_map = {}
	for _,v in ipairs(schemes) do
		schemes_map[v] = v
	end
	local default_scheme = schemes_map.https or schemes_map.http
	local host, port = http_util.split_authority(authority, default_scheme)
	return setmetatable({
		host = host;
		port = port;
		basePath = basePath or "http://}/api/v25.1";
		schemes = schemes_map;
		default_scheme = default_scheme;
		http_username = nil;
		http_password = nil;
		api_key = {};
		access_token = nil;
	}, default_api_mt)
end

function default_api:api_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/api",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:api_mdl_components_component_type_and_record_name_files_get(component_type_and_record_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/api/mdl/components/%s/files",
			self.basePath, component_type_and_record_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:api_mdl_components_component_type_and_record_name_get(component_type_and_record_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/api/mdl/components/%s",
			self.basePath, component_type_and_record_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:api_mdl_execute_async_job_id_results_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/api/mdl/execute_async/%s/results",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:api_mdl_execute_async_post(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/api/mdl/execute_async",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:api_mdl_execute_post(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/api/mdl/execute",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:api_mdl_files_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/api/mdl/files",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:audittrail_audit_trail_type_get(audit_trail_type, start_date, end_date, all_dates, format_result, limit, offset, objects, events, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/audittrail/%s?start_date=%s&end_date=%s&all_dates=%s&format_result=%s&limit=%s&offset=%s&objects=%s&events=%s",
			self.basePath, audit_trail_type, http_util.encodeURIComponent(start_date), http_util.encodeURIComponent(end_date), http_util.encodeURIComponent(all_dates), http_util.encodeURIComponent(format_result), http_util.encodeURIComponent(limit), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(objects), http_util.encodeURIComponent(events));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:auth_discovery_post(accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/auth/discovery",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:auth_oauth_session_oath_oidc_profile_id_post(oath_oidc_profile_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/auth/oauth/session/%s",
			self.basePath, oath_oidc_profile_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:auth_post(content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/auth",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_class_name_delete(class_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/%s",
			self.basePath, class_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_class_name_disable_put(class_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/%s/disable",
			self.basePath, class_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_class_name_enable_put(class_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/%s/enable",
			self.basePath, class_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_class_name_get(class_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/%s",
			self.basePath, class_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_profiler_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/profiler",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_profiler_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/profiler",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_profiler_session_name_actions_end_post(session_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/profiler/%s/actions/end",
			self.basePath, session_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_profiler_session_name_delete(session_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/profiler/%s",
			self.basePath, session_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_profiler_session_name_get(session_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/profiler/%s",
			self.basePath, session_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_profiler_session_name_results_get(session_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code/profiler/%s/results",
			self.basePath, session_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:code_put(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/code",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:composites_trees_edl_hierarchy_or_template_actions_listnodes_post(edl_hierarchy_or_template, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/composites/trees/%s/actions/listnodes",
			self.basePath, edl_hierarchy_or_template);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:composites_trees_edl_hierarchy_or_template_get(edl_hierarchy_or_template, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/composites/trees/%s",
			self.basePath, edl_hierarchy_or_template);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:composites_trees_edl_hierarchy_v_parent_node_id_children_get(parent_node_id, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/composites/trees/edl_hierarchy__v/%s/children",
			self.basePath, parent_node_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:composites_trees_edl_hierarchy_v_parent_node_id_children_put(parent_node_id, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/composites/trees/edl_hierarchy__v/%s/children",
			self.basePath, parent_node_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:configuration_component_type_and_record_name_get(component_type_and_record_name, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/configuration/%s?loc=%s",
			self.basePath, component_type_and_record_name, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:configuration_component_type_get(component_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/configuration/%s",
			self.basePath, component_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:configuration_object_name_and_object_type_get(object_name_and_object_type, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/configuration/%s?loc=%s",
			self.basePath, object_name_and_object_type, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:configuration_objecttype_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/configuration/Objecttype",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:configuration_role_assignment_rule_delete(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/configuration/role_assignment_rule",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:configuration_role_assignment_rule_get(lifecycle__v, role__v, product__v, country__v, study__v, study_country__v, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/configuration/role_assignment_rule?lifecycle__v=%s&role__v=%s&product__v=%s&country__v=%s&study__v=%s&study_country__v=%s",
			self.basePath, http_util.encodeURIComponent(lifecycle__v), http_util.encodeURIComponent(role__v), http_util.encodeURIComponent(product__v), http_util.encodeURIComponent(country__v), http_util.encodeURIComponent(study__v), http_util.encodeURIComponent(study_country__v));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:configuration_role_assignment_rule_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/configuration/role_assignment_rule",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:configuration_role_assignment_rule_put(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/configuration/role_assignment_rule",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:delegation_login_post(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/delegation/login",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:delegation_vaults_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/delegation/vaults",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:keep_alive_post(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/keep-alive",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:limits_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/limits",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:logs_api_usage_get(date, log_format, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/logs/api_usage?date=%s&log_format=%s",
			self.basePath, http_util.encodeURIComponent(date), http_util.encodeURIComponent(log_format));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:logs_code_debug_get(user_id, include_inactive, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/logs/code/debug?user_id=%s&include_inactive=%s",
			self.basePath, http_util.encodeURIComponent(user_id), http_util.encodeURIComponent(include_inactive));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:logs_code_debug_id_actions_reset_delete(id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/logs/code/debug/%s/actions/reset",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:logs_code_debug_id_actions_reset_post(id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/logs/code/debug/%s/actions/reset",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:logs_code_debug_id_files_get(id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/logs/code/debug/%s/files",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:logs_code_debug_id_get(id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/logs/code/debug/%s",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:logs_code_debug_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/logs/code/debug",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:logs_code_runtime_get(date, log_format, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/logs/code/runtime?date=%s&log_format=%s",
			self.basePath, http_util.encodeURIComponent(date), http_util.encodeURIComponent(log_format));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:messages_message_type_actions_import_post(message_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/messages/%s/actions/import",
			self.basePath, message_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:messages_message_type_language_lang_actions_export_post(message_type, lang, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/messages/%s/language/%s/actions/export",
			self.basePath, message_type, lang);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_audittrail_audit_trail_type_get(audit_trail_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/audittrail/%s",
			self.basePath, audit_trail_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_audittrail_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/audittrail",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_components_component_type_get(component_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/components/%s",
			self.basePath, component_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_components_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/components",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_binders_templates_bindernodes_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/binders/templates/bindernodes",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_binders_templates_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/binders/templates",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_annotations_placemarks_types_placemark_type_get(placemark_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/annotations/placemarks/types/%s",
			self.basePath, placemark_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_annotations_references_types_reference_type_get(reference_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/annotations/references/types/%s",
			self.basePath, reference_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_annotations_types_annotation_type_get(annotation_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/annotations/types/%s",
			self.basePath, annotation_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_events_event_type_types_event_subtype_get(event_type, event_subtype, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/events/%s/types/%s",
			self.basePath, event_type, event_subtype);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_events_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/events",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_lock_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/lock",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_properties_find_common_post(content_type, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/properties/find_common",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_properties_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/properties",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_templates_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/templates",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_types_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/types",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_types_type_get(type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/types/%s",
			self.basePath, type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_types_type_relationships_get(type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/types/%s/relationships",
			self.basePath, type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_types_type_subtypes_subtype_classifications_classification_get(type, subtype, classification, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/types/%s/subtypes/%s/classifications/%s",
			self.basePath, type, subtype, classification);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_documents_types_type_subtypes_subtype_get(type, subtype, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/documents/types/%s/subtypes/%s",
			self.basePath, type, subtype);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_groups_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/groups",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_securitypolicies_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/securitypolicies",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_objects_users_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/objects/users",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_query_archived_documents_relationships_document_signature_sysr_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/query/archived_documents/relationships/document_signature__sysr",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_query_documents_relationships_document_signature_sysr_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/query/documents/relationships/document_signature__sysr",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_vobjects_get(loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/vobjects?loc=%s",
			self.basePath, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_vobjects_object_name_actions_canceldeployment_post(object_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/vobjects/%s/actions/canceldeployment",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_vobjects_object_name_fields_object_field_name_get(object_name, object_field_name, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/vobjects/%s/fields/%s?loc=%s",
			self.basePath, object_name, object_field_name, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_vobjects_object_name_get(object_name, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/vobjects/%s?loc=%s",
			self.basePath, object_name, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_vobjects_object_name_page_layouts_get(object_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/vobjects/%s/page_layouts",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:metadata_vobjects_object_name_page_layouts_layout_name_get(object_name, layout_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/metadata/vobjects/%s/page_layouts/%s",
			self.basePath, object_name, layout_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:notifications_histories_get(start_date, end_date, all_dates, format_result, limit, offset, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/notifications/histories?start_date=%s&end_date=%s&all_dates=%s&format_result=%s&limit=%s&offset=%s",
			self.basePath, http_util.encodeURIComponent(start_date), http_util.encodeURIComponent(end_date), http_util.encodeURIComponent(all_dates), http_util.encodeURIComponent(format_result), http_util.encodeURIComponent(limit), http_util.encodeURIComponent(offset));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:object_workflow_actions_action_get(action, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/object/workflow/actions/%s",
			self.basePath, action);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:object_workflow_actions_action_post(action, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/object/workflow/actions/%s",
			self.basePath, action);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:object_workflow_actions_canceltasks_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/object/workflow/actions/canceltasks",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:object_workflow_actions_cancelworkflows_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/object/workflow/actions/cancelworkflows",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:object_workflow_actions_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/object/workflow/actions",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:object_workflow_actions_reassigntasks_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/object/workflow/actions/reassigntasks",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:object_workflow_actions_replaceworkflowowner_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/object/workflow/actions/replaceworkflowowner",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_actions_export_job_id_results_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/actions/export/%s/results",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_actions_export_post(binder_id, source, renditiontype, docversion, attachments, export, docfield, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/actions/export?source=%s&renditiontype=%s&docversion=%s&attachments=%s&export=%s&docfield=%s",
			self.basePath, binder_id, http_util.encodeURIComponent(source), http_util.encodeURIComponent(renditiontype), http_util.encodeURIComponent(docversion), http_util.encodeURIComponent(attachments), http_util.encodeURIComponent(export), http_util.encodeURIComponent(docfield));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_actions_post(binder_id, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/actions",
			self.basePath, binder_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_binding_rule_put(binder_id, content_type, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/binding_rule",
			self.basePath, binder_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_delete(binder_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s",
			self.basePath, binder_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_documents_node_id_binding_rule_put(binder_id, node_id, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/documents/%s/binding_rule",
			self.basePath, binder_id, node_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_documents_post(binder_id, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/documents",
			self.basePath, binder_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_documents_section_id_delete(binder_id, section_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/documents/%s",
			self.basePath, binder_id, section_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_documents_section_id_put(binder_id, section_id, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/documents/%s",
			self.basePath, binder_id, section_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_get(binder_id, depth, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s?depth=%s",
			self.basePath, binder_id, http_util.encodeURIComponent(depth));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_post(binder_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s",
			self.basePath, binder_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_put(binder_id, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s",
			self.basePath, binder_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_roles_role_name_and_user_or_group_id_delete(binder_id, role_name_and_user_or_group, id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/roles/%s/%s",
			self.basePath, binder_id, role_name_and_user_or_group, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_sections_node_id_binding_rule_put(binder_id, node_id, content_type, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/sections/%s/binding_rule",
			self.basePath, binder_id, node_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_sections_node_id_put(binder_id, node_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/sections/%s",
			self.basePath, binder_id, node_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_sections_post(binder_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/sections",
			self.basePath, binder_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_sections_section_id_delete(binder_id, section_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/sections/%s",
			self.basePath, binder_id, section_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_sections_section_id_get(binder_id, section_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/sections/%s",
			self.basePath, binder_id, section_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_versions_get(binder_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions",
			self.basePath, binder_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_versions_major_version_minor_version_actions_export_post(binder_id, major_version, minor_version, source, renditiontype, docversion, attachments, export, docfield, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s/actions/export?source=%s&renditiontype=%s&docversion=%s&attachments=%s&export=%s&docfield=%s",
			self.basePath, binder_id, major_version, minor_version, http_util.encodeURIComponent(source), http_util.encodeURIComponent(renditiontype), http_util.encodeURIComponent(docversion), http_util.encodeURIComponent(attachments), http_util.encodeURIComponent(export), http_util.encodeURIComponent(docfield));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_versions_major_version_minor_version_delete(binder_id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s",
			self.basePath, binder_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_versions_major_version_minor_version_get(binder_id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s",
			self.basePath, binder_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_versions_major_version_minor_version_put(binder_id, major_version, minor_version, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s",
			self.basePath, binder_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_versions_major_version_minor_version_relationships_post(binder_id, major_version, minor_version, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s/relationships",
			self.basePath, binder_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_versions_major_version_minor_version_relationships_relationship_id_delete(binder_id, major_version, minor_version, relationship_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s/relationships/%s",
			self.basePath, binder_id, major_version, minor_version, relationship_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_versions_major_version_minor_version_relationships_relationship_id_get(binder_id, major_version, minor_version, relationship_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s/relationships/%s",
			self.basePath, binder_id, major_version, minor_version, relationship_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_binder_id_versions_major_version_minor_version_sections_section_id_get(binder_id, major_version, minor_version, section_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s/sections/%s",
			self.basePath, binder_id, major_version, minor_version, section_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_id_roles_get(id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/roles",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_id_roles_post(id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/roles",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_id_roles_role_name_get(id, role_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/roles/%s",
			self.basePath, id, role_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_id_versions_major_version_minor_version_lifecycle_actions_get(id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s/lifecycle_actions",
			self.basePath, id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_id_versions_major_version_minor_version_lifecycle_actions_name_v_entry_requirements_get(id, major_version, minor_version, name__v, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s/lifecycle_actions/%s/entry_requirements",
			self.basePath, id, major_version, minor_version, name__v);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_id_versions_major_version_minor_version_lifecycle_actions_name_v_put(id, major_version, minor_version, name__v, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/%s/versions/%s/%s/lifecycle_actions/%s",
			self.basePath, id, major_version, minor_version, name__v);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_lifecycle_actions_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/lifecycle_actions",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_lifecycle_actions_user_action_name_put(user_action_name, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/lifecycle_actions/%s",
			self.basePath, user_action_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_post(async, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders?async=%s",
			self.basePath, http_util.encodeURIComponent(async));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_templates_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/templates",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_templates_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/templates",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_templates_put(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/templates",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_templates_template_name_bindernodes_get(template_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/templates/%s/bindernodes",
			self.basePath, template_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_templates_template_name_bindernodes_post(template_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/templates/%s/bindernodes",
			self.basePath, template_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_templates_template_name_bindernodes_put(template_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/templates/%s/bindernodes",
			self.basePath, template_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_templates_template_name_delete(template_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/templates/%s",
			self.basePath, template_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_binders_templates_template_name_get(template_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/binders/templates/%s",
			self.basePath, template_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_deletions_documents_get(start_date, end_date, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/deletions/documents?start_date=%s&end_date=%s",
			self.basePath, http_util.encodeURIComponent(start_date), http_util.encodeURIComponent(end_date));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_deletions_vobjects_object_name_get(object_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/deletions/vobjects/%s",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_actions_get(loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/actions?loc=%s",
			self.basePath, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_actions_lifecycle_and_state_and_action_job_id_results_get(lifecycle_and_state_and_action, job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/actions/%s/%s/results",
			self.basePath, lifecycle_and_state_and_action, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_actions_workflow_name_get(workflow_name, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/actions/%s?loc=%s",
			self.basePath, workflow_name, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_actions_workflow_name_post(workflow_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/actions/%s",
			self.basePath, workflow_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_annotations_batch_delete(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/annotations/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_annotations_batch_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/annotations/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_annotations_batch_put(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/annotations/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_annotations_replies_batch_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/annotations/replies/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_attachments_batch_delete(accept, authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/attachments/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_attachments_batch_post(accept, authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/attachments/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_attachments_batch_put(accept, authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/attachments/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_batch_actions_fileextract_job_id_results_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/batch/actions/fileextract/%s/results",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_batch_actions_fileextract_post(source, renditions, allversions, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/batch/actions/fileextract?source=%s&renditions=%s&allversions=%s",
			self.basePath, http_util.encodeURIComponent(source), http_util.encodeURIComponent(renditions), http_util.encodeURIComponent(allversions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_batch_actions_reclassify_put(authorization, content_type, accept, x_vault_api_migration_mode, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/batch/actions/reclassify",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_batch_actions_rerender_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/batch/actions/rerender",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_batch_delete(id_param, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/batch?idParam=%s",
			self.basePath, http_util.encodeURIComponent(id_param));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_batch_lock_delete(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/batch/lock",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_batch_post(authorization, accept, content_type, x_vault_api_migration_mode, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_batch_put(authorization, accept, content_type, x_vault_api_migration_mode, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_anchors_get(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/anchors",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_annotations_file_get(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/annotations/file",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_annotations_file_post(doc_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/annotations/file",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_attachment_id_delete(doc_id, attachment_id, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/%s",
			self.basePath, doc_id, attachment_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_attachment_id_file_get(doc_id, attachment_id, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/%s/file",
			self.basePath, doc_id, attachment_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_attachment_id_get(doc_id, attachment_id, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/%s",
			self.basePath, doc_id, attachment_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_attachment_id_put(doc_id, attachment_id, accept, authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/%s",
			self.basePath, doc_id, attachment_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_delete(doc_id, attachment_id, attachment_version, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/%s/versions/%s",
			self.basePath, doc_id, attachment_id, attachment_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_file_get(doc_id, attachment_id, attachment_version, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/%s/versions/%s/file",
			self.basePath, doc_id, attachment_id, attachment_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_get(doc_id, attachment_id, attachment_version, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/%s/versions/%s",
			self.basePath, doc_id, attachment_id, attachment_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_attachment_id_versions_attachment_version_post(doc_id, attachment_id, attachment_version, restore, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/%s/versions/%s?restore=%s",
			self.basePath, doc_id, attachment_id, attachment_version, http_util.encodeURIComponent(restore));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_attachment_id_versions_get(doc_id, attachment_id, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/%s/versions",
			self.basePath, doc_id, attachment_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_file_get(doc_id, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments/file",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_get(doc_id, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_attachments_post(doc_id, accept, authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/attachments",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_audittrail_get(doc_id, start_date, end_date, format_result, limit, offset, events, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/audittrail?start_date=%s&end_date=%s&format_result=%s&limit=%s&offset=%s&events=%s",
			self.basePath, doc_id, http_util.encodeURIComponent(start_date), http_util.encodeURIComponent(end_date), http_util.encodeURIComponent(format_result), http_util.encodeURIComponent(limit), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(events));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_delete(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_events_get(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/events",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_file_get(doc_id, lock_document, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/file?lockDocument=%s",
			self.basePath, doc_id, http_util.encodeURIComponent(lock_document));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_get(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_lock_delete(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/lock",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_lock_get(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/lock",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_lock_post(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/lock",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_major_version_minor_version_attachments_file_get(doc_id, major_version, minor_version, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/%s/%s/attachments/file",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_post(doc_id, suppress_rendition, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s?suppressRendition=%s",
			self.basePath, doc_id, http_util.encodeURIComponent(suppress_rendition));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_put(doc_id, authorization, content_type, accept, x_vault_api_migration_mode, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_renditions_get(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/renditions",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_renditions_rendition_type_delete(doc_id, rendition_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/renditions/%s",
			self.basePath, doc_id, rendition_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_renditions_rendition_type_get(doc_id, rendition_type, steady_state, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/renditions/%s?steadyState=%s",
			self.basePath, doc_id, rendition_type, http_util.encodeURIComponent(steady_state));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_renditions_rendition_type_post(doc_id, rendition_type, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/renditions/%s",
			self.basePath, doc_id, rendition_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_renditions_rendition_type_put(doc_id, rendition_type, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/renditions/%s",
			self.basePath, doc_id, rendition_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_roles_role_name_and_user_or_group_id_delete(doc_id, role_name_and_user_or_group, id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/roles/%s/%s",
			self.basePath, doc_id, role_name_and_user_or_group, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_version_major_version_minor_version_attachments_get(doc_id, major_version, minor_version, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/version/%s/%s/attachments",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_get(doc_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions",
			self.basePath, doc_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_annotations_annotation_id_get(doc_id, major_version, minor_version, annotation_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/annotations/%s",
			self.basePath, doc_id, major_version, minor_version, annotation_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_annotations_annotation_id_replies_get(doc_id, major_version, minor_version, annotation_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/annotations/%s/replies",
			self.basePath, doc_id, major_version, minor_version, annotation_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_annotations_file_get(doc_id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/annotations/file",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_annotations_file_post(doc_id, major_version, minor_version, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/annotations/file",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_annotations_get(doc_id, major_version, minor_version, limit, offset, annotation_types, pagination_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/annotations?limit=%s&offset=%s&annotation_types=%s&pagination_id=%s",
			self.basePath, doc_id, major_version, minor_version, http_util.encodeURIComponent(limit), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(annotation_types), http_util.encodeURIComponent(pagination_id));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_attachments_attachment_id_versions_attachment_version_file_get(doc_id, major_version, minor_version, attachment_id, attachment_version, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/attachments/%s/versions/%s/file",
			self.basePath, doc_id, major_version, minor_version, attachment_id, attachment_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_attachments_attachment_id_versions_attachment_version_get(doc_id, major_version, minor_version, attachment_id, attachment_version, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/attachments/%s/versions/%s",
			self.basePath, doc_id, major_version, minor_version, attachment_id, attachment_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_delete(doc_id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_doc_export_annotations_to_csv_get(doc_id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/doc-export-annotations-to-csv",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_events_post(doc_id, major_version, minor_version, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/events",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_export_video_annotations_get(doc_id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/export-video-annotations",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_file_get(doc_id, major_version, minor_version, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/file",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_get(doc_id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_put(doc_id, major_version, minor_version, authorization, content_type, accept, x_vault_api_migration_mode, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_relationships_get(doc_id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/relationships",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_relationships_post(doc_id, major_version, minor_version, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/relationships",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_relationships_relationship_id_delete(doc_id, major_version, minor_version, relationship_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/relationships/%s",
			self.basePath, doc_id, major_version, minor_version, relationship_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_relationships_relationship_id_get(doc_id, major_version, minor_version, relationship_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/relationships/%s",
			self.basePath, doc_id, major_version, minor_version, relationship_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_renditions_get(doc_id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/renditions",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_delete(doc_id, major_version, minor_version, rendition_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/renditions/%s",
			self.basePath, doc_id, major_version, minor_version, rendition_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_get(doc_id, major_version, minor_version, rendition_type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/renditions/%s",
			self.basePath, doc_id, major_version, minor_version, rendition_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_post(doc_id, major_version, minor_version, rendition_type, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/renditions/%s",
			self.basePath, doc_id, major_version, minor_version, rendition_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_renditions_rendition_type_put(doc_id, major_version, minor_version, rendition_type, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/renditions/%s",
			self.basePath, doc_id, major_version, minor_version, rendition_type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_doc_id_versions_major_version_minor_version_thumbnail_get(doc_id, major_version, minor_version, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/thumbnail",
			self.basePath, doc_id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_get(named_filter, scope, versionscope, search, limit, sort, start, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents?named_filter=%s&scope=%s&versionscope=%s&search=%s&limit=%s&sort=%s&start=%s",
			self.basePath, http_util.encodeURIComponent(named_filter), http_util.encodeURIComponent(scope), http_util.encodeURIComponent(versionscope), http_util.encodeURIComponent(search), http_util.encodeURIComponent(limit), http_util.encodeURIComponent(sort), http_util.encodeURIComponent(start));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_id_roles_get(id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/roles",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_id_roles_post(id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/roles",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_id_roles_role_name_get(id, role_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/roles/%s",
			self.basePath, id, role_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_id_versions_major_version_minor_version_lifecycle_actions_get(id, major_version, minor_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/lifecycle_actions",
			self.basePath, id, major_version, minor_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_id_versions_major_version_minor_version_lifecycle_actions_name_v_entry_requirements_get(id, major_version, minor_version, name__v, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/lifecycle_actions/%s/entry_requirements",
			self.basePath, id, major_version, minor_version, name__v);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_id_versions_major_version_minor_version_lifecycle_actions_name_v_put(id, major_version, minor_version, name__v, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/%s/versions/%s/%s/lifecycle_actions/%s",
			self.basePath, id, major_version, minor_version, name__v);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_lifecycle_actions_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/lifecycle_actions",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_lifecycle_actions_user_action_name_put(user_action_name, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/lifecycle_actions/%s",
			self.basePath, user_action_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_post(authorization, accept, x_vault_api_migration_mode, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_relationships_batch_delete(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/relationships/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_relationships_batch_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/relationships/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_renditions_batch_delete(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/renditions/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_renditions_batch_post(id_param, large_size_asset, authorization, accept, content_type, x_vault_api_migration_mode, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/renditions/batch?idParam=%s&largeSizeAsset=%s",
			self.basePath, http_util.encodeURIComponent(id_param), http_util.encodeURIComponent(large_size_asset));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_roles_batch_delete(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/roles/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_roles_batch_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/roles/batch",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_templates_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/templates",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_templates_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/templates",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_templates_put(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/templates",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_templates_template_name_delete(template_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/templates/%s",
			self.basePath, template_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_templates_template_name_file_get(template_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/templates/%s/file",
			self.basePath, template_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_templates_template_name_get(template_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/templates/%s",
			self.basePath, template_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_templates_template_name_put(template_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/templates/%s",
			self.basePath, template_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_tokens_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/tokens",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_versions_batch_actions_fileextract_post(source, renditions, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/versions/batch/actions/fileextract?source=%s&renditions=%s",
			self.basePath, http_util.encodeURIComponent(source), http_util.encodeURIComponent(renditions));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_versions_batch_delete(id_param, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/versions/batch?idParam=%s",
			self.basePath, http_util.encodeURIComponent(id_param));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_documents_versions_batch_post(id_param, authorization, accept, content_type, x_vault_api_migration_mode, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/documents/versions/batch?idParam=%s",
			self.basePath, http_util.encodeURIComponent(id_param));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_domain_get(include_application, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/domain?include_application=%s",
			self.basePath, http_util.encodeURIComponent(include_application));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_domains_get(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/domains",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_edl_matched_documents_batch_actions_add_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/edl_matched_documents/batch/actions/add",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_edl_matched_documents_batch_actions_remove_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/edl_matched_documents/batch/actions/remove",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_groups_auto_get(limit, offset, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/groups/auto?limit=%s&offset=%s",
			self.basePath, http_util.encodeURIComponent(limit), http_util.encodeURIComponent(offset));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_groups_get(include_implied, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/groups?includeImplied=%s",
			self.basePath, http_util.encodeURIComponent(include_implied));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_groups_group_id_delete(group_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/groups/%s",
			self.basePath, group_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_groups_group_id_get(group_id, include_implied, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/groups/%s?includeImplied=%s",
			self.basePath, group_id, http_util.encodeURIComponent(include_implied));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_groups_group_id_put(group_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/groups/%s",
			self.basePath, group_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_groups_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/groups",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_licenses_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/licenses",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_actions_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/actions",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_actions_workflow_name_get(workflow_name, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/actions/%s",
			self.basePath, workflow_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_actions_workflow_name_post(workflow_name, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/actions/%s",
			self.basePath, workflow_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_get(object__v, record_id__v, participant, status__v, offset, page_size, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows?object__v=%s&record_id__v=%s&participant=%s&status__v=%s&offset=%s&page_size=%s&loc=%s",
			self.basePath, http_util.encodeURIComponent(object__v), http_util.encodeURIComponent(record_id__v), http_util.encodeURIComponent(participant), http_util.encodeURIComponent(status__v), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(page_size), http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_get(object__v, record_id__v, assignee__v, status__v, offset, page_size, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks?object__v=%s&record_id__v=%s&assignee__v=%s&status__v=%s&offset=%s&page_size=%s&loc=%s",
			self.basePath, http_util.encodeURIComponent(object__v), http_util.encodeURIComponent(record_id__v), http_util.encodeURIComponent(assignee__v), http_util.encodeURIComponent(status__v), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(page_size), http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_accept_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/accept",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_cancel_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/cancel",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_complete_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/complete",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_get(task_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_mdwaccept_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/mdwaccept",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_mdwcomplete_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/mdwcomplete",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_mdwmanagecontent_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/mdwmanagecontent",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_mdwreassign_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/mdwreassign",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_reassign_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/reassign",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_task_action_get(task_id, task_action, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/%s?loc=%s",
			self.basePath, task_id, task_action, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_undoaccept_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/undoaccept",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_actions_updateduedate_post(task_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s/actions/updateduedate",
			self.basePath, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_tasks_task_id_get(task_id, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/tasks/%s?loc=%s",
			self.basePath, task_id, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_workflow_id_actions_get(workflow_id, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/%s/actions?loc=%s",
			self.basePath, workflow_id, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_workflow_id_actions_workflow_action_get(workflow_id, workflow_action, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/%s/actions/%s",
			self.basePath, workflow_id, workflow_action);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_workflow_id_actions_workflow_action_post(workflow_id, workflow_action, documents__sys, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/%s/actions/%s?documents__sys=%s",
			self.basePath, workflow_id, workflow_action, http_util.encodeURIComponent(documents__sys));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_objectworkflows_workflow_id_get(workflow_id, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/objectworkflows/%s?loc=%s",
			self.basePath, workflow_id, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_picklists_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/picklists",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_picklists_picklist_name_get(picklist_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/picklists/%s",
			self.basePath, picklist_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_picklists_picklist_name_picklist_value_name_delete(picklist_name, picklist_value_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/picklists/%s/%s",
			self.basePath, picklist_name, picklist_value_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_picklists_picklist_name_picklist_value_name_put(picklist_name, picklist_value_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/picklists/%s/%s",
			self.basePath, picklist_name, picklist_value_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_picklists_picklist_name_post(picklist_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/picklists/%s",
			self.basePath, picklist_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_picklists_picklist_name_put(picklist_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/picklists/%s",
			self.basePath, picklist_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_actions_buildproduction_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/actions/buildproduction",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_actions_promoteproduction_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/actions/promoteproduction",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_actions_recheckusage_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/actions/recheckusage",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_batch_changesize_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/batch/changesize",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_entitlements_set_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/entitlements/set",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_name_delete(name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/%s",
			self.basePath, name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_snapshot_api_name_actions_update_post(api_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/snapshot/%s/actions/update",
			self.basePath, api_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_snapshot_api_name_actions_upgrade_post(api_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/snapshot/%s/actions/upgrade",
			self.basePath, api_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_snapshot_api_name_delete(api_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/snapshot/%s",
			self.basePath, api_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_snapshot_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/snapshot",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_snapshot_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/snapshot",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_vault_id_actions_refresh_post(vault_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/%s/actions/refresh",
			self.basePath, vault_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_sandbox_vault_id_get(vault_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/sandbox/%s",
			self.basePath, vault_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_securitypolicies_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/securitypolicies",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_securitypolicies_security_policy_name_get(security_policy_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/securitypolicies/%s",
			self.basePath, security_policy_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_get(vaults, exclude_vault_membership, exclude_app_licensing, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users?vaults=%s&exclude_vault_membership=%s&exclude_app_licensing=%s",
			self.basePath, http_util.encodeURIComponent(vaults), http_util.encodeURIComponent(exclude_vault_membership), http_util.encodeURIComponent(exclude_app_licensing));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_id_get(id, exclude_vault_membership, exclude_app_licensing, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users/%s?exclude_vault_membership=%s&exclude_app_licensing=%s",
			self.basePath, id, http_util.encodeURIComponent(exclude_vault_membership), http_util.encodeURIComponent(exclude_app_licensing));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_id_permissions_get(id, filter, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users/%s/permissions?filter=%s",
			self.basePath, id, http_util.encodeURIComponent(filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_id_put(id, authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users/%s",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_me_get(exclude_vault_membership, exclude_app_licensing, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users/me?exclude_vault_membership=%s&exclude_app_licensing=%s",
			self.basePath, http_util.encodeURIComponent(exclude_vault_membership), http_util.encodeURIComponent(exclude_app_licensing));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_me_password_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users/me/password",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_me_permissions_get(filter, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users/me/permissions?filter=%s",
			self.basePath, http_util.encodeURIComponent(filter));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_me_put(authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users/me",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_put(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_user_id_delete(user_id, domain, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users/%s?domain=%s",
			self.basePath, user_id, http_util.encodeURIComponent(domain));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_users_user_id_vault_membership_vault_id_put(user_id, vault_id, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/users/%s/vault_membership/%s",
			self.basePath, user_id, vault_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_vault_actions_compare_post(authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/vault/actions/compare",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:objects_vault_actions_configreport_post(authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/objects/vault/actions/configreport",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:query_components_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/query/components",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:query_next_page_post(next_page, authorization, accept, x_vault_api_describe_query, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/query/%s",
			self.basePath, next_page);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_describe_query then
		req.headers:upsert("X-VaultAPI-DescribeQuery", x_vault_api_describe_query)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:query_post(authorization, accept, x_vault_api_describe_query, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/query",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_describe_query then
		req.headers:upsert("X-VaultAPI-DescribeQuery", x_vault_api_describe_query)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:query_previous_page_post(previous_page, authorization, accept, x_vault_api_describe_query, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/query/%s",
			self.basePath, previous_page);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_describe_query then
		req.headers:upsert("X-VaultAPI-DescribeQuery", x_vault_api_describe_query)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_me_get(attributes, excluded_attributes, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/Me?attributes=%s&excludedAttributes=%s",
			self.basePath, http_util.encodeURIComponent(attributes), http_util.encodeURIComponent(excluded_attributes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_me_put(attributes, excluded_attributes, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/Me?attributes=%s&excludedAttributes=%s",
			self.basePath, http_util.encodeURIComponent(attributes), http_util.encodeURIComponent(excluded_attributes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_resource_types_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/ResourceTypes",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_resource_types_type_get(type, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/ResourceTypes/%s",
			self.basePath, type);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_schemas_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/Schemas",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_schemas_id_get(id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/Schemas/%s",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_service_provider_config_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/ServiceProviderConfig",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_type_get(type, filter, attributes, excluded_attributes, sort_by, sort_order, start_index, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/%s?filter=%s&attributes=%s&excludedAttributes=%s&sortBy=%s&sortOrder=%s&startIndex=%s",
			self.basePath, type, http_util.encodeURIComponent(filter), http_util.encodeURIComponent(attributes), http_util.encodeURIComponent(excluded_attributes), http_util.encodeURIComponent(sort_by), http_util.encodeURIComponent(sort_order), http_util.encodeURIComponent(start_index));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_type_id_get(type, id, attributes, excluded_attributes, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/%s/%s?attributes=%s&excludedAttributes=%s",
			self.basePath, type, id, http_util.encodeURIComponent(attributes), http_util.encodeURIComponent(excluded_attributes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_users_get(filter, attributes, excluded_attributes, sort_by, sort_order, count, start_index, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/Users?filter=%s&attributes=%s&excludedAttributes=%s&sortBy=%s&sortOrder=%s&count=%s&startIndex=%s",
			self.basePath, http_util.encodeURIComponent(filter), http_util.encodeURIComponent(attributes), http_util.encodeURIComponent(excluded_attributes), http_util.encodeURIComponent(sort_by), http_util.encodeURIComponent(sort_order), http_util.encodeURIComponent(count), http_util.encodeURIComponent(start_index));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_users_id_get(id, filter, attributes, excluded_attributes, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/Users/%s?filter=%s&attributes=%s&excludedAttributes=%s",
			self.basePath, id, http_util.encodeURIComponent(filter), http_util.encodeURIComponent(attributes), http_util.encodeURIComponent(excluded_attributes));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_users_id_put(id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/Users/%s",
			self.basePath, id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:scim_v2_users_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/scim/v2/Users",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_certificate_cert_id_get(cert_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/certificate/%s",
			self.basePath, cert_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_configuration_mode_actions_disable_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/configuration_mode/actions/disable",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_configuration_mode_actions_enable_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/configuration_mode/actions/enable",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_directdata_files_get(extract_type, start_time, stop_time, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/directdata/files?extract_type=%s&start_time=%s&stop_time=%s",
			self.basePath, http_util.encodeURIComponent(extract_type), http_util.encodeURIComponent(start_time), http_util.encodeURIComponent(stop_time));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_directdata_files_name_get(name, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/directdata/files/%s",
			self.basePath, name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_items_content_item_get(item, authorization, accept, range, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/items/content/%s",
			self.basePath, item);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if range then
		req.headers:upsert("Range", range)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_items_item_delete(item, recursive, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/items/%s?recursive=%s",
			self.basePath, item, http_util.encodeURIComponent(recursive));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_items_item_get(item, recursive, limit, format_result, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/items/%s?recursive=%s&limit=%s&format_result=%s",
			self.basePath, item, http_util.encodeURIComponent(recursive), http_util.encodeURIComponent(limit), http_util.encodeURIComponent(format_result));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_items_item_put(item, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/items/%s",
			self.basePath, item);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_items_post(authorization, accept, content_md5, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/items",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_md5 then
		req.headers:upsert("Content-MD5", content_md5)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_upload_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/upload",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_upload_post(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/upload",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_upload_upload_session_id_delete(upload_session_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/upload/%s",
			self.basePath, upload_session_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_upload_upload_session_id_get(upload_session_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/upload/%s",
			self.basePath, upload_session_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_upload_upload_session_id_parts_get(upload_session_id, limit, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/upload/%s/parts?limit=%s",
			self.basePath, upload_session_id, http_util.encodeURIComponent(limit));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_upload_upload_session_id_post(upload_session_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/upload/%s",
			self.basePath, upload_session_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_file_staging_upload_upload_session_id_put(upload_session_id, authorization, accept, content_type, x_vault_api_file_part_number, content_md5, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/file_staging/upload/%s",
			self.basePath, upload_session_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_file_part_number then
		req.headers:upsert("X-VaultAPI-FilePartNumber", x_vault_api_file_part_number)
	end
	if content_md5 then
		req.headers:upsert("Content-MD5", content_md5)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_jobs_histories_get(start_date, end_date, status, limit, offset, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/jobs/histories?start_date=%s&end_date=%s&status=%s&limit=%s&offset=%s",
			self.basePath, http_util.encodeURIComponent(start_date), http_util.encodeURIComponent(end_date), http_util.encodeURIComponent(status), http_util.encodeURIComponent(limit), http_util.encodeURIComponent(offset));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_jobs_job_id_errors_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/jobs/%s/errors",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_jobs_job_id_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/jobs/%s",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_jobs_job_id_summary_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/jobs/%s/summary",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_jobs_job_id_tasks_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/jobs/%s/tasks",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_jobs_monitors_get(start_date, end_date, status, limit, offset, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/jobs/monitors?start_date=%s&end_date=%s&status=%s&limit=%s&offset=%s",
			self.basePath, http_util.encodeURIComponent(start_date), http_util.encodeURIComponent(end_date), http_util.encodeURIComponent(status), http_util.encodeURIComponent(limit), http_util.encodeURIComponent(offset));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_jobs_start_now_job_id_post(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/jobs/start_now/%s",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_loader_extract_post(authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/loader/extract",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_loader_job_id_tasks_task_id_failurelog_get(job_id, task_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/loader/%s/tasks/%s/failurelog",
			self.basePath, job_id, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_loader_job_id_tasks_task_id_results_get(job_id, task_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/loader/%s/tasks/%s/results",
			self.basePath, job_id, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_loader_job_id_tasks_task_id_results_renditions_get(job_id, task_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/loader/%s/tasks/%s/results/renditions",
			self.basePath, job_id, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_loader_job_id_tasks_task_id_successlog_get(job_id, task_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/loader/%s/tasks/%s/successlog",
			self.basePath, job_id, task_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_loader_load_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/loader/load",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_package_actions_validate_post(authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/package/actions/validate",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_package_post(authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/package",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_package_put(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/package",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_queues_get(authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/queues",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_queues_queue_name_actions_disable_delivery_put(queue_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/queues/%s/actions/disable_delivery",
			self.basePath, queue_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_queues_queue_name_actions_enable_delivery_put(queue_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/queues/%s/actions/enable_delivery",
			self.basePath, queue_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_queues_queue_name_actions_reset_put(queue_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/queues/%s/actions/reset",
			self.basePath, queue_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_queues_queue_name_get(queue_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/queues/%s",
			self.basePath, queue_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:services_vobject_vault_package_v_package_id_actions_validate_post(package_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/services/vobject/vault_package__v/%s/actions/validate",
			self.basePath, package_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:session_delete(accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/session",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:uicode_distributions_distribution_name_code_get(distribution_name, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/uicode/distributions/%s/code",
			self.basePath, distribution_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:uicode_distributions_distribution_name_delete(distribution_name, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/uicode/distributions/%s",
			self.basePath, distribution_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:uicode_distributions_distribution_name_get(distribution_name, accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/uicode/distributions/%s",
			self.basePath, distribution_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:uicode_distributions_get(accept, authorization, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/uicode/distributions",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:uicode_distributions_post(accept, authorization, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/uicode/distributions",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobject_vault_package_v_package_id_actions_deploy_post(package_id, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobject/vault_package__v/%s/actions/deploy",
			self.basePath, package_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobject_vault_package_v_package_id_actions_deploy_results_get(package_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobject/vault_package__v/%s/actions/deploy/results",
			self.basePath, package_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_cascadedelete_results_object_name_job_status_job_id_get(object_name, job_status, job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/cascadedelete/results/%s/%s/%s",
			self.basePath, object_name, job_status, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_deepcopy_results_object_name_job_status_job_id_get(object_name, job_status, job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/deepcopy/results/%s/%s/%s",
			self.basePath, object_name, job_status, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_edl_item_v_actions_createplaceholder_post(authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/edl_item__v/actions/createplaceholder",
			self.basePath);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_merges_job_id_log_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/merges/%s/log",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_merges_job_id_results_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/merges/%s/results",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_merges_job_id_status_get(job_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/merges/%s/status",
			self.basePath, job_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_actions_action_name_post(object_name, action_name, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/actions/%s",
			self.basePath, object_name, action_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_actions_changetype_post(object_name, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/actions/changetype",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_actions_merge_post(object_name, authorization, content_type, accept, x_vault_api_client_id, _vobjects__object_name__actions_merge_post_request_inner)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/actions/merge",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	-- TODO: create a function to select proper accept
	--local var_content_type = { "application/json" }
	req.headers:upsert("accept", "application/json")

	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end
	req:set_body(dkjson.encode(_vobjects__object_name__actions_merge_post_request_inner))


	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_actions_recalculaterollups_get(object_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/actions/recalculaterollups",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_actions_recalculaterollups_post(object_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/actions/recalculaterollups",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_actions_updatecorporatecurrency_put(object_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/actions/updatecorporatecurrency",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_attachments_batch_delete(object_name, id_param, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/attachments/batch?idParam=%s",
			self.basePath, object_name, http_util.encodeURIComponent(id_param));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_attachments_batch_post(object_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/attachments/batch",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_attachments_batch_put(object_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/attachments/batch",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_delete(object_name, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_id_roles_role_name_get(object_name, id, role_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/roles/%s",
			self.basePath, object_name, id, role_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_actions_action_name_get(object_name, object_record_id, action_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/actions/%s",
			self.basePath, object_name, object_record_id, action_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_actions_action_name_post(object_name, object_record_id, action_name, authorization, content_type, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/actions/%s",
			self.basePath, object_name, object_record_id, action_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_actions_cascadedelete_post(object_name, object_record_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/actions/cascadedelete",
			self.basePath, object_name, object_record_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_actions_deepcopy_post(object_name, object_record_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/actions/deepcopy",
			self.basePath, object_name, object_record_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_actions_get(object_name, object_record_id, loc, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/actions?loc=%s",
			self.basePath, object_name, object_record_id, http_util.encodeURIComponent(loc));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachment_fields_attachment_field_name_file_get(object_name, object_record_id, attachment_field_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachment_fields/%s/file",
			self.basePath, object_name, object_record_id, attachment_field_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachment_fields_attachment_field_name_file_post(object_name, object_record_id, attachment_field_name, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachment_fields/%s/file",
			self.basePath, object_name, object_record_id, attachment_field_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachment_fields_file_get(object_name, object_record_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachment_fields/file",
			self.basePath, object_name, object_record_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_attachment_id_delete(object_name, object_record_id, attachment_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments/%s",
			self.basePath, object_name, object_record_id, attachment_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_attachment_id_get(object_name, object_record_id, attachment_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments/%s",
			self.basePath, object_name, object_record_id, attachment_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_attachment_id_put(object_name, object_record_id, attachment_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments/%s",
			self.basePath, object_name, object_record_id, attachment_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_delete(object_name, object_record_id, attachment_id, attachment_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments/%s/versions/%s",
			self.basePath, object_name, object_record_id, attachment_id, attachment_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_file_get(object_name, object_record_id, attachment_id, attachment_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments/%s/versions/%s/file",
			self.basePath, object_name, object_record_id, attachment_id, attachment_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_get(object_name, object_record_id, attachment_id, attachment_version, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments/%s/versions/%s",
			self.basePath, object_name, object_record_id, attachment_id, attachment_version);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_attachment_id_versions_attachment_version_post(object_name, object_record_id, attachment_id, attachment_version, restore, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments/%s/versions/%s?restore=%s",
			self.basePath, object_name, object_record_id, attachment_id, attachment_version, http_util.encodeURIComponent(restore));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_attachment_id_versions_get(object_name, object_record_id, attachment_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments/%s/versions",
			self.basePath, object_name, object_record_id, attachment_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_file_get(object_name, object_record_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments/file",
			self.basePath, object_name, object_record_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_get(object_name, object_record_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments",
			self.basePath, object_name, object_record_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_attachments_post(object_name, object_record_id, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/attachments",
			self.basePath, object_name, object_record_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_audittrail_get(object_name, object_record_id, start_date, end_date, format_result, limit, offset, events, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s/audittrail?start_date=%s&end_date=%s&format_result=%s&limit=%s&offset=%s&events=%s",
			self.basePath, object_name, object_record_id, http_util.encodeURIComponent(start_date), http_util.encodeURIComponent(end_date), http_util.encodeURIComponent(format_result), http_util.encodeURIComponent(limit), http_util.encodeURIComponent(offset), http_util.encodeURIComponent(events));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_object_record_id_get(object_name, object_record_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/%s",
			self.basePath, object_name, object_record_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_post(object_name, id_param, authorization, content_type, accept, x_vault_api_migration_mode, x_vault_api_no_triggers, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s?idParam=%s",
			self.basePath, object_name, http_util.encodeURIComponent(id_param));
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_no_triggers then
		req.headers:upsert("X-VaultAPI-NoTriggers", x_vault_api_no_triggers)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_put(object_name, authorization, content_type, accept, x_vault_api_migration_mode, x_vault_api_no_triggers, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "PUT")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_migration_mode then
		req.headers:upsert("X-VaultAPI-MigrationMode", x_vault_api_migration_mode)
	end
	if x_vault_api_no_triggers then
		req.headers:upsert("X-VaultAPI-NoTriggers", x_vault_api_no_triggers)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_roles_delete(object_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/roles",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "DELETE")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_object_name_roles_post(object_name, authorization, accept, content_type, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/%s/roles",
			self.basePath, object_name);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "POST")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if content_type then
		req.headers:upsert("Content-Type", content_type)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

function default_api:vobjects_outbound_package_v_package_id_dependencies_get(package_id, authorization, accept, x_vault_api_client_id)
	local req = http_request.new_from_uri({
		scheme = self.default_scheme;
		host = self.host;
		port = self.port;
		path = string.format("%s/vobjects/outbound_package__v/%s/dependencies",
			self.basePath, package_id);
	})

	-- set HTTP verb
	req.headers:upsert(":method", "GET")
	if authorization then
		req.headers:upsert("Authorization", authorization)
	end
	if accept then
		req.headers:upsert("Accept", accept)
	end
	if x_vault_api_client_id then
		req.headers:upsert("X-VaultAPI-ClientID", x_vault_api_client_id)
	end

	-- make the HTTP call
	local headers, stream, errno = req:go()
	if not headers then
		return nil, stream, errno
	end
	local http_status = headers:get(":status")
	if http_status:sub(1,1) == "2" then
		return nil, headers
	else
		local body, err, errno2 = stream:get_body_as_string()
		if not body then
			return nil, err, errno2
		end
		stream:shutdown()
		-- return the error message (http body)
		return nil, http_status, body
	end
end

return {
	new = new_default_api;
}
