/*
Veeva Vault API v25.1

The latest GA version of the Vault REST API.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiApiGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiApiGetRequest) Authorization(authorization string) ApiApiGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiApiGetRequest) Accept(accept string) ApiApiGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiApiGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiApiGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiApiGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiGetExecute(r)
}

/*
ApiGet Retrieve API Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiGetRequest
*/
func (a *DefaultAPIService) ApiGet(ctx context.Context) ApiApiGetRequest {
	return ApiApiGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ApiGetExecute(r ApiApiGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	componentTypeAndRecordName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest) Authorization(authorization string) ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest) Accept(accept string) ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMdlComponentsComponentTypeAndRecordNameFilesGetExecute(r)
}

/*
ApiMdlComponentsComponentTypeAndRecordNameFilesGet Retrieve Content File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentTypeAndRecordName The component type of the record followed by the name of the record from which to retrieve the content file. The format is `{Componenttype}.{record_name}`. For example, `Formattedoutput.my_formatted_output__c`.
 @return ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest
*/
func (a *DefaultAPIService) ApiMdlComponentsComponentTypeAndRecordNameFilesGet(ctx context.Context, componentTypeAndRecordName string) ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest {
	return ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest{
		ApiService: a,
		ctx: ctx,
		componentTypeAndRecordName: componentTypeAndRecordName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ApiMdlComponentsComponentTypeAndRecordNameFilesGetExecute(r ApiApiMdlComponentsComponentTypeAndRecordNameFilesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiMdlComponentsComponentTypeAndRecordNameFilesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/mdl/components/{component_type_and_record_name}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"component_type_and_record_name"+"}", url.PathEscape(parameterValueToString(r.componentTypeAndRecordName, "componentTypeAndRecordName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	componentTypeAndRecordName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest) Authorization(authorization string) ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest) Accept(accept string) ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMdlComponentsComponentTypeAndRecordNameGetExecute(r)
}

/*
ApiMdlComponentsComponentTypeAndRecordNameGet Retrieve Component Record (MDL)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentTypeAndRecordName The component type name (`Picklist`, `Docfield`, `Doctype`, etc.) followed by the name of the record from which to retrieve metadata. The format is `{Componenttype}.{record_name}`. For example, `Picklist.color__c`. Find this with the [Retrieve Component Record Collection](https://developer.veevavault.com/api/24.3#Retrieve_Component_Record_Collection) endpoint.
 @return ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest
*/
func (a *DefaultAPIService) ApiMdlComponentsComponentTypeAndRecordNameGet(ctx context.Context, componentTypeAndRecordName string) ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest {
	return ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest{
		ApiService: a,
		ctx: ctx,
		componentTypeAndRecordName: componentTypeAndRecordName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ApiMdlComponentsComponentTypeAndRecordNameGetExecute(r ApiApiMdlComponentsComponentTypeAndRecordNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiMdlComponentsComponentTypeAndRecordNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/mdl/components/{component_type_and_record_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"component_type_and_record_name"+"}", url.PathEscape(parameterValueToString(r.componentTypeAndRecordName, "componentTypeAndRecordName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMdlExecuteAsyncJobIdResultsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiApiMdlExecuteAsyncJobIdResultsGetRequest) Authorization(authorization string) ApiApiMdlExecuteAsyncJobIdResultsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiApiMdlExecuteAsyncJobIdResultsGetRequest) Accept(accept string) ApiApiMdlExecuteAsyncJobIdResultsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiApiMdlExecuteAsyncJobIdResultsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiApiMdlExecuteAsyncJobIdResultsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiApiMdlExecuteAsyncJobIdResultsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMdlExecuteAsyncJobIdResultsGetExecute(r)
}

/*
ApiMdlExecuteAsyncJobIdResultsGet Retrieve Asynchronous MDL Script Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId
 @return ApiApiMdlExecuteAsyncJobIdResultsGetRequest
*/
func (a *DefaultAPIService) ApiMdlExecuteAsyncJobIdResultsGet(ctx context.Context, jobId string) ApiApiMdlExecuteAsyncJobIdResultsGetRequest {
	return ApiApiMdlExecuteAsyncJobIdResultsGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ApiMdlExecuteAsyncJobIdResultsGetExecute(r ApiApiMdlExecuteAsyncJobIdResultsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiMdlExecuteAsyncJobIdResultsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/mdl/execute_async/{job_id}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMdlExecuteAsyncPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiApiMdlExecuteAsyncPostRequest) Authorization(authorization string) ApiApiMdlExecuteAsyncPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiApiMdlExecuteAsyncPostRequest) Accept(accept string) ApiApiMdlExecuteAsyncPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiApiMdlExecuteAsyncPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiApiMdlExecuteAsyncPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiApiMdlExecuteAsyncPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMdlExecuteAsyncPostExecute(r)
}

/*
ApiMdlExecuteAsyncPost Execute MDL Script Asynchronously

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMdlExecuteAsyncPostRequest
*/
func (a *DefaultAPIService) ApiMdlExecuteAsyncPost(ctx context.Context) ApiApiMdlExecuteAsyncPostRequest {
	return ApiApiMdlExecuteAsyncPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ApiMdlExecuteAsyncPostExecute(r ApiApiMdlExecuteAsyncPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiMdlExecuteAsyncPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/mdl/execute_async"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMdlExecutePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiApiMdlExecutePostRequest) Authorization(authorization string) ApiApiMdlExecutePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiApiMdlExecutePostRequest) Accept(accept string) ApiApiMdlExecutePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiApiMdlExecutePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiApiMdlExecutePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiApiMdlExecutePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMdlExecutePostExecute(r)
}

/*
ApiMdlExecutePost Execute MDL Script

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMdlExecutePostRequest
*/
func (a *DefaultAPIService) ApiMdlExecutePost(ctx context.Context) ApiApiMdlExecutePostRequest {
	return ApiApiMdlExecutePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ApiMdlExecutePostExecute(r ApiApiMdlExecutePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiMdlExecutePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/mdl/execute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiMdlFilesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiApiMdlFilesPostRequest) Authorization(authorization string) ApiApiMdlFilesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiApiMdlFilesPostRequest) Accept(accept string) ApiApiMdlFilesPostRequest {
	r.accept = &accept
	return r
}

func (r ApiApiMdlFilesPostRequest) ContentType(contentType string) ApiApiMdlFilesPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiApiMdlFilesPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiApiMdlFilesPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiApiMdlFilesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiMdlFilesPostExecute(r)
}

/*
ApiMdlFilesPost Upload Content File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiMdlFilesPostRequest
*/
func (a *DefaultAPIService) ApiMdlFilesPost(ctx context.Context) ApiApiMdlFilesPostRequest {
	return ApiApiMdlFilesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ApiMdlFilesPostExecute(r ApiApiMdlFilesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiMdlFilesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/mdl/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAudittrailAuditTrailTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	auditTrailType string
	startDate *string
	endDate *string
	allDates *string
	formatResult *string
	limit *string
	offset *string
	objects *string
	events *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Specify a start date to retrieve audit information. This date cannot be more than 30 days ago. Dates must be YYYY-MM-DDTHH:MM:SSZ format, for example, 7AM on January 15, 2016 would use 2016-01-15T07:00:00Z. If omitted, defaults to the last 30 days.
func (r ApiAudittrailAuditTrailTypeGetRequest) StartDate(startDate string) ApiAudittrailAuditTrailTypeGetRequest {
	r.startDate = &startDate
	return r
}

// Specify an end date to retrieve audit information. This date cannot be more than 30 days ago. Dates must be YYYY-MM-DDTHH:MM:SSZ format, for example, 7AM on January 15, 2016 would use 2016-01-15T07:00:00Z. If omitted, defaults to the last 30 days.
func (r ApiAudittrailAuditTrailTypeGetRequest) EndDate(endDate string) ApiAudittrailAuditTrailTypeGetRequest {
	r.endDate = &endDate
	return r
}

// Set to true to request audit information for all dates. You must leave start_date and end_date blank when requesting an export of a full audit trail.
func (r ApiAudittrailAuditTrailTypeGetRequest) AllDates(allDates string) ApiAudittrailAuditTrailTypeGetRequest {
	r.allDates = &allDates
	return r
}

// To request a downloadable CSV file of your audit details, use csv. The response contains a jobId to retrieve the job status, which contains a link to download the CSV file. If omitted, the API returns a JSON response and does not start a job. If all_dates is true, this parameter is required.
func (r ApiAudittrailAuditTrailTypeGetRequest) FormatResult(formatResult string) ApiAudittrailAuditTrailTypeGetRequest {
	r.formatResult = &formatResult
	return r
}

// Paginate the results by specifying the maximum number of histories per page in the response. This can be any value between 1 and 1000. If omitted, defaults to 200.
func (r ApiAudittrailAuditTrailTypeGetRequest) Limit(limit string) ApiAudittrailAuditTrailTypeGetRequest {
	r.limit = &limit
	return r
}

// Paginate the results displayed per page by specifying the amount of offset from the entry returned. For example, if you are viewing the first 50 results (page 1) and want to see the next page, set this to offset&#x3D;51. If omitted, defaults to 0.
func (r ApiAudittrailAuditTrailTypeGetRequest) Offset(offset string) ApiAudittrailAuditTrailTypeGetRequest {
	r.offset = &offset
	return r
}

// This is an optional parameter when specifying object_audit_trail as the {audit_trail_type}. Provide a comma-separated list of one or more object names to retrieve their audit details. For example, objects&#x3D;product__v,country__v. If omitted, defaults to all objects.
func (r ApiAudittrailAuditTrailTypeGetRequest) Objects(objects string) ApiAudittrailAuditTrailTypeGetRequest {
	r.objects = &objects
	return r
}

// This is an optional parameter when specifying object_audit_trail or document_audit_trail as the {audit_trail_type}. Provide a comma-separated list of one or more audit events to retrieve their audit details. For example, events&#x3D;Edit,Delete,TaskAssignment. If omitted, defaults to all audit events. See Vault Help for full lists of object audit events and document audit events.
func (r ApiAudittrailAuditTrailTypeGetRequest) Events(events string) ApiAudittrailAuditTrailTypeGetRequest {
	r.events = &events
	return r
}

func (r ApiAudittrailAuditTrailTypeGetRequest) Authorization(authorization string) ApiAudittrailAuditTrailTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiAudittrailAuditTrailTypeGetRequest) Accept(accept string) ApiAudittrailAuditTrailTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiAudittrailAuditTrailTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiAudittrailAuditTrailTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiAudittrailAuditTrailTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.AudittrailAuditTrailTypeGetExecute(r)
}

/*
AudittrailAuditTrailTypeGet Retrieve Audit Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param auditTrailType The name of the specified audit type (document_audit_trail, object_audit_trail, etc). Use the Retrieve Audit Types API to retrieve types available in your Vault. Requests for login_audit_trail only accept one request per user at a time.
 @return ApiAudittrailAuditTrailTypeGetRequest
*/
func (a *DefaultAPIService) AudittrailAuditTrailTypeGet(ctx context.Context, auditTrailType string) ApiAudittrailAuditTrailTypeGetRequest {
	return ApiAudittrailAuditTrailTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		auditTrailType: auditTrailType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) AudittrailAuditTrailTypeGetExecute(r ApiAudittrailAuditTrailTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AudittrailAuditTrailTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audittrail/{audit_trail_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"audit_trail_type"+"}", url.PathEscape(parameterValueToString(r.auditTrailType, "auditTrailType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.allDates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_dates", r.allDates, "form", "")
	}
	if r.formatResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format_result", r.formatResult, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.objects != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "objects", r.objects, "form", "")
	}
	if r.events != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "events", r.events, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthDiscoveryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	accept *string
	xVaultAPIClientID *string
}

func (r ApiAuthDiscoveryPostRequest) Accept(accept string) ApiAuthDiscoveryPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiAuthDiscoveryPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiAuthDiscoveryPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiAuthDiscoveryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AuthDiscoveryPostExecute(r)
}

/*
AuthDiscoveryPost Authentication Type Discovery

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthDiscoveryPostRequest
*/
func (a *DefaultAPIService) AuthDiscoveryPost(ctx context.Context) ApiAuthDiscoveryPostRequest {
	return ApiAuthDiscoveryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) AuthDiscoveryPostExecute(r ApiAuthDiscoveryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AuthDiscoveryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth/discovery"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthOauthSessionOathOidcProfileIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	oathOidcProfileId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiAuthOauthSessionOathOidcProfileIdPostRequest) Authorization(authorization string) ApiAuthOauthSessionOathOidcProfileIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiAuthOauthSessionOathOidcProfileIdPostRequest) Accept(accept string) ApiAuthOauthSessionOathOidcProfileIdPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiAuthOauthSessionOathOidcProfileIdPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiAuthOauthSessionOathOidcProfileIdPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiAuthOauthSessionOathOidcProfileIdPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AuthOauthSessionOathOidcProfileIdPostExecute(r)
}

/*
AuthOauthSessionOathOidcProfileIdPost OAuth 2.0 / OpenID Connect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param oathOidcProfileId
 @return ApiAuthOauthSessionOathOidcProfileIdPostRequest
*/
func (a *DefaultAPIService) AuthOauthSessionOathOidcProfileIdPost(ctx context.Context, oathOidcProfileId string) ApiAuthOauthSessionOathOidcProfileIdPostRequest {
	return ApiAuthOauthSessionOathOidcProfileIdPostRequest{
		ApiService: a,
		ctx: ctx,
		oathOidcProfileId: oathOidcProfileId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) AuthOauthSessionOathOidcProfileIdPostExecute(r ApiAuthOauthSessionOathOidcProfileIdPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AuthOauthSessionOathOidcProfileIdPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth/oauth/session/{oath_oidc_profile_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"oath_oidc_profile_id"+"}", url.PathEscape(parameterValueToString(r.oathOidcProfileId, "oathOidcProfileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAuthPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiAuthPostRequest) ContentType(contentType string) ApiAuthPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiAuthPostRequest) Accept(accept string) ApiAuthPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiAuthPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiAuthPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiAuthPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.AuthPostExecute(r)
}

/*
AuthPost User Name and Password

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuthPostRequest
*/
func (a *DefaultAPIService) AuthPost(ctx context.Context) ApiAuthPostRequest {
	return ApiAuthPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) AuthPostExecute(r ApiAuthPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.AuthPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeClassNameDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	className string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCodeClassNameDeleteRequest) Authorization(authorization string) ApiCodeClassNameDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeClassNameDeleteRequest) Accept(accept string) ApiCodeClassNameDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeClassNameDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeClassNameDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeClassNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeClassNameDeleteExecute(r)
}

/*
CodeClassNameDelete Delete Single Source Code File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param className The fully qualified class name of your file.
 @return ApiCodeClassNameDeleteRequest
*/
func (a *DefaultAPIService) CodeClassNameDelete(ctx context.Context, className string) ApiCodeClassNameDeleteRequest {
	return ApiCodeClassNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		className: className,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeClassNameDeleteExecute(r ApiCodeClassNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeClassNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/{class_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"class_name"+"}", url.PathEscape(parameterValueToString(r.className, "className")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeClassNameDisablePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	className string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiCodeClassNameDisablePutRequest) Authorization(authorization string) ApiCodeClassNameDisablePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeClassNameDisablePutRequest) Accept(accept string) ApiCodeClassNameDisablePutRequest {
	r.accept = &accept
	return r
}

func (r ApiCodeClassNameDisablePutRequest) ContentType(contentType string) ApiCodeClassNameDisablePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeClassNameDisablePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeClassNameDisablePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeClassNameDisablePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeClassNameDisablePutExecute(r)
}

/*
CodeClassNameDisablePut Disable Vault Extension

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param className The fully qualified class name of your file.
 @return ApiCodeClassNameDisablePutRequest
*/
func (a *DefaultAPIService) CodeClassNameDisablePut(ctx context.Context, className string) ApiCodeClassNameDisablePutRequest {
	return ApiCodeClassNameDisablePutRequest{
		ApiService: a,
		ctx: ctx,
		className: className,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeClassNameDisablePutExecute(r ApiCodeClassNameDisablePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeClassNameDisablePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/{class_name}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"class_name"+"}", url.PathEscape(parameterValueToString(r.className, "className")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeClassNameEnablePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	className string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiCodeClassNameEnablePutRequest) Authorization(authorization string) ApiCodeClassNameEnablePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeClassNameEnablePutRequest) Accept(accept string) ApiCodeClassNameEnablePutRequest {
	r.accept = &accept
	return r
}

func (r ApiCodeClassNameEnablePutRequest) ContentType(contentType string) ApiCodeClassNameEnablePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeClassNameEnablePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeClassNameEnablePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeClassNameEnablePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeClassNameEnablePutExecute(r)
}

/*
CodeClassNameEnablePut Enable Vault Extension

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param className The fully qualified class name of your file.
 @return ApiCodeClassNameEnablePutRequest
*/
func (a *DefaultAPIService) CodeClassNameEnablePut(ctx context.Context, className string) ApiCodeClassNameEnablePutRequest {
	return ApiCodeClassNameEnablePutRequest{
		ApiService: a,
		ctx: ctx,
		className: className,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeClassNameEnablePutExecute(r ApiCodeClassNameEnablePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeClassNameEnablePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/{class_name}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"class_name"+"}", url.PathEscape(parameterValueToString(r.className, "className")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeClassNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	className string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCodeClassNameGetRequest) Authorization(authorization string) ApiCodeClassNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeClassNameGetRequest) Accept(accept string) ApiCodeClassNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeClassNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeClassNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeClassNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeClassNameGetExecute(r)
}

/*
CodeClassNameGet Retrieve Single Source Code File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param className The fully qualified class name of your file.
 @return ApiCodeClassNameGetRequest
*/
func (a *DefaultAPIService) CodeClassNameGet(ctx context.Context, className string) ApiCodeClassNameGetRequest {
	return ApiCodeClassNameGetRequest{
		ApiService: a,
		ctx: ctx,
		className: className,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeClassNameGetExecute(r ApiCodeClassNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeClassNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/{class_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"class_name"+"}", url.PathEscape(parameterValueToString(r.className, "className")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeProfilerGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCodeProfilerGetRequest) Authorization(authorization string) ApiCodeProfilerGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeProfilerGetRequest) Accept(accept string) ApiCodeProfilerGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeProfilerGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeProfilerGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeProfilerGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeProfilerGetExecute(r)
}

/*
CodeProfilerGet Retrieve All Profiling Sessions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCodeProfilerGetRequest
*/
func (a *DefaultAPIService) CodeProfilerGet(ctx context.Context) ApiCodeProfilerGetRequest {
	return ApiCodeProfilerGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeProfilerGetExecute(r ApiCodeProfilerGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeProfilerGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/profiler"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeProfilerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCodeProfilerPostRequest) Authorization(authorization string) ApiCodeProfilerPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeProfilerPostRequest) ContentType(contentType string) ApiCodeProfilerPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiCodeProfilerPostRequest) Accept(accept string) ApiCodeProfilerPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeProfilerPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeProfilerPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeProfilerPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeProfilerPostExecute(r)
}

/*
CodeProfilerPost Create Profiling Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCodeProfilerPostRequest
*/
func (a *DefaultAPIService) CodeProfilerPost(ctx context.Context) ApiCodeProfilerPostRequest {
	return ApiCodeProfilerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeProfilerPostExecute(r ApiCodeProfilerPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeProfilerPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/profiler"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeProfilerSessionNameActionsEndPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	sessionName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCodeProfilerSessionNameActionsEndPostRequest) Authorization(authorization string) ApiCodeProfilerSessionNameActionsEndPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeProfilerSessionNameActionsEndPostRequest) Accept(accept string) ApiCodeProfilerSessionNameActionsEndPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeProfilerSessionNameActionsEndPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeProfilerSessionNameActionsEndPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeProfilerSessionNameActionsEndPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeProfilerSessionNameActionsEndPostExecute(r)
}

/*
CodeProfilerSessionNameActionsEndPost End Profiling Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionName The name of the session, for example,  baseline__c.
 @return ApiCodeProfilerSessionNameActionsEndPostRequest
*/
func (a *DefaultAPIService) CodeProfilerSessionNameActionsEndPost(ctx context.Context, sessionName string) ApiCodeProfilerSessionNameActionsEndPostRequest {
	return ApiCodeProfilerSessionNameActionsEndPostRequest{
		ApiService: a,
		ctx: ctx,
		sessionName: sessionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeProfilerSessionNameActionsEndPostExecute(r ApiCodeProfilerSessionNameActionsEndPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeProfilerSessionNameActionsEndPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/profiler/{session_name}/actions/end"
	localVarPath = strings.Replace(localVarPath, "{"+"session_name"+"}", url.PathEscape(parameterValueToString(r.sessionName, "sessionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeProfilerSessionNameDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	sessionName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCodeProfilerSessionNameDeleteRequest) Authorization(authorization string) ApiCodeProfilerSessionNameDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeProfilerSessionNameDeleteRequest) Accept(accept string) ApiCodeProfilerSessionNameDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeProfilerSessionNameDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeProfilerSessionNameDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeProfilerSessionNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeProfilerSessionNameDeleteExecute(r)
}

/*
CodeProfilerSessionNameDelete Delete Profiling Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionName The name of the session, for example,  baseline__c.
 @return ApiCodeProfilerSessionNameDeleteRequest
*/
func (a *DefaultAPIService) CodeProfilerSessionNameDelete(ctx context.Context, sessionName string) ApiCodeProfilerSessionNameDeleteRequest {
	return ApiCodeProfilerSessionNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		sessionName: sessionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeProfilerSessionNameDeleteExecute(r ApiCodeProfilerSessionNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeProfilerSessionNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/profiler/{session_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"session_name"+"}", url.PathEscape(parameterValueToString(r.sessionName, "sessionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeProfilerSessionNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	sessionName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCodeProfilerSessionNameGetRequest) Authorization(authorization string) ApiCodeProfilerSessionNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeProfilerSessionNameGetRequest) Accept(accept string) ApiCodeProfilerSessionNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeProfilerSessionNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeProfilerSessionNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeProfilerSessionNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeProfilerSessionNameGetExecute(r)
}

/*
CodeProfilerSessionNameGet Retrieve Profiling Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionName The name of the session, for example,  baseline__c.
 @return ApiCodeProfilerSessionNameGetRequest
*/
func (a *DefaultAPIService) CodeProfilerSessionNameGet(ctx context.Context, sessionName string) ApiCodeProfilerSessionNameGetRequest {
	return ApiCodeProfilerSessionNameGetRequest{
		ApiService: a,
		ctx: ctx,
		sessionName: sessionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeProfilerSessionNameGetExecute(r ApiCodeProfilerSessionNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeProfilerSessionNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/profiler/{session_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"session_name"+"}", url.PathEscape(parameterValueToString(r.sessionName, "sessionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodeProfilerSessionNameResultsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	sessionName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCodeProfilerSessionNameResultsGetRequest) Authorization(authorization string) ApiCodeProfilerSessionNameResultsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodeProfilerSessionNameResultsGetRequest) Accept(accept string) ApiCodeProfilerSessionNameResultsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodeProfilerSessionNameResultsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodeProfilerSessionNameResultsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodeProfilerSessionNameResultsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodeProfilerSessionNameResultsGetExecute(r)
}

/*
CodeProfilerSessionNameResultsGet Download Profiling Session Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionName The name of the session, for example,  baseline__c.
 @return ApiCodeProfilerSessionNameResultsGetRequest
*/
func (a *DefaultAPIService) CodeProfilerSessionNameResultsGet(ctx context.Context, sessionName string) ApiCodeProfilerSessionNameResultsGetRequest {
	return ApiCodeProfilerSessionNameResultsGetRequest{
		ApiService: a,
		ctx: ctx,
		sessionName: sessionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodeProfilerSessionNameResultsGetExecute(r ApiCodeProfilerSessionNameResultsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodeProfilerSessionNameResultsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code/profiler/{session_name}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"session_name"+"}", url.PathEscape(parameterValueToString(r.sessionName, "sessionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCodePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiCodePutRequest) Authorization(authorization string) ApiCodePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCodePutRequest) Accept(accept string) ApiCodePutRequest {
	r.accept = &accept
	return r
}

func (r ApiCodePutRequest) ContentType(contentType string) ApiCodePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCodePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCodePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCodePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CodePutExecute(r)
}

/*
CodePut Add or Replace Single Source Code File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCodePutRequest
*/
func (a *DefaultAPIService) CodePut(ctx context.Context) ApiCodePutRequest {
	return ApiCodePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CodePutExecute(r ApiCodePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CodePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/code"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	edlHierarchyOrTemplate string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest) Authorization(authorization string) ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest) ContentType(contentType string) ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest) Accept(accept string) ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostExecute(r)
}

/*
CompositesTreesEdlHierarchyOrTemplateActionsListnodesPost Retrieve Specific Root Nodes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edlHierarchyOrTemplate Choose to retrieve either edl_hierarchy__v or edl_template__v
 @return ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest
*/
func (a *DefaultAPIService) CompositesTreesEdlHierarchyOrTemplateActionsListnodesPost(ctx context.Context, edlHierarchyOrTemplate string) ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest {
	return ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest{
		ApiService: a,
		ctx: ctx,
		edlHierarchyOrTemplate: edlHierarchyOrTemplate,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CompositesTreesEdlHierarchyOrTemplateActionsListnodesPostExecute(r ApiCompositesTreesEdlHierarchyOrTemplateActionsListnodesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CompositesTreesEdlHierarchyOrTemplateActionsListnodesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/composites/trees/{edl_hierarchy_or_template}/actions/listnodes"
	localVarPath = strings.Replace(localVarPath, "{"+"edl_hierarchy_or_template"+"}", url.PathEscape(parameterValueToString(r.edlHierarchyOrTemplate, "edlHierarchyOrTemplate")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompositesTreesEdlHierarchyOrTemplateGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	edlHierarchyOrTemplate string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCompositesTreesEdlHierarchyOrTemplateGetRequest) Authorization(authorization string) ApiCompositesTreesEdlHierarchyOrTemplateGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCompositesTreesEdlHierarchyOrTemplateGetRequest) ContentType(contentType string) ApiCompositesTreesEdlHierarchyOrTemplateGetRequest {
	r.contentType = &contentType
	return r
}

func (r ApiCompositesTreesEdlHierarchyOrTemplateGetRequest) Accept(accept string) ApiCompositesTreesEdlHierarchyOrTemplateGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCompositesTreesEdlHierarchyOrTemplateGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCompositesTreesEdlHierarchyOrTemplateGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCompositesTreesEdlHierarchyOrTemplateGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompositesTreesEdlHierarchyOrTemplateGetExecute(r)
}

/*
CompositesTreesEdlHierarchyOrTemplateGet Retrieve All Root Nodes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param edlHierarchyOrTemplate
 @return ApiCompositesTreesEdlHierarchyOrTemplateGetRequest
*/
func (a *DefaultAPIService) CompositesTreesEdlHierarchyOrTemplateGet(ctx context.Context, edlHierarchyOrTemplate string) ApiCompositesTreesEdlHierarchyOrTemplateGetRequest {
	return ApiCompositesTreesEdlHierarchyOrTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
		edlHierarchyOrTemplate: edlHierarchyOrTemplate,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CompositesTreesEdlHierarchyOrTemplateGetExecute(r ApiCompositesTreesEdlHierarchyOrTemplateGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CompositesTreesEdlHierarchyOrTemplateGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/composites/trees/{edl_hierarchy_or_template}"
	localVarPath = strings.Replace(localVarPath, "{"+"edl_hierarchy_or_template"+"}", url.PathEscape(parameterValueToString(r.edlHierarchyOrTemplate, "edlHierarchyOrTemplate")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	parentNodeId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest) Authorization(authorization string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest) ContentType(contentType string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest {
	r.contentType = &contentType
	return r
}

func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest) Accept(accept string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompositesTreesEdlHierarchyVParentNodeIdChildrenGetExecute(r)
}

/*
CompositesTreesEdlHierarchyVParentNodeIdChildrenGet Retrieve a Node's Children

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentNodeId The ID of a parent node in the hierarchy.
 @return ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest
*/
func (a *DefaultAPIService) CompositesTreesEdlHierarchyVParentNodeIdChildrenGet(ctx context.Context, parentNodeId string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest {
	return ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest{
		ApiService: a,
		ctx: ctx,
		parentNodeId: parentNodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CompositesTreesEdlHierarchyVParentNodeIdChildrenGetExecute(r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CompositesTreesEdlHierarchyVParentNodeIdChildrenGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/composites/trees/edl_hierarchy__v/{parent_node_id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_node_id"+"}", url.PathEscape(parameterValueToString(r.parentNodeId, "parentNodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	parentNodeId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest) Authorization(authorization string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest) ContentType(contentType string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest) Accept(accept string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CompositesTreesEdlHierarchyVParentNodeIdChildrenPutExecute(r)
}

/*
CompositesTreesEdlHierarchyVParentNodeIdChildrenPut Update Node Order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param parentNodeId The ID of a parent node in the hierarchy.
 @return ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest
*/
func (a *DefaultAPIService) CompositesTreesEdlHierarchyVParentNodeIdChildrenPut(ctx context.Context, parentNodeId string) ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest {
	return ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest{
		ApiService: a,
		ctx: ctx,
		parentNodeId: parentNodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) CompositesTreesEdlHierarchyVParentNodeIdChildrenPutExecute(r ApiCompositesTreesEdlHierarchyVParentNodeIdChildrenPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.CompositesTreesEdlHierarchyVParentNodeIdChildrenPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/composites/trees/edl_hierarchy__v/{parent_node_id}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"parent_node_id"+"}", url.PathEscape(parameterValueToString(r.parentNodeId, "parentNodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigurationComponentTypeAndRecordNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	componentTypeAndRecordName string
	loc *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When localized (translated) strings are available, retrieve them by setting loc to true.
func (r ApiConfigurationComponentTypeAndRecordNameGetRequest) Loc(loc string) ApiConfigurationComponentTypeAndRecordNameGetRequest {
	r.loc = &loc
	return r
}

func (r ApiConfigurationComponentTypeAndRecordNameGetRequest) Authorization(authorization string) ApiConfigurationComponentTypeAndRecordNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiConfigurationComponentTypeAndRecordNameGetRequest) Accept(accept string) ApiConfigurationComponentTypeAndRecordNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiConfigurationComponentTypeAndRecordNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiConfigurationComponentTypeAndRecordNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiConfigurationComponentTypeAndRecordNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigurationComponentTypeAndRecordNameGetExecute(r)
}

/*
ConfigurationComponentTypeAndRecordNameGet Retrieve Component Record (XML/JSON)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentTypeAndRecordName The component type name (`Picklist`, `Docfield`, `Doctype`, etc.) followed by the name of the record from which to retrieve metadata. The format is `{Componenttype}.{record_name}`. For example, `Picklist.color__c`. Find this with the [Retrieve Component Record Collection](https://developer.veevavault.com/api/24.3#Retrieve_Component_Record_Collection) endpoint.
 @return ApiConfigurationComponentTypeAndRecordNameGetRequest
*/
func (a *DefaultAPIService) ConfigurationComponentTypeAndRecordNameGet(ctx context.Context, componentTypeAndRecordName string) ApiConfigurationComponentTypeAndRecordNameGetRequest {
	return ApiConfigurationComponentTypeAndRecordNameGetRequest{
		ApiService: a,
		ctx: ctx,
		componentTypeAndRecordName: componentTypeAndRecordName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConfigurationComponentTypeAndRecordNameGetExecute(r ApiConfigurationComponentTypeAndRecordNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigurationComponentTypeAndRecordNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/configuration/{component_type_and_record_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"component_type_and_record_name"+"}", url.PathEscape(parameterValueToString(r.componentTypeAndRecordName, "componentTypeAndRecordName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigurationComponentTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	componentType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiConfigurationComponentTypeGetRequest) Authorization(authorization string) ApiConfigurationComponentTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiConfigurationComponentTypeGetRequest) Accept(accept string) ApiConfigurationComponentTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiConfigurationComponentTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiConfigurationComponentTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiConfigurationComponentTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigurationComponentTypeGetExecute(r)
}

/*
ConfigurationComponentTypeGet Retrieve Component Record Collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentType
 @return ApiConfigurationComponentTypeGetRequest
*/
func (a *DefaultAPIService) ConfigurationComponentTypeGet(ctx context.Context, componentType string) ApiConfigurationComponentTypeGetRequest {
	return ApiConfigurationComponentTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		componentType: componentType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConfigurationComponentTypeGetExecute(r ApiConfigurationComponentTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigurationComponentTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/configuration/{component_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"component_type"+"}", url.PathEscape(parameterValueToString(r.componentType, "componentType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigurationObjectNameAndObjectTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectNameAndObjectType string
	loc *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When localized (translated) strings are available, retrieve them by setting loc to true.
func (r ApiConfigurationObjectNameAndObjectTypeGetRequest) Loc(loc string) ApiConfigurationObjectNameAndObjectTypeGetRequest {
	r.loc = &loc
	return r
}

func (r ApiConfigurationObjectNameAndObjectTypeGetRequest) Authorization(authorization string) ApiConfigurationObjectNameAndObjectTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiConfigurationObjectNameAndObjectTypeGetRequest) Accept(accept string) ApiConfigurationObjectNameAndObjectTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiConfigurationObjectNameAndObjectTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiConfigurationObjectNameAndObjectTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiConfigurationObjectNameAndObjectTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigurationObjectNameAndObjectTypeGetExecute(r)
}

/*
ConfigurationObjectNameAndObjectTypeGet Retrieve Details from a Specific Object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectNameAndObjectType The object name followed by the object type in the format `Objecttype.{object_name}.{object_type}`. For example, `Objecttype.product__v.base__v`.
 @return ApiConfigurationObjectNameAndObjectTypeGetRequest
*/
func (a *DefaultAPIService) ConfigurationObjectNameAndObjectTypeGet(ctx context.Context, objectNameAndObjectType string) ApiConfigurationObjectNameAndObjectTypeGetRequest {
	return ApiConfigurationObjectNameAndObjectTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		objectNameAndObjectType: objectNameAndObjectType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConfigurationObjectNameAndObjectTypeGetExecute(r ApiConfigurationObjectNameAndObjectTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigurationObjectNameAndObjectTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/configuration/{object_name_and_object_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name_and_object_type"+"}", url.PathEscape(parameterValueToString(r.objectNameAndObjectType, "objectNameAndObjectType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigurationObjecttypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiConfigurationObjecttypeGetRequest) Authorization(authorization string) ApiConfigurationObjecttypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiConfigurationObjecttypeGetRequest) Accept(accept string) ApiConfigurationObjecttypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiConfigurationObjecttypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiConfigurationObjecttypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiConfigurationObjecttypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigurationObjecttypeGetExecute(r)
}

/*
ConfigurationObjecttypeGet Retrieve Details from All Object Types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigurationObjecttypeGetRequest
*/
func (a *DefaultAPIService) ConfigurationObjecttypeGet(ctx context.Context) ApiConfigurationObjecttypeGetRequest {
	return ApiConfigurationObjecttypeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConfigurationObjecttypeGetExecute(r ApiConfigurationObjecttypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigurationObjecttypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/configuration/Objecttype"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigurationRoleAssignmentRuleDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiConfigurationRoleAssignmentRuleDeleteRequest) Authorization(authorization string) ApiConfigurationRoleAssignmentRuleDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiConfigurationRoleAssignmentRuleDeleteRequest) Accept(accept string) ApiConfigurationRoleAssignmentRuleDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiConfigurationRoleAssignmentRuleDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiConfigurationRoleAssignmentRuleDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiConfigurationRoleAssignmentRuleDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigurationRoleAssignmentRuleDeleteExecute(r)
}

/*
ConfigurationRoleAssignmentRuleDelete Delete Lifecycle Role Assignment Override Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigurationRoleAssignmentRuleDeleteRequest
*/
func (a *DefaultAPIService) ConfigurationRoleAssignmentRuleDelete(ctx context.Context) ApiConfigurationRoleAssignmentRuleDeleteRequest {
	return ApiConfigurationRoleAssignmentRuleDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConfigurationRoleAssignmentRuleDeleteExecute(r ApiConfigurationRoleAssignmentRuleDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigurationRoleAssignmentRuleDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/configuration/role_assignment_rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigurationRoleAssignmentRuleGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	lifecycleV *string
	roleV *string
	productV *string
	countryV *string
	studyV *string
	studyCountryV *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Include the name of the lifecycle from which to retrieve information. For example: lifecycle_v&#x3D;general_lifecycle__c
func (r ApiConfigurationRoleAssignmentRuleGetRequest) LifecycleV(lifecycleV string) ApiConfigurationRoleAssignmentRuleGetRequest {
	r.lifecycleV = &lifecycleV
	return r
}

// Include the name of the role from which to retrieve information. For example: role__v&#x3D;editor__c
func (r ApiConfigurationRoleAssignmentRuleGetRequest) RoleV(roleV string) ApiConfigurationRoleAssignmentRuleGetRequest {
	r.roleV = &roleV
	return r
}

// Include the ID/name of a specific product to see product-based override rules to default users/allowed users for the lifecycle role. For example: product__v&#x3D;0PR0011001 or product__v.name__v&#x3D;CholeCap
func (r ApiConfigurationRoleAssignmentRuleGetRequest) ProductV(productV string) ApiConfigurationRoleAssignmentRuleGetRequest {
	r.productV = &productV
	return r
}

// Include the ID/name of a specific country to see country-based override rules to default users/allowed users for the lifecycle role. For example: country__v&#x3D;0CR0022002 or country__v.name__v&#x3D;United States
func (r ApiConfigurationRoleAssignmentRuleGetRequest) CountryV(countryV string) ApiConfigurationRoleAssignmentRuleGetRequest {
	r.countryV = &countryV
	return r
}

// In eTMF Vaults only. Include the ID/name of a specific study to see study-based override rules to default users/allowed users for the lifecycle role. For example: study__v&#x3D;0ST0021J01 or study__v.name__v&#x3D;CholeCap Study
func (r ApiConfigurationRoleAssignmentRuleGetRequest) StudyV(studyV string) ApiConfigurationRoleAssignmentRuleGetRequest {
	r.studyV = &studyV
	return r
}

// In eTMF Vaults only. Include the ID/name of a specific study country to see study country-based override rules to default users/allowed users for the lifecycle role. For example: study_country__v&#x3D;0SC0001001 or study_country__v.name__v&#x3D;Germany
func (r ApiConfigurationRoleAssignmentRuleGetRequest) StudyCountryV(studyCountryV string) ApiConfigurationRoleAssignmentRuleGetRequest {
	r.studyCountryV = &studyCountryV
	return r
}

func (r ApiConfigurationRoleAssignmentRuleGetRequest) Authorization(authorization string) ApiConfigurationRoleAssignmentRuleGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiConfigurationRoleAssignmentRuleGetRequest) Accept(accept string) ApiConfigurationRoleAssignmentRuleGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiConfigurationRoleAssignmentRuleGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiConfigurationRoleAssignmentRuleGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiConfigurationRoleAssignmentRuleGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigurationRoleAssignmentRuleGetExecute(r)
}

/*
ConfigurationRoleAssignmentRuleGet Retrieve Lifecycle Role Assignment Rules (Default & Override)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigurationRoleAssignmentRuleGetRequest
*/
func (a *DefaultAPIService) ConfigurationRoleAssignmentRuleGet(ctx context.Context) ApiConfigurationRoleAssignmentRuleGetRequest {
	return ApiConfigurationRoleAssignmentRuleGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConfigurationRoleAssignmentRuleGetExecute(r ApiConfigurationRoleAssignmentRuleGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigurationRoleAssignmentRuleGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/configuration/role_assignment_rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lifecycleV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lifecycle__v", r.lifecycleV, "form", "")
	}
	if r.roleV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role__v", r.roleV, "form", "")
	}
	if r.productV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product__v", r.productV, "form", "")
	}
	if r.countryV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country__v", r.countryV, "form", "")
	}
	if r.studyV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "study__v", r.studyV, "form", "")
	}
	if r.studyCountryV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "study_country__v", r.studyCountryV, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigurationRoleAssignmentRulePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiConfigurationRoleAssignmentRulePostRequest) Authorization(authorization string) ApiConfigurationRoleAssignmentRulePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiConfigurationRoleAssignmentRulePostRequest) Accept(accept string) ApiConfigurationRoleAssignmentRulePostRequest {
	r.accept = &accept
	return r
}

func (r ApiConfigurationRoleAssignmentRulePostRequest) ContentType(contentType string) ApiConfigurationRoleAssignmentRulePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiConfigurationRoleAssignmentRulePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiConfigurationRoleAssignmentRulePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiConfigurationRoleAssignmentRulePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigurationRoleAssignmentRulePostExecute(r)
}

/*
ConfigurationRoleAssignmentRulePost Create Lifecycle Role Assignment Override Rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigurationRoleAssignmentRulePostRequest
*/
func (a *DefaultAPIService) ConfigurationRoleAssignmentRulePost(ctx context.Context) ApiConfigurationRoleAssignmentRulePostRequest {
	return ApiConfigurationRoleAssignmentRulePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConfigurationRoleAssignmentRulePostExecute(r ApiConfigurationRoleAssignmentRulePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigurationRoleAssignmentRulePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/configuration/role_assignment_rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiConfigurationRoleAssignmentRulePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiConfigurationRoleAssignmentRulePutRequest) Authorization(authorization string) ApiConfigurationRoleAssignmentRulePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiConfigurationRoleAssignmentRulePutRequest) Accept(accept string) ApiConfigurationRoleAssignmentRulePutRequest {
	r.accept = &accept
	return r
}

func (r ApiConfigurationRoleAssignmentRulePutRequest) ContentType(contentType string) ApiConfigurationRoleAssignmentRulePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiConfigurationRoleAssignmentRulePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiConfigurationRoleAssignmentRulePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiConfigurationRoleAssignmentRulePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ConfigurationRoleAssignmentRulePutExecute(r)
}

/*
ConfigurationRoleAssignmentRulePut Update Lifecycle Role Assignment Rules (Default & Override)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiConfigurationRoleAssignmentRulePutRequest
*/
func (a *DefaultAPIService) ConfigurationRoleAssignmentRulePut(ctx context.Context) ApiConfigurationRoleAssignmentRulePutRequest {
	return ApiConfigurationRoleAssignmentRulePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ConfigurationRoleAssignmentRulePutExecute(r ApiConfigurationRoleAssignmentRulePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ConfigurationRoleAssignmentRulePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/configuration/role_assignment_rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDelegationLoginPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// The sessionId of the currently authenticated user who will initiate the delegated session. Cannot be a delegated_sessionid.
func (r ApiDelegationLoginPostRequest) Authorization(authorization string) ApiDelegationLoginPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDelegationLoginPostRequest) Accept(accept string) ApiDelegationLoginPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiDelegationLoginPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiDelegationLoginPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiDelegationLoginPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.DelegationLoginPostExecute(r)
}

/*
DelegationLoginPost Initiate Delegated Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDelegationLoginPostRequest
*/
func (a *DefaultAPIService) DelegationLoginPost(ctx context.Context) ApiDelegationLoginPostRequest {
	return ApiDelegationLoginPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DelegationLoginPostExecute(r ApiDelegationLoginPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DelegationLoginPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delegation/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDelegationVaultsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiDelegationVaultsGetRequest) Authorization(authorization string) ApiDelegationVaultsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiDelegationVaultsGetRequest) Accept(accept string) ApiDelegationVaultsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiDelegationVaultsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiDelegationVaultsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiDelegationVaultsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.DelegationVaultsGetExecute(r)
}

/*
DelegationVaultsGet Retrieve Delegations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDelegationVaultsGetRequest
*/
func (a *DefaultAPIService) DelegationVaultsGet(ctx context.Context) ApiDelegationVaultsGetRequest {
	return ApiDelegationVaultsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) DelegationVaultsGetExecute(r ApiDelegationVaultsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.DelegationVaultsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delegation/vaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiKeepAlivePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiKeepAlivePostRequest) Authorization(authorization string) ApiKeepAlivePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiKeepAlivePostRequest) Accept(accept string) ApiKeepAlivePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiKeepAlivePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiKeepAlivePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiKeepAlivePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.KeepAlivePostExecute(r)
}

/*
KeepAlivePost Session Keep Alive

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiKeepAlivePostRequest
*/
func (a *DefaultAPIService) KeepAlivePost(ctx context.Context) ApiKeepAlivePostRequest {
	return ApiKeepAlivePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) KeepAlivePostExecute(r ApiKeepAlivePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.KeepAlivePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/keep-alive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLimitsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiLimitsGetRequest) Authorization(authorization string) ApiLimitsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiLimitsGetRequest) Accept(accept string) ApiLimitsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiLimitsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiLimitsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiLimitsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.LimitsGetExecute(r)
}

/*
LimitsGet Retrieve Limits on Objects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLimitsGetRequest
*/
func (a *DefaultAPIService) LimitsGet(ctx context.Context) ApiLimitsGetRequest {
	return ApiLimitsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) LimitsGetExecute(r ApiLimitsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LimitsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/limits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLogsApiUsageGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	date *string
	logFormat *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// The day to retrieve the API Usage log. Date is in UTC and follows the format YYYY-MM-DD. Date cannot be more than 30 days in the past.
func (r ApiLogsApiUsageGetRequest) Date(date string) ApiLogsApiUsageGetRequest {
	r.date = &date
	return r
}

// Optional: Specify the format to download. Possible values are csv or logfile. If omitted, defaults to csv. Note that this call always downloads a ZIP file. This parameter only changes the format of the file contained within the ZIP. 
func (r ApiLogsApiUsageGetRequest) LogFormat(logFormat string) ApiLogsApiUsageGetRequest {
	r.logFormat = &logFormat
	return r
}

func (r ApiLogsApiUsageGetRequest) Authorization(authorization string) ApiLogsApiUsageGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiLogsApiUsageGetRequest) Accept(accept string) ApiLogsApiUsageGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiLogsApiUsageGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiLogsApiUsageGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiLogsApiUsageGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogsApiUsageGetExecute(r)
}

/*
LogsApiUsageGet Download Daily API Usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLogsApiUsageGetRequest
*/
func (a *DefaultAPIService) LogsApiUsageGet(ctx context.Context) ApiLogsApiUsageGetRequest {
	return ApiLogsApiUsageGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) LogsApiUsageGetExecute(r ApiLogsApiUsageGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LogsApiUsageGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logs/api_usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.logFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "log_format", r.logFormat, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLogsCodeDebugGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	userId *string
	includeInactive *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Filter results to retrieve the debug log for this user ID only. If omitted, this request retrieves debug logs for all users in the Vault.
func (r ApiLogsCodeDebugGetRequest) UserId(userId string) ApiLogsCodeDebugGetRequest {
	r.userId = &userId
	return r
}

// Set to &#x60;true&#x60; to include debug log sessions with a status of &#x60;inactive__sys&#x60; in the response. If omitted, defaults to &#x60;false&#x60; and inactive sessions are not included in the response.
func (r ApiLogsCodeDebugGetRequest) IncludeInactive(includeInactive bool) ApiLogsCodeDebugGetRequest {
	r.includeInactive = &includeInactive
	return r
}

func (r ApiLogsCodeDebugGetRequest) Authorization(authorization string) ApiLogsCodeDebugGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiLogsCodeDebugGetRequest) Accept(accept string) ApiLogsCodeDebugGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiLogsCodeDebugGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiLogsCodeDebugGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiLogsCodeDebugGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogsCodeDebugGetExecute(r)
}

/*
LogsCodeDebugGet Retrieve All Debug Logs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLogsCodeDebugGetRequest
*/
func (a *DefaultAPIService) LogsCodeDebugGet(ctx context.Context) ApiLogsCodeDebugGetRequest {
	return ApiLogsCodeDebugGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) LogsCodeDebugGetExecute(r ApiLogsCodeDebugGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LogsCodeDebugGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logs/code/debug"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_id", r.userId, "form", "")
	}
	if r.includeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_inactive", r.includeInactive, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLogsCodeDebugIdActionsResetDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiLogsCodeDebugIdActionsResetDeleteRequest) Authorization(authorization string) ApiLogsCodeDebugIdActionsResetDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiLogsCodeDebugIdActionsResetDeleteRequest) Accept(accept string) ApiLogsCodeDebugIdActionsResetDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiLogsCodeDebugIdActionsResetDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiLogsCodeDebugIdActionsResetDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiLogsCodeDebugIdActionsResetDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogsCodeDebugIdActionsResetDeleteExecute(r)
}

/*
LogsCodeDebugIdActionsResetDelete Delete Debug Log

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the debug log to delete.
 @return ApiLogsCodeDebugIdActionsResetDeleteRequest
*/
func (a *DefaultAPIService) LogsCodeDebugIdActionsResetDelete(ctx context.Context, id string) ApiLogsCodeDebugIdActionsResetDeleteRequest {
	return ApiLogsCodeDebugIdActionsResetDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) LogsCodeDebugIdActionsResetDeleteExecute(r ApiLogsCodeDebugIdActionsResetDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LogsCodeDebugIdActionsResetDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logs/code/debug/{id}/actions/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLogsCodeDebugIdActionsResetPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiLogsCodeDebugIdActionsResetPostRequest) Authorization(authorization string) ApiLogsCodeDebugIdActionsResetPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiLogsCodeDebugIdActionsResetPostRequest) Accept(accept string) ApiLogsCodeDebugIdActionsResetPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiLogsCodeDebugIdActionsResetPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiLogsCodeDebugIdActionsResetPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiLogsCodeDebugIdActionsResetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogsCodeDebugIdActionsResetPostExecute(r)
}

/*
LogsCodeDebugIdActionsResetPost Reset Debug Log

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the debug log to delete.
 @return ApiLogsCodeDebugIdActionsResetPostRequest
*/
func (a *DefaultAPIService) LogsCodeDebugIdActionsResetPost(ctx context.Context, id string) ApiLogsCodeDebugIdActionsResetPostRequest {
	return ApiLogsCodeDebugIdActionsResetPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) LogsCodeDebugIdActionsResetPostExecute(r ApiLogsCodeDebugIdActionsResetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LogsCodeDebugIdActionsResetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logs/code/debug/{id}/actions/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLogsCodeDebugIdFilesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiLogsCodeDebugIdFilesGetRequest) Authorization(authorization string) ApiLogsCodeDebugIdFilesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiLogsCodeDebugIdFilesGetRequest) Accept(accept string) ApiLogsCodeDebugIdFilesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiLogsCodeDebugIdFilesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiLogsCodeDebugIdFilesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiLogsCodeDebugIdFilesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogsCodeDebugIdFilesGetExecute(r)
}

/*
LogsCodeDebugIdFilesGet Download Debug Log Files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the debug log to download.
 @return ApiLogsCodeDebugIdFilesGetRequest
*/
func (a *DefaultAPIService) LogsCodeDebugIdFilesGet(ctx context.Context, id string) ApiLogsCodeDebugIdFilesGetRequest {
	return ApiLogsCodeDebugIdFilesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) LogsCodeDebugIdFilesGetExecute(r ApiLogsCodeDebugIdFilesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LogsCodeDebugIdFilesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logs/code/debug/{id}/files"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLogsCodeDebugIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiLogsCodeDebugIdGetRequest) Authorization(authorization string) ApiLogsCodeDebugIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiLogsCodeDebugIdGetRequest) Accept(accept string) ApiLogsCodeDebugIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiLogsCodeDebugIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiLogsCodeDebugIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiLogsCodeDebugIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogsCodeDebugIdGetExecute(r)
}

/*
LogsCodeDebugIdGet Retrieve Single Debug Log

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the debug log to retrieve.
 @return ApiLogsCodeDebugIdGetRequest
*/
func (a *DefaultAPIService) LogsCodeDebugIdGet(ctx context.Context, id string) ApiLogsCodeDebugIdGetRequest {
	return ApiLogsCodeDebugIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) LogsCodeDebugIdGetExecute(r ApiLogsCodeDebugIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LogsCodeDebugIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logs/code/debug/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLogsCodeDebugPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiLogsCodeDebugPostRequest) Authorization(authorization string) ApiLogsCodeDebugPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiLogsCodeDebugPostRequest) Accept(accept string) ApiLogsCodeDebugPostRequest {
	r.accept = &accept
	return r
}

func (r ApiLogsCodeDebugPostRequest) ContentType(contentType string) ApiLogsCodeDebugPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiLogsCodeDebugPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiLogsCodeDebugPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiLogsCodeDebugPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogsCodeDebugPostExecute(r)
}

/*
LogsCodeDebugPost Create Debug Log

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLogsCodeDebugPostRequest
*/
func (a *DefaultAPIService) LogsCodeDebugPost(ctx context.Context) ApiLogsCodeDebugPostRequest {
	return ApiLogsCodeDebugPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) LogsCodeDebugPostExecute(r ApiLogsCodeDebugPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LogsCodeDebugPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logs/code/debug"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLogsCodeRuntimeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	date *string
	logFormat *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiLogsCodeRuntimeGetRequest) Date(date string) ApiLogsCodeRuntimeGetRequest {
	r.date = &date
	return r
}

// Optional: Specify the format to download. Possible values are csv or logfile. If omitted, defaults to csv. Note that this call always downloads a ZIP file. This parameter only changes the format of the file contained within the ZIP. 
func (r ApiLogsCodeRuntimeGetRequest) LogFormat(logFormat string) ApiLogsCodeRuntimeGetRequest {
	r.logFormat = &logFormat
	return r
}

func (r ApiLogsCodeRuntimeGetRequest) Authorization(authorization string) ApiLogsCodeRuntimeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiLogsCodeRuntimeGetRequest) Accept(accept string) ApiLogsCodeRuntimeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiLogsCodeRuntimeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiLogsCodeRuntimeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiLogsCodeRuntimeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.LogsCodeRuntimeGetExecute(r)
}

/*
LogsCodeRuntimeGet Download SDK Runtime Log

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLogsCodeRuntimeGetRequest
*/
func (a *DefaultAPIService) LogsCodeRuntimeGet(ctx context.Context) ApiLogsCodeRuntimeGetRequest {
	return ApiLogsCodeRuntimeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) LogsCodeRuntimeGetExecute(r ApiLogsCodeRuntimeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.LogsCodeRuntimeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/logs/code/runtime"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	}
	if r.logFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "log_format", r.logFormat, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMessagesMessageTypeActionsImportPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	messageType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMessagesMessageTypeActionsImportPostRequest) Authorization(authorization string) ApiMessagesMessageTypeActionsImportPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMessagesMessageTypeActionsImportPostRequest) Accept(accept string) ApiMessagesMessageTypeActionsImportPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMessagesMessageTypeActionsImportPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMessagesMessageTypeActionsImportPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMessagesMessageTypeActionsImportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MessagesMessageTypeActionsImportPostExecute(r)
}

/*
MessagesMessageTypeActionsImportPost Import Bulk Translation File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageType The message type name: field_labels__sys, system_messages__sys, notification_template_messages__sys, or user_account_messages__sys.
 @return ApiMessagesMessageTypeActionsImportPostRequest
*/
func (a *DefaultAPIService) MessagesMessageTypeActionsImportPost(ctx context.Context, messageType string) ApiMessagesMessageTypeActionsImportPostRequest {
	return ApiMessagesMessageTypeActionsImportPostRequest{
		ApiService: a,
		ctx: ctx,
		messageType: messageType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MessagesMessageTypeActionsImportPostExecute(r ApiMessagesMessageTypeActionsImportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MessagesMessageTypeActionsImportPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{message_type}/actions/import"
	localVarPath = strings.Replace(localVarPath, "{"+"message_type"+"}", url.PathEscape(parameterValueToString(r.messageType, "messageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMessagesMessageTypeLanguageLangActionsExportPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	messageType string
	lang string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMessagesMessageTypeLanguageLangActionsExportPostRequest) Authorization(authorization string) ApiMessagesMessageTypeLanguageLangActionsExportPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMessagesMessageTypeLanguageLangActionsExportPostRequest) Accept(accept string) ApiMessagesMessageTypeLanguageLangActionsExportPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMessagesMessageTypeLanguageLangActionsExportPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMessagesMessageTypeLanguageLangActionsExportPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMessagesMessageTypeLanguageLangActionsExportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MessagesMessageTypeLanguageLangActionsExportPostExecute(r)
}

/*
MessagesMessageTypeLanguageLangActionsExportPost Export Bulk Translation File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageType The message type name: field_labels__sys, system_messages__sys, notification_template_messages__sys, or user_account_messages__sys.
 @param lang A valid language code value, for example, en. Retrieve available values from the Admin Key (admin_key__sys) field on the Language (language__sys) object. Active and Inactive languages are both valid. 
 @return ApiMessagesMessageTypeLanguageLangActionsExportPostRequest
*/
func (a *DefaultAPIService) MessagesMessageTypeLanguageLangActionsExportPost(ctx context.Context, messageType string, lang string) ApiMessagesMessageTypeLanguageLangActionsExportPostRequest {
	return ApiMessagesMessageTypeLanguageLangActionsExportPostRequest{
		ApiService: a,
		ctx: ctx,
		messageType: messageType,
		lang: lang,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MessagesMessageTypeLanguageLangActionsExportPostExecute(r ApiMessagesMessageTypeLanguageLangActionsExportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MessagesMessageTypeLanguageLangActionsExportPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/messages/{message_type}/language/{lang}/actions/export"
	localVarPath = strings.Replace(localVarPath, "{"+"message_type"+"}", url.PathEscape(parameterValueToString(r.messageType, "messageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"lang"+"}", url.PathEscape(parameterValueToString(r.lang, "lang")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataAudittrailAuditTrailTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	auditTrailType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataAudittrailAuditTrailTypeGetRequest) Authorization(authorization string) ApiMetadataAudittrailAuditTrailTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataAudittrailAuditTrailTypeGetRequest) Accept(accept string) ApiMetadataAudittrailAuditTrailTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataAudittrailAuditTrailTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataAudittrailAuditTrailTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataAudittrailAuditTrailTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataAudittrailAuditTrailTypeGetExecute(r)
}

/*
MetadataAudittrailAuditTrailTypeGet Retrieve Audit Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param auditTrailType The name of the specified audit type (document_audit_trail, object_audit_trail, etc).
 @return ApiMetadataAudittrailAuditTrailTypeGetRequest
*/
func (a *DefaultAPIService) MetadataAudittrailAuditTrailTypeGet(ctx context.Context, auditTrailType string) ApiMetadataAudittrailAuditTrailTypeGetRequest {
	return ApiMetadataAudittrailAuditTrailTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		auditTrailType: auditTrailType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataAudittrailAuditTrailTypeGetExecute(r ApiMetadataAudittrailAuditTrailTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataAudittrailAuditTrailTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/audittrail/{audit_trail_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"audit_trail_type"+"}", url.PathEscape(parameterValueToString(r.auditTrailType, "auditTrailType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataAudittrailGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataAudittrailGetRequest) Authorization(authorization string) ApiMetadataAudittrailGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataAudittrailGetRequest) Accept(accept string) ApiMetadataAudittrailGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataAudittrailGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataAudittrailGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataAudittrailGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataAudittrailGetExecute(r)
}

/*
MetadataAudittrailGet Retrieve Audit Types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataAudittrailGetRequest
*/
func (a *DefaultAPIService) MetadataAudittrailGet(ctx context.Context) ApiMetadataAudittrailGetRequest {
	return ApiMetadataAudittrailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataAudittrailGetExecute(r ApiMetadataAudittrailGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataAudittrailGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/audittrail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataComponentsComponentTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	componentType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataComponentsComponentTypeGetRequest) Authorization(authorization string) ApiMetadataComponentsComponentTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataComponentsComponentTypeGetRequest) Accept(accept string) ApiMetadataComponentsComponentTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataComponentsComponentTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataComponentsComponentTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataComponentsComponentTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataComponentsComponentTypeGetExecute(r)
}

/*
MetadataComponentsComponentTypeGet Retrieve Component Type Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentType The component type name (Picklist, Docfield, Doctype, etc.).
 @return ApiMetadataComponentsComponentTypeGetRequest
*/
func (a *DefaultAPIService) MetadataComponentsComponentTypeGet(ctx context.Context, componentType string) ApiMetadataComponentsComponentTypeGetRequest {
	return ApiMetadataComponentsComponentTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		componentType: componentType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataComponentsComponentTypeGetExecute(r ApiMetadataComponentsComponentTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataComponentsComponentTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/components/{component_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"component_type"+"}", url.PathEscape(parameterValueToString(r.componentType, "componentType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataComponentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataComponentsGetRequest) Authorization(authorization string) ApiMetadataComponentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataComponentsGetRequest) Accept(accept string) ApiMetadataComponentsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataComponentsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataComponentsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataComponentsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataComponentsGetExecute(r)
}

/*
MetadataComponentsGet Retrieve All Component Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataComponentsGetRequest
*/
func (a *DefaultAPIService) MetadataComponentsGet(ctx context.Context) ApiMetadataComponentsGetRequest {
	return ApiMetadataComponentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataComponentsGetExecute(r ApiMetadataComponentsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataComponentsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/components"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsBindersTemplatesBindernodesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsBindersTemplatesBindernodesGetRequest) Authorization(authorization string) ApiMetadataObjectsBindersTemplatesBindernodesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsBindersTemplatesBindernodesGetRequest) Accept(accept string) ApiMetadataObjectsBindersTemplatesBindernodesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsBindersTemplatesBindernodesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsBindersTemplatesBindernodesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsBindersTemplatesBindernodesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsBindersTemplatesBindernodesGetExecute(r)
}

/*
MetadataObjectsBindersTemplatesBindernodesGet Retrieve Binder Template Node Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsBindersTemplatesBindernodesGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsBindersTemplatesBindernodesGet(ctx context.Context) ApiMetadataObjectsBindersTemplatesBindernodesGetRequest {
	return ApiMetadataObjectsBindersTemplatesBindernodesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsBindersTemplatesBindernodesGetExecute(r ApiMetadataObjectsBindersTemplatesBindernodesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsBindersTemplatesBindernodesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/binders/templates/bindernodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsBindersTemplatesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsBindersTemplatesGetRequest) Authorization(authorization string) ApiMetadataObjectsBindersTemplatesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsBindersTemplatesGetRequest) Accept(accept string) ApiMetadataObjectsBindersTemplatesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsBindersTemplatesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsBindersTemplatesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsBindersTemplatesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsBindersTemplatesGetExecute(r)
}

/*
MetadataObjectsBindersTemplatesGet Retrieve Binder Template Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsBindersTemplatesGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsBindersTemplatesGet(ctx context.Context) ApiMetadataObjectsBindersTemplatesGetRequest {
	return ApiMetadataObjectsBindersTemplatesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsBindersTemplatesGetExecute(r ApiMetadataObjectsBindersTemplatesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsBindersTemplatesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/binders/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	placemarkType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetExecute(r)
}

/*
MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet Retrieve Annotation Placemark Type Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param placemarkType The name of the placemark type. For example, sticky__sys.
 @return ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet(ctx context.Context, placemarkType string) ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest {
	return ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		placemarkType: placemarkType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetExecute(r ApiMetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/annotations/placemarks/types/{placemark_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"placemark_type"+"}", url.PathEscape(parameterValueToString(r.placemarkType, "placemarkType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	referenceType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetExecute(r)
}

/*
MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet Retrieve Annotation Reference Type Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param referenceType
 @return ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet(ctx context.Context, referenceType string) ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest {
	return ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		referenceType: referenceType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetExecute(r ApiMetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/annotations/references/types/{reference_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"reference_type"+"}", url.PathEscape(parameterValueToString(r.referenceType, "referenceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	annotationType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetExecute(r)
}

/*
MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet Retrieve Annotation Type Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param annotationType The name of the annotation type. Valid annotation types include: `note__sys` `line__sys` `document_link__sys` `permalink_link__sys` `anchor__sys` `reply__sys` `external_link__sys`  The following annotation types are only valid in Medical and PromoMats Vaults:  `suggested_link__sys` `approved_link__sys` `auto_link__sys` `keyword_link__sys`
 @return ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet(ctx context.Context, annotationType string) ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest {
	return ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		annotationType: annotationType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetExecute(r ApiMetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsAnnotationsTypesAnnotationTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/annotations/types/{annotation_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"annotation_type"+"}", url.PathEscape(parameterValueToString(r.annotationType, "annotationType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	eventType string
	eventSubtype string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetExecute(r)
}

/*
MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet Retrieve Document Event SubType Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventType The event type. For example, distribution__v.
 @param eventSubtype The event subtype. For example, approved_email__v.
 @return ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet(ctx context.Context, eventType string, eventSubtype string) ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest {
	return ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest{
		ApiService: a,
		ctx: ctx,
		eventType: eventType,
		eventSubtype: eventSubtype,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetExecute(r ApiMetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/events/{event_type}/types/{event_subtype}"
	localVarPath = strings.Replace(localVarPath, "{"+"event_type"+"}", url.PathEscape(parameterValueToString(r.eventType, "eventType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event_subtype"+"}", url.PathEscape(parameterValueToString(r.eventSubtype, "eventSubtype")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsEventsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsEventsGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsEventsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsEventsGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsEventsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsEventsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsEventsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsEventsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsEventsGetExecute(r)
}

/*
MetadataObjectsDocumentsEventsGet Retrieve Document Event Types and Subtypes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsDocumentsEventsGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsEventsGet(ctx context.Context) ApiMetadataObjectsDocumentsEventsGetRequest {
	return ApiMetadataObjectsDocumentsEventsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsEventsGetExecute(r ApiMetadataObjectsDocumentsEventsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsEventsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsLockGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsLockGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsLockGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsLockGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsLockGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsLockGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsLockGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsLockGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsLockGetExecute(r)
}

/*
MetadataObjectsDocumentsLockGet Retrieve Document Lock Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsDocumentsLockGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsLockGet(ctx context.Context) ApiMetadataObjectsDocumentsLockGetRequest {
	return ApiMetadataObjectsDocumentsLockGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsLockGetExecute(r ApiMetadataObjectsDocumentsLockGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsLockGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/lock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	contentType *string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest) ContentType(contentType string) ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest) Accept(accept string) ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest {
	r.accept = &accept
	return r
}

func (r ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsPropertiesFindCommonPostExecute(r)
}

/*
MetadataObjectsDocumentsPropertiesFindCommonPost Retrieve Common Document Fields

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsPropertiesFindCommonPost(ctx context.Context) ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest {
	return ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsPropertiesFindCommonPostExecute(r ApiMetadataObjectsDocumentsPropertiesFindCommonPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsPropertiesFindCommonPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/properties/find_common"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsPropertiesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsPropertiesGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsPropertiesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsPropertiesGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsPropertiesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsPropertiesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsPropertiesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsPropertiesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsPropertiesGetExecute(r)
}

/*
MetadataObjectsDocumentsPropertiesGet Retrieve All Document Fields

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsDocumentsPropertiesGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsPropertiesGet(ctx context.Context) ApiMetadataObjectsDocumentsPropertiesGetRequest {
	return ApiMetadataObjectsDocumentsPropertiesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsPropertiesGetExecute(r ApiMetadataObjectsDocumentsPropertiesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsPropertiesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/properties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsTemplatesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsTemplatesGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsTemplatesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsTemplatesGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsTemplatesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsTemplatesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsTemplatesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsTemplatesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsTemplatesGetExecute(r)
}

/*
MetadataObjectsDocumentsTemplatesGet Retrieve Document Template Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsDocumentsTemplatesGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsTemplatesGet(ctx context.Context) ApiMetadataObjectsDocumentsTemplatesGetRequest {
	return ApiMetadataObjectsDocumentsTemplatesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsTemplatesGetExecute(r ApiMetadataObjectsDocumentsTemplatesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsTemplatesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsTypesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsTypesGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsTypesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsTypesGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsTypesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsTypesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsTypesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsTypesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsTypesGetExecute(r)
}

/*
MetadataObjectsDocumentsTypesGet Retrieve All Document Types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsDocumentsTypesGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesGet(ctx context.Context) ApiMetadataObjectsDocumentsTypesGetRequest {
	return ApiMetadataObjectsDocumentsTypesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesGetExecute(r ApiMetadataObjectsDocumentsTypesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsTypesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsTypesTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	type_ string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsTypesTypeGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsTypesTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsTypesTypeGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsTypesTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsTypesTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsTypesTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsTypesTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsTypesTypeGetExecute(r)
}

/*
MetadataObjectsDocumentsTypesTypeGet Retrieve Document Type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ The document type. See Retrieve Document Types.
 @return ApiMetadataObjectsDocumentsTypesTypeGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesTypeGet(ctx context.Context, type_ string) ApiMetadataObjectsDocumentsTypesTypeGetRequest {
	return ApiMetadataObjectsDocumentsTypesTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesTypeGetExecute(r ApiMetadataObjectsDocumentsTypesTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsTypesTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/types/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	type_ string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsTypesTypeRelationshipsGetExecute(r)
}

/*
MetadataObjectsDocumentsTypesTypeRelationshipsGet Retrieve Document Type Relationships

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ The document type. See Retrieve Document Types.
 @return ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesTypeRelationshipsGet(ctx context.Context, type_ string) ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest {
	return ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesTypeRelationshipsGetExecute(r ApiMetadataObjectsDocumentsTypesTypeRelationshipsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsTypesTypeRelationshipsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/types/{type}/relationships"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	type_ string
	subtype string
	classification string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetExecute(r)
}

/*
MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet Retrieve Document Classification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ The document type. See Retrieve Document Types.
 @param subtype The document subtype. See Retrieve Document Types.
 @param classification The document classification. See Retrieve Document Types.
 @return ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet(ctx context.Context, type_ string, subtype string, classification string) ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest {
	return ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
		subtype: subtype,
		classification: classification,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetExecute(r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/types/{type}/subtypes/{subtype}/classifications/{classification}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subtype"+"}", url.PathEscape(parameterValueToString(r.subtype, "subtype")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"classification"+"}", url.PathEscape(parameterValueToString(r.classification, "classification")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	type_ string
	subtype string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest) Authorization(authorization string) ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest) Accept(accept string) ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetExecute(r)
}

/*
MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGet Retrieve Document Subtype

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ The document type. See Retrieve Document Types.
 @param subtype The document subtype. See Retrieve Document Types.
 @return ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGet(ctx context.Context, type_ string, subtype string) ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest {
	return ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
		subtype: subtype,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetExecute(r ApiMetadataObjectsDocumentsTypesTypeSubtypesSubtypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsDocumentsTypesTypeSubtypesSubtypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/documents/types/{type}/subtypes/{subtype}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subtype"+"}", url.PathEscape(parameterValueToString(r.subtype, "subtype")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsGroupsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsGroupsGetRequest) Authorization(authorization string) ApiMetadataObjectsGroupsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsGroupsGetRequest) Accept(accept string) ApiMetadataObjectsGroupsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsGroupsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsGroupsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsGroupsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsGroupsGetExecute(r)
}

/*
MetadataObjectsGroupsGet Retrieve Group Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsGroupsGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsGroupsGet(ctx context.Context) ApiMetadataObjectsGroupsGetRequest {
	return ApiMetadataObjectsGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsGroupsGetExecute(r ApiMetadataObjectsGroupsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsGroupsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsSecuritypoliciesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsSecuritypoliciesGetRequest) Authorization(authorization string) ApiMetadataObjectsSecuritypoliciesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsSecuritypoliciesGetRequest) Accept(accept string) ApiMetadataObjectsSecuritypoliciesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsSecuritypoliciesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsSecuritypoliciesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsSecuritypoliciesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsSecuritypoliciesGetExecute(r)
}

/*
MetadataObjectsSecuritypoliciesGet Retrieve Security Policy Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsSecuritypoliciesGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsSecuritypoliciesGet(ctx context.Context) ApiMetadataObjectsSecuritypoliciesGetRequest {
	return ApiMetadataObjectsSecuritypoliciesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsSecuritypoliciesGetExecute(r ApiMetadataObjectsSecuritypoliciesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsSecuritypoliciesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/securitypolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataObjectsUsersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataObjectsUsersGetRequest) Authorization(authorization string) ApiMetadataObjectsUsersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataObjectsUsersGetRequest) Accept(accept string) ApiMetadataObjectsUsersGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataObjectsUsersGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataObjectsUsersGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataObjectsUsersGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataObjectsUsersGetExecute(r)
}

/*
MetadataObjectsUsersGet Retrieve User Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataObjectsUsersGetRequest
*/
func (a *DefaultAPIService) MetadataObjectsUsersGet(ctx context.Context) ApiMetadataObjectsUsersGetRequest {
	return ApiMetadataObjectsUsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataObjectsUsersGetExecute(r ApiMetadataObjectsUsersGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataObjectsUsersGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/objects/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest) Authorization(authorization string) ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest) Accept(accept string) ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetExecute(r)
}

/*
MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGet Retrieve Archived Document Signature Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest
*/
func (a *DefaultAPIService) MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGet(ctx context.Context) ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest {
	return ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetExecute(r ApiMetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/query/archived_documents/relationships/document_signature__sysr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest) Authorization(authorization string) ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest) Accept(accept string) ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetExecute(r)
}

/*
MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGet Retrieve Document Signature Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest
*/
func (a *DefaultAPIService) MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGet(ctx context.Context) ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest {
	return ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetExecute(r ApiMetadataQueryDocumentsRelationshipsDocumentSignatureSysrGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataQueryDocumentsRelationshipsDocumentSignatureSysrGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/query/documents/relationships/document_signature__sysr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataVobjectsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	loc *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// To retrieve localized (translated) strings, include the parameter loc&#x3D;true. See the next request below for details.
func (r ApiMetadataVobjectsGetRequest) Loc(loc bool) ApiMetadataVobjectsGetRequest {
	r.loc = &loc
	return r
}

func (r ApiMetadataVobjectsGetRequest) Authorization(authorization string) ApiMetadataVobjectsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataVobjectsGetRequest) Accept(accept string) ApiMetadataVobjectsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataVobjectsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataVobjectsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataVobjectsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataVobjectsGetExecute(r)
}

/*
MetadataVobjectsGet Retrieve Object Collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataVobjectsGetRequest
*/
func (a *DefaultAPIService) MetadataVobjectsGet(ctx context.Context) ApiMetadataVobjectsGetRequest {
	return ApiMetadataVobjectsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataVobjectsGetExecute(r ApiMetadataVobjectsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataVobjectsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/vobjects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest) Authorization(authorization string) ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest) Accept(accept string) ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataVobjectsObjectNameActionsCanceldeploymentPostExecute(r)
}

/*
MetadataVobjectsObjectNameActionsCanceldeploymentPost Cancel Raw Object Deployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName
 @return ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest
*/
func (a *DefaultAPIService) MetadataVobjectsObjectNameActionsCanceldeploymentPost(ctx context.Context, objectName string) ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest {
	return ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataVobjectsObjectNameActionsCanceldeploymentPostExecute(r ApiMetadataVobjectsObjectNameActionsCanceldeploymentPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataVobjectsObjectNameActionsCanceldeploymentPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/vobjects/{object_name}/actions/canceldeployment"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectFieldName string
	loc *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// To retrieve localized (translated) strings, include the parameter loc&#x3D;true. See the next request below for details.
func (r ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest) Loc(loc bool) ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest {
	r.loc = &loc
	return r
}

func (r ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest) Authorization(authorization string) ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest) Accept(accept string) ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataVobjectsObjectNameFieldsObjectFieldNameGetExecute(r)
}

/*
MetadataVobjectsObjectNameFieldsObjectFieldNameGet Retrieve Object Field Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectFieldName The object field name value (id, name__v, external_id__v, etc.).
 @return ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest
*/
func (a *DefaultAPIService) MetadataVobjectsObjectNameFieldsObjectFieldNameGet(ctx context.Context, objectName string, objectFieldName string) ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest {
	return ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectFieldName: objectFieldName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataVobjectsObjectNameFieldsObjectFieldNameGetExecute(r ApiMetadataVobjectsObjectNameFieldsObjectFieldNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataVobjectsObjectNameFieldsObjectFieldNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/vobjects/{object_name}/fields/{object_field_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_field_name"+"}", url.PathEscape(parameterValueToString(r.objectFieldName, "objectFieldName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataVobjectsObjectNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	loc *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// To retrieve localized (translated) strings, include the parameter loc&#x3D;true. See the next request below for details.
func (r ApiMetadataVobjectsObjectNameGetRequest) Loc(loc bool) ApiMetadataVobjectsObjectNameGetRequest {
	r.loc = &loc
	return r
}

func (r ApiMetadataVobjectsObjectNameGetRequest) Authorization(authorization string) ApiMetadataVobjectsObjectNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataVobjectsObjectNameGetRequest) Accept(accept string) ApiMetadataVobjectsObjectNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataVobjectsObjectNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataVobjectsObjectNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataVobjectsObjectNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataVobjectsObjectNameGetExecute(r)
}

/*
MetadataVobjectsObjectNameGet Retrieve Object Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @return ApiMetadataVobjectsObjectNameGetRequest
*/
func (a *DefaultAPIService) MetadataVobjectsObjectNameGet(ctx context.Context, objectName string) ApiMetadataVobjectsObjectNameGetRequest {
	return ApiMetadataVobjectsObjectNameGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataVobjectsObjectNameGetExecute(r ApiMetadataVobjectsObjectNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataVobjectsObjectNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/vobjects/{object_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataVobjectsObjectNamePageLayoutsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataVobjectsObjectNamePageLayoutsGetRequest) Authorization(authorization string) ApiMetadataVobjectsObjectNamePageLayoutsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataVobjectsObjectNamePageLayoutsGetRequest) Accept(accept string) ApiMetadataVobjectsObjectNamePageLayoutsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataVobjectsObjectNamePageLayoutsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataVobjectsObjectNamePageLayoutsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataVobjectsObjectNamePageLayoutsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataVobjectsObjectNamePageLayoutsGetExecute(r)
}

/*
MetadataVobjectsObjectNamePageLayoutsGet Retrieve Page Layouts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName
 @return ApiMetadataVobjectsObjectNamePageLayoutsGetRequest
*/
func (a *DefaultAPIService) MetadataVobjectsObjectNamePageLayoutsGet(ctx context.Context, objectName string) ApiMetadataVobjectsObjectNamePageLayoutsGetRequest {
	return ApiMetadataVobjectsObjectNamePageLayoutsGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataVobjectsObjectNamePageLayoutsGetExecute(r ApiMetadataVobjectsObjectNamePageLayoutsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataVobjectsObjectNamePageLayoutsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/vobjects/{object_name}/page_layouts"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	layoutName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest) Authorization(authorization string) ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest) Accept(accept string) ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataVobjectsObjectNamePageLayoutsLayoutNameGetExecute(r)
}

/*
MetadataVobjectsObjectNamePageLayoutsLayoutNameGet Retrieve Page Layout Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The name of the object from which to retrieve page layout metadata.
 @param layoutName The name of the page layout from which to retrieve metadata.
 @return ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest
*/
func (a *DefaultAPIService) MetadataVobjectsObjectNamePageLayoutsLayoutNameGet(ctx context.Context, objectName string, layoutName string) ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest {
	return ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		layoutName: layoutName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) MetadataVobjectsObjectNamePageLayoutsLayoutNameGetExecute(r ApiMetadataVobjectsObjectNamePageLayoutsLayoutNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.MetadataVobjectsObjectNamePageLayoutsLayoutNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata/vobjects/{object_name}/page_layouts/{layout_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"layout_name"+"}", url.PathEscape(parameterValueToString(r.layoutName, "layoutName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiNotificationsHistoriesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	startDate *string
	endDate *string
	allDates *bool
	formatResult *string
	limit *string
	offset *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Specify a start date to retrieve notification history. This date cannot be more than 2 years ago. Dates must be in YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. If time is omitted (THH:mm:ssZ), defaults to the start of the day. If start_date is omitted entirely, defaults to the start of the previous day. If you’ve specified a start_date, you must also specify an end_date.
func (r ApiNotificationsHistoriesGetRequest) StartDate(startDate string) ApiNotificationsHistoriesGetRequest {
	r.startDate = &startDate
	return r
}

// Specify an end date to retrieve notification history. This date cannot be more than 30 days away from the specified start_date. Dates must be in YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. If time is omitted (THH:mm:ssZ), defaults to the time of the API request. If you’ve specified an end_date, you must also specify a start_date.
func (r ApiNotificationsHistoriesGetRequest) EndDate(endDate string) ApiNotificationsHistoriesGetRequest {
	r.endDate = &endDate
	return r
}

// Set to true to request notification history for all dates. This is the same as requesting a full CSV export from the Vault UI. When requesting a full notification history, you must leave start_date and end_date blank and set format_result to csv. You can request an export of notification history for all_dates once every 24 hours.
func (r ApiNotificationsHistoriesGetRequest) AllDates(allDates bool) ApiNotificationsHistoriesGetRequest {
	r.allDates = &allDates
	return r
}

// To request a downloadable CSV file of your notification history, set this parameter to csv. The response contains a jobId to retrieve the job status, which provides a link to download the CSV file. If omitted, the API returns a JSON response with notification history and does not start a job. If all_dates is true, this parameter must be csv.
func (r ApiNotificationsHistoriesGetRequest) FormatResult(formatResult string) ApiNotificationsHistoriesGetRequest {
	r.formatResult = &formatResult
	return r
}

// Paginate the results by specifying the maximum number of histories per page in the response. This can be any value between 1 and 1000. If omitted, defaults to 200.
func (r ApiNotificationsHistoriesGetRequest) Limit(limit string) ApiNotificationsHistoriesGetRequest {
	r.limit = &limit
	return r
}

// Paginate the results displayed per page by specifying the amount of offset from the entry returned. If omitted, defaults to 0.
func (r ApiNotificationsHistoriesGetRequest) Offset(offset string) ApiNotificationsHistoriesGetRequest {
	r.offset = &offset
	return r
}

func (r ApiNotificationsHistoriesGetRequest) Authorization(authorization string) ApiNotificationsHistoriesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiNotificationsHistoriesGetRequest) Accept(accept string) ApiNotificationsHistoriesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiNotificationsHistoriesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiNotificationsHistoriesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiNotificationsHistoriesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.NotificationsHistoriesGetExecute(r)
}

/*
NotificationsHistoriesGet Retrieve Email Notification Histories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNotificationsHistoriesGetRequest
*/
func (a *DefaultAPIService) NotificationsHistoriesGet(ctx context.Context) ApiNotificationsHistoriesGetRequest {
	return ApiNotificationsHistoriesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) NotificationsHistoriesGetExecute(r ApiNotificationsHistoriesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.NotificationsHistoriesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/histories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.allDates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all_dates", r.allDates, "form", "")
	}
	if r.formatResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format_result", r.formatResult, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectWorkflowActionsActionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	action string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectWorkflowActionsActionGetRequest) Authorization(authorization string) ApiObjectWorkflowActionsActionGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectWorkflowActionsActionGetRequest) Accept(accept string) ApiObjectWorkflowActionsActionGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectWorkflowActionsActionGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectWorkflowActionsActionGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectWorkflowActionsActionGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectWorkflowActionsActionGetExecute(r)
}

/*
ObjectWorkflowActionsActionGet Retrieve Bulk Workflow Action Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param action
 @return ApiObjectWorkflowActionsActionGetRequest
*/
func (a *DefaultAPIService) ObjectWorkflowActionsActionGet(ctx context.Context, action string) ApiObjectWorkflowActionsActionGetRequest {
	return ApiObjectWorkflowActionsActionGetRequest{
		ApiService: a,
		ctx: ctx,
		action: action,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectWorkflowActionsActionGetExecute(r ApiObjectWorkflowActionsActionGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectWorkflowActionsActionGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/object/workflow/actions/{action}"
	localVarPath = strings.Replace(localVarPath, "{"+"action"+"}", url.PathEscape(parameterValueToString(r.action, "action")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectWorkflowActionsActionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	action string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectWorkflowActionsActionPostRequest) Authorization(authorization string) ApiObjectWorkflowActionsActionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectWorkflowActionsActionPostRequest) Accept(accept string) ApiObjectWorkflowActionsActionPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectWorkflowActionsActionPostRequest) ContentType(contentType string) ApiObjectWorkflowActionsActionPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectWorkflowActionsActionPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectWorkflowActionsActionPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectWorkflowActionsActionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectWorkflowActionsActionPostExecute(r)
}

/*
ObjectWorkflowActionsActionPost Initiate Workflow Actions on Multiple Workflows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param action
 @return ApiObjectWorkflowActionsActionPostRequest
*/
func (a *DefaultAPIService) ObjectWorkflowActionsActionPost(ctx context.Context, action string) ApiObjectWorkflowActionsActionPostRequest {
	return ApiObjectWorkflowActionsActionPostRequest{
		ApiService: a,
		ctx: ctx,
		action: action,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectWorkflowActionsActionPostExecute(r ApiObjectWorkflowActionsActionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectWorkflowActionsActionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/object/workflow/actions/{action}"
	localVarPath = strings.Replace(localVarPath, "{"+"action"+"}", url.PathEscape(parameterValueToString(r.action, "action")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectWorkflowActionsCanceltasksPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectWorkflowActionsCanceltasksPostRequest) Authorization(authorization string) ApiObjectWorkflowActionsCanceltasksPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectWorkflowActionsCanceltasksPostRequest) Accept(accept string) ApiObjectWorkflowActionsCanceltasksPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectWorkflowActionsCanceltasksPostRequest) ContentType(contentType string) ApiObjectWorkflowActionsCanceltasksPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectWorkflowActionsCanceltasksPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectWorkflowActionsCanceltasksPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectWorkflowActionsCanceltasksPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectWorkflowActionsCanceltasksPostExecute(r)
}

/*
ObjectWorkflowActionsCanceltasksPost Cancel Workflow Tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectWorkflowActionsCanceltasksPostRequest
*/
func (a *DefaultAPIService) ObjectWorkflowActionsCanceltasksPost(ctx context.Context) ApiObjectWorkflowActionsCanceltasksPostRequest {
	return ApiObjectWorkflowActionsCanceltasksPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectWorkflowActionsCanceltasksPostExecute(r ApiObjectWorkflowActionsCanceltasksPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectWorkflowActionsCanceltasksPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/object/workflow/actions/canceltasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectWorkflowActionsCancelworkflowsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectWorkflowActionsCancelworkflowsPostRequest) Authorization(authorization string) ApiObjectWorkflowActionsCancelworkflowsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectWorkflowActionsCancelworkflowsPostRequest) Accept(accept string) ApiObjectWorkflowActionsCancelworkflowsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectWorkflowActionsCancelworkflowsPostRequest) ContentType(contentType string) ApiObjectWorkflowActionsCancelworkflowsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectWorkflowActionsCancelworkflowsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectWorkflowActionsCancelworkflowsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectWorkflowActionsCancelworkflowsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectWorkflowActionsCancelworkflowsPostExecute(r)
}

/*
ObjectWorkflowActionsCancelworkflowsPost Cancel Workflows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectWorkflowActionsCancelworkflowsPostRequest
*/
func (a *DefaultAPIService) ObjectWorkflowActionsCancelworkflowsPost(ctx context.Context) ApiObjectWorkflowActionsCancelworkflowsPostRequest {
	return ApiObjectWorkflowActionsCancelworkflowsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectWorkflowActionsCancelworkflowsPostExecute(r ApiObjectWorkflowActionsCancelworkflowsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectWorkflowActionsCancelworkflowsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/object/workflow/actions/cancelworkflows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectWorkflowActionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectWorkflowActionsGetRequest) Authorization(authorization string) ApiObjectWorkflowActionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectWorkflowActionsGetRequest) Accept(accept string) ApiObjectWorkflowActionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectWorkflowActionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectWorkflowActionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectWorkflowActionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectWorkflowActionsGetExecute(r)
}

/*
ObjectWorkflowActionsGet Retrieve Bulk Workflow Actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectWorkflowActionsGetRequest
*/
func (a *DefaultAPIService) ObjectWorkflowActionsGet(ctx context.Context) ApiObjectWorkflowActionsGetRequest {
	return ApiObjectWorkflowActionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectWorkflowActionsGetExecute(r ApiObjectWorkflowActionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectWorkflowActionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/object/workflow/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectWorkflowActionsReassigntasksPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectWorkflowActionsReassigntasksPostRequest) Authorization(authorization string) ApiObjectWorkflowActionsReassigntasksPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectWorkflowActionsReassigntasksPostRequest) Accept(accept string) ApiObjectWorkflowActionsReassigntasksPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectWorkflowActionsReassigntasksPostRequest) ContentType(contentType string) ApiObjectWorkflowActionsReassigntasksPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectWorkflowActionsReassigntasksPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectWorkflowActionsReassigntasksPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectWorkflowActionsReassigntasksPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectWorkflowActionsReassigntasksPostExecute(r)
}

/*
ObjectWorkflowActionsReassigntasksPost Reassign Workflow Tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectWorkflowActionsReassigntasksPostRequest
*/
func (a *DefaultAPIService) ObjectWorkflowActionsReassigntasksPost(ctx context.Context) ApiObjectWorkflowActionsReassigntasksPostRequest {
	return ApiObjectWorkflowActionsReassigntasksPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectWorkflowActionsReassigntasksPostExecute(r ApiObjectWorkflowActionsReassigntasksPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectWorkflowActionsReassigntasksPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/object/workflow/actions/reassigntasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectWorkflowActionsReplaceworkflowownerPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectWorkflowActionsReplaceworkflowownerPostRequest) Authorization(authorization string) ApiObjectWorkflowActionsReplaceworkflowownerPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectWorkflowActionsReplaceworkflowownerPostRequest) Accept(accept string) ApiObjectWorkflowActionsReplaceworkflowownerPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectWorkflowActionsReplaceworkflowownerPostRequest) ContentType(contentType string) ApiObjectWorkflowActionsReplaceworkflowownerPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectWorkflowActionsReplaceworkflowownerPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectWorkflowActionsReplaceworkflowownerPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectWorkflowActionsReplaceworkflowownerPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectWorkflowActionsReplaceworkflowownerPostExecute(r)
}

/*
ObjectWorkflowActionsReplaceworkflowownerPost Replace Workflow Owner

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectWorkflowActionsReplaceworkflowownerPostRequest
*/
func (a *DefaultAPIService) ObjectWorkflowActionsReplaceworkflowownerPost(ctx context.Context) ApiObjectWorkflowActionsReplaceworkflowownerPostRequest {
	return ApiObjectWorkflowActionsReplaceworkflowownerPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectWorkflowActionsReplaceworkflowownerPostExecute(r ApiObjectWorkflowActionsReplaceworkflowownerPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectWorkflowActionsReplaceworkflowownerPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/object/workflow/actions/replaceworkflowowner"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersActionsExportJobIdResultsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersActionsExportJobIdResultsGetRequest) Authorization(authorization string) ApiObjectsBindersActionsExportJobIdResultsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersActionsExportJobIdResultsGetRequest) Accept(accept string) ApiObjectsBindersActionsExportJobIdResultsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersActionsExportJobIdResultsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersActionsExportJobIdResultsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersActionsExportJobIdResultsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersActionsExportJobIdResultsGetExecute(r)
}

/*
ObjectsBindersActionsExportJobIdResultsGet Retrieve Binder Export Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The id value of the requested export job. This is returned with the export binder requests above.
 @return ApiObjectsBindersActionsExportJobIdResultsGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersActionsExportJobIdResultsGet(ctx context.Context, jobId string) ApiObjectsBindersActionsExportJobIdResultsGetRequest {
	return ApiObjectsBindersActionsExportJobIdResultsGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersActionsExportJobIdResultsGetExecute(r ApiObjectsBindersActionsExportJobIdResultsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersActionsExportJobIdResultsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/actions/export/{job_id}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdActionsExportPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	source *bool
	renditiontype *string
	docversion *string
	attachments *string
	export *string
	docfield *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// to include source content or not
func (r ApiObjectsBindersBinderIdActionsExportPostRequest) Source(source bool) ApiObjectsBindersBinderIdActionsExportPostRequest {
	r.source = &source
	return r
}

// to include viewable renditions
func (r ApiObjectsBindersBinderIdActionsExportPostRequest) Renditiontype(renditiontype string) ApiObjectsBindersBinderIdActionsExportPostRequest {
	r.renditiontype = &renditiontype
	return r
}

// to include all major versions
func (r ApiObjectsBindersBinderIdActionsExportPostRequest) Docversion(docversion string) ApiObjectsBindersBinderIdActionsExportPostRequest {
	r.docversion = &docversion
	return r
}

// to include all versions of attachments
func (r ApiObjectsBindersBinderIdActionsExportPostRequest) Attachments(attachments string) ApiObjectsBindersBinderIdActionsExportPostRequest {
	r.attachments = &attachments
	return r
}

// configurable filename metadata
func (r ApiObjectsBindersBinderIdActionsExportPostRequest) Export(export string) ApiObjectsBindersBinderIdActionsExportPostRequest {
	r.export = &export
	return r
}

// to exclude document metadata csv
func (r ApiObjectsBindersBinderIdActionsExportPostRequest) Docfield(docfield bool) ApiObjectsBindersBinderIdActionsExportPostRequest {
	r.docfield = &docfield
	return r
}

func (r ApiObjectsBindersBinderIdActionsExportPostRequest) Authorization(authorization string) ApiObjectsBindersBinderIdActionsExportPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdActionsExportPostRequest) Accept(accept string) ApiObjectsBindersBinderIdActionsExportPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdActionsExportPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdActionsExportPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdActionsExportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdActionsExportPostExecute(r)
}

/*
ObjectsBindersBinderIdActionsExportPost Export Binder (Latest Version)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdActionsExportPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdActionsExportPost(ctx context.Context, binderId string) ApiObjectsBindersBinderIdActionsExportPostRequest {
	return ApiObjectsBindersBinderIdActionsExportPostRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdActionsExportPostExecute(r ApiObjectsBindersBinderIdActionsExportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdActionsExportPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/actions/export"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	}
	if r.renditiontype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "renditiontype", r.renditiontype, "form", "")
	}
	if r.docversion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docversion", r.docversion, "form", "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "form", "")
	}
	if r.export != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "export", r.export, "form", "")
	}
	if r.docfield != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docfield", r.docfield, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdActionsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdActionsPostRequest) Authorization(authorization string) ApiObjectsBindersBinderIdActionsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdActionsPostRequest) ContentType(contentType string) ApiObjectsBindersBinderIdActionsPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersBinderIdActionsPostRequest) Accept(accept string) ApiObjectsBindersBinderIdActionsPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdActionsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdActionsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdActionsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdActionsPostExecute(r)
}

/*
ObjectsBindersBinderIdActionsPost Refresh Binder Auto-Filing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdActionsPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdActionsPost(ctx context.Context, binderId string) ApiObjectsBindersBinderIdActionsPostRequest {
	return ApiObjectsBindersBinderIdActionsPostRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdActionsPostExecute(r ApiObjectsBindersBinderIdActionsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdActionsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdBindingRulePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	contentType *string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdBindingRulePutRequest) ContentType(contentType string) ApiObjectsBindersBinderIdBindingRulePutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersBinderIdBindingRulePutRequest) Accept(accept string) ApiObjectsBindersBinderIdBindingRulePutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersBinderIdBindingRulePutRequest) Authorization(authorization string) ApiObjectsBindersBinderIdBindingRulePutRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdBindingRulePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdBindingRulePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdBindingRulePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdBindingRulePutExecute(r)
}

/*
ObjectsBindersBinderIdBindingRulePut Update Binding Rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdBindingRulePutRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdBindingRulePut(ctx context.Context, binderId string) ApiObjectsBindersBinderIdBindingRulePutRequest {
	return ApiObjectsBindersBinderIdBindingRulePutRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdBindingRulePutExecute(r ApiObjectsBindersBinderIdBindingRulePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdBindingRulePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/binding_rule"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdDeleteRequest) Authorization(authorization string) ApiObjectsBindersBinderIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdDeleteRequest) Accept(accept string) ApiObjectsBindersBinderIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdDeleteExecute(r)
}

/*
ObjectsBindersBinderIdDelete Delete Binder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdDelete(ctx context.Context, binderId string) ApiObjectsBindersBinderIdDeleteRequest {
	return ApiObjectsBindersBinderIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdDeleteExecute(r ApiObjectsBindersBinderIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	nodeId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest) Authorization(authorization string) ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest) ContentType(contentType string) ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest) Accept(accept string) ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutExecute(r)
}

/*
ObjectsBindersBinderIdDocumentsNodeIdBindingRulePut Update Binder Document Binding Rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param nodeId The binder node id field value.
 @return ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdDocumentsNodeIdBindingRulePut(ctx context.Context, binderId string, nodeId string) ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest {
	return ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdDocumentsNodeIdBindingRulePutExecute(r ApiObjectsBindersBinderIdDocumentsNodeIdBindingRulePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdDocumentsNodeIdBindingRulePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/documents/{node_id}/binding_rule"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdDocumentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdDocumentsPostRequest) Authorization(authorization string) ApiObjectsBindersBinderIdDocumentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsPostRequest) ContentType(contentType string) ApiObjectsBindersBinderIdDocumentsPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsPostRequest) Accept(accept string) ApiObjectsBindersBinderIdDocumentsPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdDocumentsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdDocumentsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdDocumentsPostExecute(r)
}

/*
ObjectsBindersBinderIdDocumentsPost Add Document to Binder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdDocumentsPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdDocumentsPost(ctx context.Context, binderId string) ApiObjectsBindersBinderIdDocumentsPostRequest {
	return ApiObjectsBindersBinderIdDocumentsPostRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdDocumentsPostExecute(r ApiObjectsBindersBinderIdDocumentsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdDocumentsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	sectionId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest) Authorization(authorization string) ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest) Accept(accept string) ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdDocumentsSectionIdDeleteExecute(r)
}

/*
ObjectsBindersBinderIdDocumentsSectionIdDelete Remove Document from Binder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param sectionId The binder node id field value.
 @return ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdDocumentsSectionIdDelete(ctx context.Context, binderId string, sectionId string) ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest {
	return ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		sectionId: sectionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdDocumentsSectionIdDeleteExecute(r ApiObjectsBindersBinderIdDocumentsSectionIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdDocumentsSectionIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/documents/{section_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"section_id"+"}", url.PathEscape(parameterValueToString(r.sectionId, "sectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	sectionId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest) Authorization(authorization string) ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest) ContentType(contentType string) ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest) Accept(accept string) ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdDocumentsSectionIdPutExecute(r)
}

/*
ObjectsBindersBinderIdDocumentsSectionIdPut Move Document in Binder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param sectionId The binder node id field value.
 @return ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdDocumentsSectionIdPut(ctx context.Context, binderId string, sectionId string) ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest {
	return ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		sectionId: sectionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdDocumentsSectionIdPutExecute(r ApiObjectsBindersBinderIdDocumentsSectionIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdDocumentsSectionIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/documents/{section_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"section_id"+"}", url.PathEscape(parameterValueToString(r.sectionId, "sectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	depth *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// To retrieve all information in all levels of the binder, set this to all. By default, only one level is returned.
func (r ApiObjectsBindersBinderIdGetRequest) Depth(depth string) ApiObjectsBindersBinderIdGetRequest {
	r.depth = &depth
	return r
}

func (r ApiObjectsBindersBinderIdGetRequest) Authorization(authorization string) ApiObjectsBindersBinderIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdGetRequest) Accept(accept string) ApiObjectsBindersBinderIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdGetExecute(r)
}

/*
ObjectsBindersBinderIdGet Retrieve Binder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdGet(ctx context.Context, binderId string) ApiObjectsBindersBinderIdGetRequest {
	return ApiObjectsBindersBinderIdGetRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdGetExecute(r ApiObjectsBindersBinderIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.depth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "depth", r.depth, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdPostRequest) Authorization(authorization string) ApiObjectsBindersBinderIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdPostRequest) Accept(accept string) ApiObjectsBindersBinderIdPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdPostExecute(r)
}

/*
ObjectsBindersBinderIdPost Create Binder Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdPost(ctx context.Context, binderId string) ApiObjectsBindersBinderIdPostRequest {
	return ApiObjectsBindersBinderIdPostRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdPostExecute(r ApiObjectsBindersBinderIdPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdPutRequest) Authorization(authorization string) ApiObjectsBindersBinderIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdPutRequest) ContentType(contentType string) ApiObjectsBindersBinderIdPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersBinderIdPutRequest) Accept(accept string) ApiObjectsBindersBinderIdPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdPutExecute(r)
}

/*
ObjectsBindersBinderIdPut Update Binder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdPutRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdPut(ctx context.Context, binderId string) ApiObjectsBindersBinderIdPutRequest {
	return ApiObjectsBindersBinderIdPutRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdPutExecute(r ApiObjectsBindersBinderIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	roleNameAndUserOrGroup string
	id string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest) Authorization(authorization string) ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest) Accept(accept string) ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteExecute(r)
}

/*
ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete Remove Users & Groups from Roles on a Single Binder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The id value of the binder from which to remove roles.
 @param roleNameAndUserOrGroup The name of the role from which to remove the user or group followed by either `user` or `group`. The format is `{role_name}.{user_or_group}`. For example, `consumer__v.user`.
 @param id The id value of the user or group to remove from the role.
 @return ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete(ctx context.Context, binderId string, roleNameAndUserOrGroup string, id string) ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
	return ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		roleNameAndUserOrGroup: roleNameAndUserOrGroup,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteExecute(r ApiObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/roles/{role_name_and_user_or_group}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role_name_and_user_or_group"+"}", url.PathEscape(parameterValueToString(r.roleNameAndUserOrGroup, "roleNameAndUserOrGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	nodeId string
	contentType *string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest) ContentType(contentType string) ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest) Accept(accept string) ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest) Authorization(authorization string) ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdSectionsNodeIdBindingRulePutExecute(r)
}

/*
ObjectsBindersBinderIdSectionsNodeIdBindingRulePut Update Binder Section Binding Rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param nodeId The binder node id field value.
 @return ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsNodeIdBindingRulePut(ctx context.Context, binderId string, nodeId string) ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest {
	return ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsNodeIdBindingRulePutExecute(r ApiObjectsBindersBinderIdSectionsNodeIdBindingRulePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdSectionsNodeIdBindingRulePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/sections/{node_id}/binding_rule"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdSectionsNodeIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	nodeId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdSectionsNodeIdPutRequest) Authorization(authorization string) ApiObjectsBindersBinderIdSectionsNodeIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdSectionsNodeIdPutRequest) Accept(accept string) ApiObjectsBindersBinderIdSectionsNodeIdPutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersBinderIdSectionsNodeIdPutRequest) ContentType(contentType string) ApiObjectsBindersBinderIdSectionsNodeIdPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdSectionsNodeIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdSectionsNodeIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdSectionsNodeIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdSectionsNodeIdPutExecute(r)
}

/*
ObjectsBindersBinderIdSectionsNodeIdPut Update Binder Section

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param nodeId The binder node id of the section.
 @return ApiObjectsBindersBinderIdSectionsNodeIdPutRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsNodeIdPut(ctx context.Context, binderId string, nodeId string) ApiObjectsBindersBinderIdSectionsNodeIdPutRequest {
	return ApiObjectsBindersBinderIdSectionsNodeIdPutRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsNodeIdPutExecute(r ApiObjectsBindersBinderIdSectionsNodeIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdSectionsNodeIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/sections/{node_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"node_id"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdSectionsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdSectionsPostRequest) Authorization(authorization string) ApiObjectsBindersBinderIdSectionsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdSectionsPostRequest) Accept(accept string) ApiObjectsBindersBinderIdSectionsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersBinderIdSectionsPostRequest) ContentType(contentType string) ApiObjectsBindersBinderIdSectionsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdSectionsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdSectionsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdSectionsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdSectionsPostExecute(r)
}

/*
ObjectsBindersBinderIdSectionsPost Create Binder Section

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdSectionsPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsPost(ctx context.Context, binderId string) ApiObjectsBindersBinderIdSectionsPostRequest {
	return ApiObjectsBindersBinderIdSectionsPostRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsPostExecute(r ApiObjectsBindersBinderIdSectionsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdSectionsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/sections"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	sectionId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest) Authorization(authorization string) ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest) Accept(accept string) ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest) ContentType(contentType string) ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdSectionsSectionIdDeleteExecute(r)
}

/*
ObjectsBindersBinderIdSectionsSectionIdDelete Delete Binder Section

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param sectionId The binder node id field value.
 @return ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsSectionIdDelete(ctx context.Context, binderId string, sectionId string) ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest {
	return ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		sectionId: sectionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsSectionIdDeleteExecute(r ApiObjectsBindersBinderIdSectionsSectionIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdSectionsSectionIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/sections/{section_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"section_id"+"}", url.PathEscape(parameterValueToString(r.sectionId, "sectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdSectionsSectionIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	sectionId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdSectionsSectionIdGetRequest) Authorization(authorization string) ApiObjectsBindersBinderIdSectionsSectionIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdSectionsSectionIdGetRequest) Accept(accept string) ApiObjectsBindersBinderIdSectionsSectionIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdSectionsSectionIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdSectionsSectionIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdSectionsSectionIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdSectionsSectionIdGetExecute(r)
}

/*
ObjectsBindersBinderIdSectionsSectionIdGet Retrieve Binder Sections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param sectionId The binder node id field value.
 @return ApiObjectsBindersBinderIdSectionsSectionIdGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsSectionIdGet(ctx context.Context, binderId string, sectionId string) ApiObjectsBindersBinderIdSectionsSectionIdGetRequest {
	return ApiObjectsBindersBinderIdSectionsSectionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		sectionId: sectionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdSectionsSectionIdGetExecute(r ApiObjectsBindersBinderIdSectionsSectionIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdSectionsSectionIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/sections/{section_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"section_id"+"}", url.PathEscape(parameterValueToString(r.sectionId, "sectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdVersionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdVersionsGetRequest) Authorization(authorization string) ApiObjectsBindersBinderIdVersionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdVersionsGetRequest) Accept(accept string) ApiObjectsBindersBinderIdVersionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdVersionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdVersionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdVersionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdVersionsGetExecute(r)
}

/*
ObjectsBindersBinderIdVersionsGet Retrieve All Binder Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @return ApiObjectsBindersBinderIdVersionsGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsGet(ctx context.Context, binderId string) ApiObjectsBindersBinderIdVersionsGetRequest {
	return ApiObjectsBindersBinderIdVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsGetExecute(r ApiObjectsBindersBinderIdVersionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdVersionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	majorVersion string
	minorVersion string
	source *bool
	renditiontype *string
	docversion *string
	attachments *string
	export *string
	docfield *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// to include source content or not
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) Source(source bool) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	r.source = &source
	return r
}

// to include viewable renditions
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) Renditiontype(renditiontype string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	r.renditiontype = &renditiontype
	return r
}

// to include all major versions
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) Docversion(docversion string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	r.docversion = &docversion
	return r
}

// to include all versions of attachments
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) Attachments(attachments string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	r.attachments = &attachments
	return r
}

// configurable filename metadata
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) Export(export string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	r.export = &export
	return r
}

// to exclude document metadata csv
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) Docfield(docfield bool) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	r.docfield = &docfield
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) Authorization(authorization string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) Accept(accept string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostExecute(r)
}

/*
ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost Export Binder (Specific Version)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param majorVersion The binder major_version_number__v field value.
 @param minorVersion The binder minor_version_number__v field value.
 @return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost(ctx context.Context, binderId string, majorVersion string, minorVersion string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest {
	return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostExecute(r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	}
	if r.renditiontype != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "renditiontype", r.renditiontype, "form", "")
	}
	if r.docversion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docversion", r.docversion, "form", "")
	}
	if r.attachments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attachments", r.attachments, "form", "")
	}
	if r.export != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "export", r.export, "form", "")
	}
	if r.docfield != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "docfield", r.docfield, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest) Authorization(authorization string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest) Accept(accept string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteExecute(r)
}

/*
ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDelete Delete Binder Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param majorVersion The binder major_version_number__v field value.
 @param minorVersion The binder minor_version_number__v field value.
 @return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDelete(ctx context.Context, binderId string, majorVersion string, minorVersion string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest {
	return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteExecute(r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest) Authorization(authorization string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest) Accept(accept string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetExecute(r)
}

/*
ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGet Retrieve Binder Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param majorVersion The binder major_version_number__v field value.
 @param minorVersion The binder minor_version_number__v field value.
 @return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGet(ctx context.Context, binderId string, majorVersion string, minorVersion string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest {
	return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetExecute(r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	majorVersion string
	minorVersion string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest) Authorization(authorization string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest) ContentType(contentType string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest) Accept(accept string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutExecute(r)
}

/*
ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPut Update Binder Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param majorVersion The binder major_version_number__v field value.
 @param minorVersion The binder minor_version_number__v field value.
 @return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPut(ctx context.Context, binderId string, majorVersion string, minorVersion string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest {
	return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutExecute(r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/versions/{major_version}/{minor_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	majorVersion string
	minorVersion string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) Authorization(authorization string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) ContentType(contentType string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) Accept(accept string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostExecute(r)
}

/*
ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost Create Binder Relationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param majorVersion The binder major_version_number__v field value.
 @param minorVersion The binder minor_version_number__v field value.
 @return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost(ctx context.Context, binderId string, majorVersion string, minorVersion string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostExecute(r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	majorVersion string
	minorVersion string
	relationshipId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) Authorization(authorization string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) Accept(accept string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteExecute(r)
}

/*
ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete Delete Binder Relationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param majorVersion The binder major_version_number__v field value.
 @param minorVersion The binder minor_version_number__v field value.
 @param relationshipId The binder relationship id field value.
 @return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(ctx context.Context, binderId string, majorVersion string, minorVersion string, relationshipId string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
	return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		relationshipId: relationshipId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteExecute(r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relationship_id"+"}", url.PathEscape(parameterValueToString(r.relationshipId, "relationshipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	majorVersion string
	minorVersion string
	relationshipId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) Authorization(authorization string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) Accept(accept string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetExecute(r)
}

/*
ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet Retrieve Binder Relationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param majorVersion The binder major_version_number__v field value.
 @param minorVersion The binder minor_version_number__v field value.
 @param relationshipId The binder relationship id field value.
 @return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(ctx context.Context, binderId string, majorVersion string, minorVersion string, relationshipId string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
	return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		relationshipId: relationshipId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetExecute(r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relationship_id"+"}", url.PathEscape(parameterValueToString(r.relationshipId, "relationshipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	binderId string
	majorVersion string
	minorVersion string
	sectionId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest) Authorization(authorization string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest) Accept(accept string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetExecute(r)
}

/*
ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet Retrieve Binder Version Section

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param binderId The binder id field value.
 @param majorVersion The binder major_version_number__v field value.
 @param minorVersion The binder minor_version_number__v field value.
 @param sectionId Retrieve all sections (documents and subsections) in a binder’s sub-level node. If not included, all sections from the binder’s top-level root node will be returned.
 @return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet(ctx context.Context, binderId string, majorVersion string, minorVersion string, sectionId string) ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest {
	return ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		binderId: binderId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		sectionId: sectionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetExecute(r ApiObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/sections/{section_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"binder_id"+"}", url.PathEscape(parameterValueToString(r.binderId, "binderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"section_id"+"}", url.PathEscape(parameterValueToString(r.sectionId, "sectionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersIdRolesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersIdRolesGetRequest) Authorization(authorization string) ApiObjectsBindersIdRolesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersIdRolesGetRequest) Accept(accept string) ApiObjectsBindersIdRolesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersIdRolesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersIdRolesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersIdRolesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersIdRolesGetExecute(r)
}

/*
ObjectsBindersIdRolesGet Retrieve All Binder Roles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiObjectsBindersIdRolesGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersIdRolesGet(ctx context.Context, id string) ApiObjectsBindersIdRolesGetRequest {
	return ApiObjectsBindersIdRolesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersIdRolesGetExecute(r ApiObjectsBindersIdRolesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersIdRolesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{id}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersIdRolesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersIdRolesPostRequest) Authorization(authorization string) ApiObjectsBindersIdRolesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersIdRolesPostRequest) Accept(accept string) ApiObjectsBindersIdRolesPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersIdRolesPostRequest) ContentType(contentType string) ApiObjectsBindersIdRolesPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersIdRolesPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersIdRolesPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersIdRolesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersIdRolesPostExecute(r)
}

/*
ObjectsBindersIdRolesPost Assign Users & Groups to Roles on a Single Binder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiObjectsBindersIdRolesPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersIdRolesPost(ctx context.Context, id string) ApiObjectsBindersIdRolesPostRequest {
	return ApiObjectsBindersIdRolesPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersIdRolesPostExecute(r ApiObjectsBindersIdRolesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersIdRolesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{id}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersIdRolesRoleNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	roleName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersIdRolesRoleNameGetRequest) Authorization(authorization string) ApiObjectsBindersIdRolesRoleNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersIdRolesRoleNameGetRequest) Accept(accept string) ApiObjectsBindersIdRolesRoleNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersIdRolesRoleNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersIdRolesRoleNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersIdRolesRoleNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersIdRolesRoleNameGetExecute(r)
}

/*
ObjectsBindersIdRolesRoleNameGet Retrieve Document Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The binder `id`.
 @param roleName The name of the role to retrieve. For example, `owner__v`.
 @return ApiObjectsBindersIdRolesRoleNameGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersIdRolesRoleNameGet(ctx context.Context, id string, roleName string) ApiObjectsBindersIdRolesRoleNameGetRequest {
	return ApiObjectsBindersIdRolesRoleNameGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersIdRolesRoleNameGetExecute(r ApiObjectsBindersIdRolesRoleNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersIdRolesRoleNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{id}/roles/{role_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) Authorization(authorization string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) Accept(accept string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetExecute(r)
}

/*
ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet Retrieve Binder User Actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The binder id field value from which to retrieve available user actions.
 @param majorVersion The major version number of the binder.
 @param minorVersion The minor version number of the binder.
 @return ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet(ctx context.Context, id string, majorVersion string, minorVersion string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
	return ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetExecute(r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	majorVersion string
	minorVersion string
	nameV string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) Authorization(authorization string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) Accept(accept string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetExecute(r)
}

/*
ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet Retrieve Binder Entry Criteria

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The binder id field value from which to retrieve available user actions.
 @param majorVersion The major version number of the binder.
 @param minorVersion The minor version number of the binder.
 @param nameV The lifecycle name__v field value from which to retrieve entry criteria. This is retrieved from the Retrieve User Actions request above.
 @return ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(ctx context.Context, id string, majorVersion string, minorVersion string, nameV string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
	return ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		nameV: nameV,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetExecute(r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name__v"+"}", url.PathEscape(parameterValueToString(r.nameV, "nameV")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	majorVersion string
	minorVersion string
	nameV string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) Authorization(authorization string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) ContentType(contentType string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) Accept(accept string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutExecute(r)
}

/*
ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut Initiate Binder User Action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The binder id field value from which to retrieve available user actions.
 @param majorVersion The major version number of the binder.
 @param minorVersion The minor version number of the binder.
 @param nameV The action name__v field value to initiate. This is retrieved from the Retrieve User Action request.
 @return ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest
*/
func (a *DefaultAPIService) ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(ctx context.Context, id string, majorVersion string, minorVersion string, nameV string) ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	return ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		nameV: nameV,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutExecute(r ApiObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name__v"+"}", url.PathEscape(parameterValueToString(r.nameV, "nameV")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersLifecycleActionsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersLifecycleActionsPostRequest) Authorization(authorization string) ApiObjectsBindersLifecycleActionsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersLifecycleActionsPostRequest) Accept(accept string) ApiObjectsBindersLifecycleActionsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersLifecycleActionsPostRequest) ContentType(contentType string) ApiObjectsBindersLifecycleActionsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersLifecycleActionsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersLifecycleActionsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersLifecycleActionsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersLifecycleActionsPostExecute(r)
}

/*
ObjectsBindersLifecycleActionsPost Retrieve User Actions on Multiple Binders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsBindersLifecycleActionsPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersLifecycleActionsPost(ctx context.Context) ApiObjectsBindersLifecycleActionsPostRequest {
	return ApiObjectsBindersLifecycleActionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersLifecycleActionsPostExecute(r ApiObjectsBindersLifecycleActionsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersLifecycleActionsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/lifecycle_actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersLifecycleActionsUserActionNamePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	userActionName string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersLifecycleActionsUserActionNamePutRequest) Authorization(authorization string) ApiObjectsBindersLifecycleActionsUserActionNamePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersLifecycleActionsUserActionNamePutRequest) ContentType(contentType string) ApiObjectsBindersLifecycleActionsUserActionNamePutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersLifecycleActionsUserActionNamePutRequest) Accept(accept string) ApiObjectsBindersLifecycleActionsUserActionNamePutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersLifecycleActionsUserActionNamePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersLifecycleActionsUserActionNamePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersLifecycleActionsUserActionNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersLifecycleActionsUserActionNamePutExecute(r)
}

/*
ObjectsBindersLifecycleActionsUserActionNamePut Initiate Bulk Binder User Actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userActionName The user action name__v field value. Find this value with the Retrieve User Actions on Multiple Binders endpoint.
 @return ApiObjectsBindersLifecycleActionsUserActionNamePutRequest
*/
func (a *DefaultAPIService) ObjectsBindersLifecycleActionsUserActionNamePut(ctx context.Context, userActionName string) ApiObjectsBindersLifecycleActionsUserActionNamePutRequest {
	return ApiObjectsBindersLifecycleActionsUserActionNamePutRequest{
		ApiService: a,
		ctx: ctx,
		userActionName: userActionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersLifecycleActionsUserActionNamePutExecute(r ApiObjectsBindersLifecycleActionsUserActionNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersLifecycleActionsUserActionNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/lifecycle_actions/{user_action_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_action_name"+"}", url.PathEscape(parameterValueToString(r.userActionName, "userActionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	async *bool
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

// When creating a binder, the binder metadata is indexed synchronously by default. To process the indexing asynchronously, include a query parameter async set to true (objects/binders?async&#x3D;true). This helps speed up the response time from Vault when processing large amounts of data. 
func (r ApiObjectsBindersPostRequest) Async(async bool) ApiObjectsBindersPostRequest {
	r.async = &async
	return r
}

func (r ApiObjectsBindersPostRequest) Authorization(authorization string) ApiObjectsBindersPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersPostRequest) ContentType(contentType string) ApiObjectsBindersPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsBindersPostRequest) Accept(accept string) ApiObjectsBindersPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersPostExecute(r)
}

/*
ObjectsBindersPost Create Binder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsBindersPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersPost(ctx context.Context) ApiObjectsBindersPostRequest {
	return ApiObjectsBindersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersPostExecute(r ApiObjectsBindersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "async", r.async, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersTemplatesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersTemplatesGetRequest) Authorization(authorization string) ApiObjectsBindersTemplatesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersTemplatesGetRequest) Accept(accept string) ApiObjectsBindersTemplatesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersTemplatesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersTemplatesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersTemplatesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersTemplatesGetExecute(r)
}

/*
ObjectsBindersTemplatesGet Retrieve Binder Template Collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsBindersTemplatesGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersTemplatesGet(ctx context.Context) ApiObjectsBindersTemplatesGetRequest {
	return ApiObjectsBindersTemplatesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersTemplatesGetExecute(r ApiObjectsBindersTemplatesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersTemplatesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersTemplatesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersTemplatesPostRequest) Authorization(authorization string) ApiObjectsBindersTemplatesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersTemplatesPostRequest) Accept(accept string) ApiObjectsBindersTemplatesPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersTemplatesPostRequest) ContentType(contentType string) ApiObjectsBindersTemplatesPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersTemplatesPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersTemplatesPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersTemplatesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersTemplatesPostExecute(r)
}

/*
ObjectsBindersTemplatesPost Create Binder Template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsBindersTemplatesPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersTemplatesPost(ctx context.Context) ApiObjectsBindersTemplatesPostRequest {
	return ApiObjectsBindersTemplatesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersTemplatesPostExecute(r ApiObjectsBindersTemplatesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersTemplatesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersTemplatesPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersTemplatesPutRequest) Authorization(authorization string) ApiObjectsBindersTemplatesPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersTemplatesPutRequest) Accept(accept string) ApiObjectsBindersTemplatesPutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersTemplatesPutRequest) ContentType(contentType string) ApiObjectsBindersTemplatesPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersTemplatesPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersTemplatesPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersTemplatesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersTemplatesPutExecute(r)
}

/*
ObjectsBindersTemplatesPut Update Binder Template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsBindersTemplatesPutRequest
*/
func (a *DefaultAPIService) ObjectsBindersTemplatesPut(ctx context.Context) ApiObjectsBindersTemplatesPutRequest {
	return ApiObjectsBindersTemplatesPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersTemplatesPutExecute(r ApiObjectsBindersTemplatesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersTemplatesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	templateName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest) Authorization(authorization string) ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest) Accept(accept string) ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersTemplatesTemplateNameBindernodesGetExecute(r)
}

/*
ObjectsBindersTemplatesTemplateNameBindernodesGet Retrieve Binder Template Node Attributes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateName The binder template name__v field value.
 @return ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameBindernodesGet(ctx context.Context, templateName string) ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest {
	return ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest{
		ApiService: a,
		ctx: ctx,
		templateName: templateName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameBindernodesGetExecute(r ApiObjectsBindersTemplatesTemplateNameBindernodesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersTemplatesTemplateNameBindernodesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/templates/{template_name}/bindernodes"
	localVarPath = strings.Replace(localVarPath, "{"+"template_name"+"}", url.PathEscape(parameterValueToString(r.templateName, "templateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	templateName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest) Authorization(authorization string) ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest) Accept(accept string) ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest) ContentType(contentType string) ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersTemplatesTemplateNameBindernodesPostExecute(r)
}

/*
ObjectsBindersTemplatesTemplateNameBindernodesPost Create Binder Template Node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateName The binder template name__v field value.
 @return ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest
*/
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameBindernodesPost(ctx context.Context, templateName string) ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest {
	return ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest{
		ApiService: a,
		ctx: ctx,
		templateName: templateName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameBindernodesPostExecute(r ApiObjectsBindersTemplatesTemplateNameBindernodesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersTemplatesTemplateNameBindernodesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/templates/{template_name}/bindernodes"
	localVarPath = strings.Replace(localVarPath, "{"+"template_name"+"}", url.PathEscape(parameterValueToString(r.templateName, "templateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	templateName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest) Authorization(authorization string) ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest) Accept(accept string) ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest) ContentType(contentType string) ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersTemplatesTemplateNameBindernodesPutExecute(r)
}

/*
ObjectsBindersTemplatesTemplateNameBindernodesPut Replace Binder Template Nodes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateName The binder template name__v field value.
 @return ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest
*/
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameBindernodesPut(ctx context.Context, templateName string) ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest {
	return ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest{
		ApiService: a,
		ctx: ctx,
		templateName: templateName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameBindernodesPutExecute(r ApiObjectsBindersTemplatesTemplateNameBindernodesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersTemplatesTemplateNameBindernodesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/templates/{template_name}/bindernodes"
	localVarPath = strings.Replace(localVarPath, "{"+"template_name"+"}", url.PathEscape(parameterValueToString(r.templateName, "templateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersTemplatesTemplateNameDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	templateName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersTemplatesTemplateNameDeleteRequest) Authorization(authorization string) ApiObjectsBindersTemplatesTemplateNameDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameDeleteRequest) Accept(accept string) ApiObjectsBindersTemplatesTemplateNameDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersTemplatesTemplateNameDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersTemplatesTemplateNameDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersTemplatesTemplateNameDeleteExecute(r)
}

/*
ObjectsBindersTemplatesTemplateNameDelete Delete Binder Template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateName The binder template name__v field value.
 @return ApiObjectsBindersTemplatesTemplateNameDeleteRequest
*/
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameDelete(ctx context.Context, templateName string) ApiObjectsBindersTemplatesTemplateNameDeleteRequest {
	return ApiObjectsBindersTemplatesTemplateNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		templateName: templateName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameDeleteExecute(r ApiObjectsBindersTemplatesTemplateNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersTemplatesTemplateNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/templates/{template_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_name"+"}", url.PathEscape(parameterValueToString(r.templateName, "templateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsBindersTemplatesTemplateNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	templateName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsBindersTemplatesTemplateNameGetRequest) Authorization(authorization string) ApiObjectsBindersTemplatesTemplateNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameGetRequest) Accept(accept string) ApiObjectsBindersTemplatesTemplateNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsBindersTemplatesTemplateNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsBindersTemplatesTemplateNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsBindersTemplatesTemplateNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsBindersTemplatesTemplateNameGetExecute(r)
}

/*
ObjectsBindersTemplatesTemplateNameGet Retrieve Binder Template Attributes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateName The binder template name__v field value.
 @return ApiObjectsBindersTemplatesTemplateNameGetRequest
*/
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameGet(ctx context.Context, templateName string) ApiObjectsBindersTemplatesTemplateNameGetRequest {
	return ApiObjectsBindersTemplatesTemplateNameGetRequest{
		ApiService: a,
		ctx: ctx,
		templateName: templateName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsBindersTemplatesTemplateNameGetExecute(r ApiObjectsBindersTemplatesTemplateNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsBindersTemplatesTemplateNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/binders/templates/{template_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_name"+"}", url.PathEscape(parameterValueToString(r.templateName, "templateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDeletionsDocumentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	startDate *string
	endDate *string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

// Specify a date (no more than 30 days past) after which Vault will look for deleted documents. Dates must be YYYY-MM-DDTHH:MM:SSZ format, for example, 7AM on January 15, 2016 would use 2016-01-15T07:00:00Z
func (r ApiObjectsDeletionsDocumentsGetRequest) StartDate(startDate string) ApiObjectsDeletionsDocumentsGetRequest {
	r.startDate = &startDate
	return r
}

// Specify a date (no more than 30 days past) before which Vault will look for deleted documents. Dates must be YYYY-MM-DDTHH:MM:SSZ format, for example, 7AM on January 15, 2016 would use 2016-01-15T07:00:00Z 
func (r ApiObjectsDeletionsDocumentsGetRequest) EndDate(endDate string) ApiObjectsDeletionsDocumentsGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiObjectsDeletionsDocumentsGetRequest) Authorization(authorization string) ApiObjectsDeletionsDocumentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDeletionsDocumentsGetRequest) ContentType(contentType string) ApiObjectsDeletionsDocumentsGetRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDeletionsDocumentsGetRequest) Accept(accept string) ApiObjectsDeletionsDocumentsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDeletionsDocumentsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDeletionsDocumentsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDeletionsDocumentsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDeletionsDocumentsGetExecute(r)
}

/*
ObjectsDeletionsDocumentsGet Retrieve Deleted Document IDs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDeletionsDocumentsGetRequest
*/
func (a *DefaultAPIService) ObjectsDeletionsDocumentsGet(ctx context.Context) ApiObjectsDeletionsDocumentsGetRequest {
	return ApiObjectsDeletionsDocumentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDeletionsDocumentsGetExecute(r ApiObjectsDeletionsDocumentsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDeletionsDocumentsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/deletions/documents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDeletionsVobjectsObjectNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDeletionsVobjectsObjectNameGetRequest) Authorization(authorization string) ApiObjectsDeletionsVobjectsObjectNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDeletionsVobjectsObjectNameGetRequest) Accept(accept string) ApiObjectsDeletionsVobjectsObjectNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDeletionsVobjectsObjectNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDeletionsVobjectsObjectNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDeletionsVobjectsObjectNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDeletionsVobjectsObjectNameGetExecute(r)
}

/*
ObjectsDeletionsVobjectsObjectNameGet Retrieve Deleted Object Record ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @return ApiObjectsDeletionsVobjectsObjectNameGetRequest
*/
func (a *DefaultAPIService) ObjectsDeletionsVobjectsObjectNameGet(ctx context.Context, objectName string) ApiObjectsDeletionsVobjectsObjectNameGetRequest {
	return ApiObjectsDeletionsVobjectsObjectNameGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDeletionsVobjectsObjectNameGetExecute(r ApiObjectsDeletionsVobjectsObjectNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDeletionsVobjectsObjectNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/deletions/vobjects/{object_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsActionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	loc *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When localized (translated) strings are available, retrieve them by setting loc to true.
func (r ApiObjectsDocumentsActionsGetRequest) Loc(loc bool) ApiObjectsDocumentsActionsGetRequest {
	r.loc = &loc
	return r
}

func (r ApiObjectsDocumentsActionsGetRequest) Authorization(authorization string) ApiObjectsDocumentsActionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsActionsGetRequest) Accept(accept string) ApiObjectsDocumentsActionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsActionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsActionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsActionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsActionsGetExecute(r)
}

/*
ObjectsDocumentsActionsGet Retrieve All Document Workflows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsActionsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsActionsGet(ctx context.Context) ApiObjectsDocumentsActionsGetRequest {
	return ApiObjectsDocumentsActionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsActionsGetExecute(r ApiObjectsDocumentsActionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsActionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	lifecycleAndStateAndAction string
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest) Authorization(authorization string) ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest) Accept(accept string) ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetExecute(r)
}

/*
ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet Download Controlled Copy Job Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lifecycleAndStateAndAction The `name__v` values for the lifecycle, state, and action in the format `{lifecycle_name}.{state_name}.{action_name}`. To get this value, [Retrieve the Job Status](https://developer.veevavault.com/api/24.3#RetrieveJobStatus) and find the `href` under the `artifacts` link.
 @param jobId
 @return ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet(ctx context.Context, lifecycleAndStateAndAction string, jobId string) ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest {
	return ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest{
		ApiService: a,
		ctx: ctx,
		lifecycleAndStateAndAction: lifecycleAndStateAndAction,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetExecute(r ApiObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/actions/{lifecycle_and_state_and_action}/{job_id}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"lifecycle_and_state_and_action"+"}", url.PathEscape(parameterValueToString(r.lifecycleAndStateAndAction, "lifecycleAndStateAndAction")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsActionsWorkflowNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	workflowName string
	loc *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When localized (translated) strings are available, retrieve them by setting loc to true.
func (r ApiObjectsDocumentsActionsWorkflowNameGetRequest) Loc(loc bool) ApiObjectsDocumentsActionsWorkflowNameGetRequest {
	r.loc = &loc
	return r
}

func (r ApiObjectsDocumentsActionsWorkflowNameGetRequest) Authorization(authorization string) ApiObjectsDocumentsActionsWorkflowNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsActionsWorkflowNameGetRequest) Accept(accept string) ApiObjectsDocumentsActionsWorkflowNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsActionsWorkflowNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsActionsWorkflowNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsActionsWorkflowNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsActionsWorkflowNameGetExecute(r)
}

/*
ObjectsDocumentsActionsWorkflowNameGet Retrieve Document Workflow Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowName The document workflow name value.
 @return ApiObjectsDocumentsActionsWorkflowNameGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsActionsWorkflowNameGet(ctx context.Context, workflowName string) ApiObjectsDocumentsActionsWorkflowNameGetRequest {
	return ApiObjectsDocumentsActionsWorkflowNameGetRequest{
		ApiService: a,
		ctx: ctx,
		workflowName: workflowName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsActionsWorkflowNameGetExecute(r ApiObjectsDocumentsActionsWorkflowNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsActionsWorkflowNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/actions/{workflow_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_name"+"}", url.PathEscape(parameterValueToString(r.workflowName, "workflowName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsActionsWorkflowNamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	workflowName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsActionsWorkflowNamePostRequest) Authorization(authorization string) ApiObjectsDocumentsActionsWorkflowNamePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsActionsWorkflowNamePostRequest) Accept(accept string) ApiObjectsDocumentsActionsWorkflowNamePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsActionsWorkflowNamePostRequest) ContentType(contentType string) ApiObjectsDocumentsActionsWorkflowNamePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsActionsWorkflowNamePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsActionsWorkflowNamePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsActionsWorkflowNamePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsActionsWorkflowNamePostExecute(r)
}

/*
ObjectsDocumentsActionsWorkflowNamePost Initiate Document Workflow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowName The document workflow name value.
 @return ApiObjectsDocumentsActionsWorkflowNamePostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsActionsWorkflowNamePost(ctx context.Context, workflowName string) ApiObjectsDocumentsActionsWorkflowNamePostRequest {
	return ApiObjectsDocumentsActionsWorkflowNamePostRequest{
		ApiService: a,
		ctx: ctx,
		workflowName: workflowName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsActionsWorkflowNamePostExecute(r ApiObjectsDocumentsActionsWorkflowNamePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsActionsWorkflowNamePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/actions/{workflow_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_name"+"}", url.PathEscape(parameterValueToString(r.workflowName, "workflowName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsAnnotationsBatchDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsAnnotationsBatchDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsAnnotationsBatchDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsAnnotationsBatchDeleteRequest) Accept(accept string) ApiObjectsDocumentsAnnotationsBatchDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsAnnotationsBatchDeleteRequest) ContentType(contentType string) ApiObjectsDocumentsAnnotationsBatchDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsAnnotationsBatchDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsAnnotationsBatchDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsAnnotationsBatchDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsAnnotationsBatchDeleteExecute(r)
}

/*
ObjectsDocumentsAnnotationsBatchDelete Delete Annotations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsAnnotationsBatchDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsAnnotationsBatchDelete(ctx context.Context) ApiObjectsDocumentsAnnotationsBatchDeleteRequest {
	return ApiObjectsDocumentsAnnotationsBatchDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsAnnotationsBatchDeleteExecute(r ApiObjectsDocumentsAnnotationsBatchDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsAnnotationsBatchDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/annotations/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsAnnotationsBatchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsAnnotationsBatchPostRequest) Authorization(authorization string) ApiObjectsDocumentsAnnotationsBatchPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsAnnotationsBatchPostRequest) ContentType(contentType string) ApiObjectsDocumentsAnnotationsBatchPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsAnnotationsBatchPostRequest) Accept(accept string) ApiObjectsDocumentsAnnotationsBatchPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsAnnotationsBatchPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsAnnotationsBatchPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsAnnotationsBatchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsAnnotationsBatchPostExecute(r)
}

/*
ObjectsDocumentsAnnotationsBatchPost Create Multiple Annotations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsAnnotationsBatchPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsAnnotationsBatchPost(ctx context.Context) ApiObjectsDocumentsAnnotationsBatchPostRequest {
	return ApiObjectsDocumentsAnnotationsBatchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsAnnotationsBatchPostExecute(r ApiObjectsDocumentsAnnotationsBatchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsAnnotationsBatchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/annotations/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if strlen(*r.authorization) < 0 {
		return nil, reportError("authorization must have at least 0 elements")
	}
	if strlen(*r.authorization) > 0 {
		return nil, reportError("authorization must have less than 0 elements")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if strlen(*r.contentType) < 0 {
		return nil, reportError("contentType must have at least 0 elements")
	}
	if strlen(*r.contentType) > 0 {
		return nil, reportError("contentType must have less than 0 elements")
	}
	if r.accept == nil {
		return nil, reportError("accept is required and must be specified")
	}
	if strlen(*r.accept) < 0 {
		return nil, reportError("accept must have at least 0 elements")
	}
	if strlen(*r.accept) > 0 {
		return nil, reportError("accept must have less than 0 elements")
	}
	if r.xVaultAPIClientID == nil {
		return nil, reportError("xVaultAPIClientID is required and must be specified")
	}
	if strlen(*r.xVaultAPIClientID) < 0 {
		return nil, reportError("xVaultAPIClientID must have at least 0 elements")
	}
	if strlen(*r.xVaultAPIClientID) > 0 {
		return nil, reportError("xVaultAPIClientID must have less than 0 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsAnnotationsBatchPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsAnnotationsBatchPutRequest) Authorization(authorization string) ApiObjectsDocumentsAnnotationsBatchPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsAnnotationsBatchPutRequest) ContentType(contentType string) ApiObjectsDocumentsAnnotationsBatchPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsAnnotationsBatchPutRequest) Accept(accept string) ApiObjectsDocumentsAnnotationsBatchPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsAnnotationsBatchPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsAnnotationsBatchPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsAnnotationsBatchPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsAnnotationsBatchPutExecute(r)
}

/*
ObjectsDocumentsAnnotationsBatchPut Update Annotations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsAnnotationsBatchPutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsAnnotationsBatchPut(ctx context.Context) ApiObjectsDocumentsAnnotationsBatchPutRequest {
	return ApiObjectsDocumentsAnnotationsBatchPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsAnnotationsBatchPutExecute(r ApiObjectsDocumentsAnnotationsBatchPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsAnnotationsBatchPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/annotations/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest) Authorization(authorization string) ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest) ContentType(contentType string) ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest) Accept(accept string) ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsAnnotationsRepliesBatchPostExecute(r)
}

/*
ObjectsDocumentsAnnotationsRepliesBatchPost Add Annotation Replies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsAnnotationsRepliesBatchPost(ctx context.Context) ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest {
	return ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsAnnotationsRepliesBatchPostExecute(r ApiObjectsDocumentsAnnotationsRepliesBatchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsAnnotationsRepliesBatchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/annotations/replies/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsAttachmentsBatchDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	accept *string
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsAttachmentsBatchDeleteRequest) Accept(accept string) ApiObjectsDocumentsAttachmentsBatchDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsAttachmentsBatchDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsAttachmentsBatchDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsAttachmentsBatchDeleteRequest) ContentType(contentType string) ApiObjectsDocumentsAttachmentsBatchDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsAttachmentsBatchDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsAttachmentsBatchDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsAttachmentsBatchDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsAttachmentsBatchDeleteExecute(r)
}

/*
ObjectsDocumentsAttachmentsBatchDelete Delete Multiple Document Attachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsAttachmentsBatchDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsAttachmentsBatchDelete(ctx context.Context) ApiObjectsDocumentsAttachmentsBatchDeleteRequest {
	return ApiObjectsDocumentsAttachmentsBatchDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsAttachmentsBatchDeleteExecute(r ApiObjectsDocumentsAttachmentsBatchDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsAttachmentsBatchDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/attachments/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsAttachmentsBatchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	accept *string
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsAttachmentsBatchPostRequest) Accept(accept string) ApiObjectsDocumentsAttachmentsBatchPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsAttachmentsBatchPostRequest) Authorization(authorization string) ApiObjectsDocumentsAttachmentsBatchPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsAttachmentsBatchPostRequest) ContentType(contentType string) ApiObjectsDocumentsAttachmentsBatchPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsAttachmentsBatchPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsAttachmentsBatchPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsAttachmentsBatchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsAttachmentsBatchPostExecute(r)
}

/*
ObjectsDocumentsAttachmentsBatchPost Create Multiple Document Attachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsAttachmentsBatchPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsAttachmentsBatchPost(ctx context.Context) ApiObjectsDocumentsAttachmentsBatchPostRequest {
	return ApiObjectsDocumentsAttachmentsBatchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsAttachmentsBatchPostExecute(r ApiObjectsDocumentsAttachmentsBatchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsAttachmentsBatchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/attachments/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsAttachmentsBatchPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	accept *string
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsAttachmentsBatchPutRequest) Accept(accept string) ApiObjectsDocumentsAttachmentsBatchPutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsAttachmentsBatchPutRequest) Authorization(authorization string) ApiObjectsDocumentsAttachmentsBatchPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsAttachmentsBatchPutRequest) ContentType(contentType string) ApiObjectsDocumentsAttachmentsBatchPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsAttachmentsBatchPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsAttachmentsBatchPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsAttachmentsBatchPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsAttachmentsBatchPutExecute(r)
}

/*
ObjectsDocumentsAttachmentsBatchPut Update Multiple Document Attachment Descriptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsAttachmentsBatchPutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsAttachmentsBatchPut(ctx context.Context) ApiObjectsDocumentsAttachmentsBatchPutRequest {
	return ApiObjectsDocumentsAttachmentsBatchPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsAttachmentsBatchPutExecute(r ApiObjectsDocumentsAttachmentsBatchPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsAttachmentsBatchPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/attachments/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest) Authorization(authorization string) ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest) Accept(accept string) ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsBatchActionsFileextractJobIdResultsGetExecute(r)
}

/*
ObjectsDocumentsBatchActionsFileextractJobIdResultsGet Retrieve Document Export Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The id value of the requested export job. This is returned with the export document requests.
 @return ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsBatchActionsFileextractJobIdResultsGet(ctx context.Context, jobId string) ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest {
	return ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsBatchActionsFileextractJobIdResultsGetExecute(r ApiObjectsDocumentsBatchActionsFileextractJobIdResultsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsBatchActionsFileextractJobIdResultsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/batch/actions/fileextract/{job_id}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsBatchActionsFileextractPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	source *bool
	renditions *bool
	allversions *bool
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: To exclude source files, include a query parameter source&#x3D;false. If omitted, defaults to true.
func (r ApiObjectsDocumentsBatchActionsFileextractPostRequest) Source(source bool) ApiObjectsDocumentsBatchActionsFileextractPostRequest {
	r.source = &source
	return r
}

// Optional: To include renditions, include a query parameter renditions&#x3D;true. If omitted, defaults to false.
func (r ApiObjectsDocumentsBatchActionsFileextractPostRequest) Renditions(renditions bool) ApiObjectsDocumentsBatchActionsFileextractPostRequest {
	r.renditions = &renditions
	return r
}

// Optional: To include all versions or latest version, include a query parameter allversions&#x3D;true. If omitted, defaults to false.
func (r ApiObjectsDocumentsBatchActionsFileextractPostRequest) Allversions(allversions bool) ApiObjectsDocumentsBatchActionsFileextractPostRequest {
	r.allversions = &allversions
	return r
}

func (r ApiObjectsDocumentsBatchActionsFileextractPostRequest) Authorization(authorization string) ApiObjectsDocumentsBatchActionsFileextractPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsBatchActionsFileextractPostRequest) ContentType(contentType string) ApiObjectsDocumentsBatchActionsFileextractPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsBatchActionsFileextractPostRequest) Accept(accept string) ApiObjectsDocumentsBatchActionsFileextractPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsBatchActionsFileextractPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsBatchActionsFileextractPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsBatchActionsFileextractPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsBatchActionsFileextractPostExecute(r)
}

/*
ObjectsDocumentsBatchActionsFileextractPost Export Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsBatchActionsFileextractPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsBatchActionsFileextractPost(ctx context.Context) ApiObjectsDocumentsBatchActionsFileextractPostRequest {
	return ApiObjectsDocumentsBatchActionsFileextractPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsBatchActionsFileextractPostExecute(r ApiObjectsDocumentsBatchActionsFileextractPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsBatchActionsFileextractPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/batch/actions/fileextract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	}
	if r.renditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "renditions", r.renditions, "form", "")
	}
	if r.allversions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allversions", r.allversions, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsBatchActionsReclassifyPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIMigrationMode *bool
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsBatchActionsReclassifyPutRequest) Authorization(authorization string) ApiObjectsDocumentsBatchActionsReclassifyPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsBatchActionsReclassifyPutRequest) ContentType(contentType string) ApiObjectsDocumentsBatchActionsReclassifyPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsBatchActionsReclassifyPutRequest) Accept(accept string) ApiObjectsDocumentsBatchActionsReclassifyPutRequest {
	r.accept = &accept
	return r
}

// When set to true, Vault allows you to manually set the document number and to update documents to any lifecycle state using the status__v field. All other Document Migration Mode overrides available at document creation are ignored, but do not generate an error message.  You must have the Document Migration permission to use this header. Learn more about &lt;a href&#x3D;\&quot;https://platform.veevavault.help/en/gr/54028\&quot;&gt;Document Migration Mode in Vault Help.&lt;/a&gt;
func (r ApiObjectsDocumentsBatchActionsReclassifyPutRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode bool) ApiObjectsDocumentsBatchActionsReclassifyPutRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsBatchActionsReclassifyPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsBatchActionsReclassifyPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsBatchActionsReclassifyPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsBatchActionsReclassifyPutExecute(r)
}

/*
ObjectsDocumentsBatchActionsReclassifyPut Reclassify Multiple Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsBatchActionsReclassifyPutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsBatchActionsReclassifyPut(ctx context.Context) ApiObjectsDocumentsBatchActionsReclassifyPutRequest {
	return ApiObjectsDocumentsBatchActionsReclassifyPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsBatchActionsReclassifyPutExecute(r ApiObjectsDocumentsBatchActionsReclassifyPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsBatchActionsReclassifyPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/batch/actions/reclassify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsBatchActionsRerenderPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsBatchActionsRerenderPostRequest) Authorization(authorization string) ApiObjectsDocumentsBatchActionsRerenderPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsBatchActionsRerenderPostRequest) Accept(accept string) ApiObjectsDocumentsBatchActionsRerenderPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsBatchActionsRerenderPostRequest) ContentType(contentType string) ApiObjectsDocumentsBatchActionsRerenderPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsBatchActionsRerenderPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsBatchActionsRerenderPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsBatchActionsRerenderPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsBatchActionsRerenderPostExecute(r)
}

/*
ObjectsDocumentsBatchActionsRerenderPost Update Multiple Document Renditions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsBatchActionsRerenderPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsBatchActionsRerenderPost(ctx context.Context) ApiObjectsDocumentsBatchActionsRerenderPostRequest {
	return ApiObjectsDocumentsBatchActionsRerenderPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsBatchActionsRerenderPostExecute(r ApiObjectsDocumentsBatchActionsRerenderPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsBatchActionsRerenderPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/batch/actions/rerender"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsBatchDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	idParam *string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

// If you’re identifying documents in your input by their external ID
func (r ApiObjectsDocumentsBatchDeleteRequest) IdParam(idParam string) ApiObjectsDocumentsBatchDeleteRequest {
	r.idParam = &idParam
	return r
}

func (r ApiObjectsDocumentsBatchDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsBatchDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsBatchDeleteRequest) Accept(accept string) ApiObjectsDocumentsBatchDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsBatchDeleteRequest) ContentType(contentType string) ApiObjectsDocumentsBatchDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsBatchDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsBatchDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsBatchDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsBatchDeleteExecute(r)
}

/*
ObjectsDocumentsBatchDelete Delete Multiple Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsBatchDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsBatchDelete(ctx context.Context) ApiObjectsDocumentsBatchDeleteRequest {
	return ApiObjectsDocumentsBatchDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsBatchDeleteExecute(r ApiObjectsDocumentsBatchDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsBatchDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idParam", r.idParam, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsBatchLockDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsBatchLockDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsBatchLockDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsBatchLockDeleteRequest) Accept(accept string) ApiObjectsDocumentsBatchLockDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsBatchLockDeleteRequest) ContentType(contentType string) ApiObjectsDocumentsBatchLockDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsBatchLockDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsBatchLockDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsBatchLockDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsBatchLockDeleteExecute(r)
}

/*
ObjectsDocumentsBatchLockDelete Undo Collaborative Authoring Checkout

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsBatchLockDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsBatchLockDelete(ctx context.Context) ApiObjectsDocumentsBatchLockDeleteRequest {
	return ApiObjectsDocumentsBatchLockDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsBatchLockDeleteExecute(r ApiObjectsDocumentsBatchLockDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsBatchLockDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/batch/lock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsBatchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIMigrationMode *bool
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsBatchPostRequest) Authorization(authorization string) ApiObjectsDocumentsBatchPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsBatchPostRequest) Accept(accept string) ApiObjectsDocumentsBatchPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsBatchPostRequest) ContentType(contentType string) ApiObjectsDocumentsBatchPostRequest {
	r.contentType = &contentType
	return r
}

// When set to true, Vault allows you to create documents in any lifecycle state using the status__v field, and to manually set the name, document number, and version number. Vault also bypasses entry criteria, entry actions, and event actions. You must have the Document Migration permission to use this header. Learn more about &lt;a href&#x3D;\&quot;https://platform.veevavault.help/en/gr/54028\&quot;&gt;Document Migration Mode in Vault Help.&lt;/a&gt;
func (r ApiObjectsDocumentsBatchPostRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode bool) ApiObjectsDocumentsBatchPostRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsBatchPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsBatchPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsBatchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsBatchPostExecute(r)
}

/*
ObjectsDocumentsBatchPost Create Multiple Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsBatchPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsBatchPost(ctx context.Context) ApiObjectsDocumentsBatchPostRequest {
	return ApiObjectsDocumentsBatchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsBatchPostExecute(r ApiObjectsDocumentsBatchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsBatchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsBatchPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIMigrationMode *bool
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsBatchPutRequest) Authorization(authorization string) ApiObjectsDocumentsBatchPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsBatchPutRequest) Accept(accept string) ApiObjectsDocumentsBatchPutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsBatchPutRequest) ContentType(contentType string) ApiObjectsDocumentsBatchPutRequest {
	r.contentType = &contentType
	return r
}

// When set to true, Vault allows you to change the document number. All other Document Migration Mode overrides available at document creation are ignored, but do not generate an error message. You must have the Document Migration permission to use this header.Learn more about &lt;a href&#x3D;\&quot;https://platform.veevavault.help/en/gr/54028\&quot;&gt;Document Migration Mode in Vault Help.&lt;/a&gt;
func (r ApiObjectsDocumentsBatchPutRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode bool) ApiObjectsDocumentsBatchPutRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsBatchPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsBatchPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsBatchPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsBatchPutExecute(r)
}

/*
ObjectsDocumentsBatchPut Update Multiple Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsBatchPutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsBatchPut(ctx context.Context) ApiObjectsDocumentsBatchPutRequest {
	return ApiObjectsDocumentsBatchPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsBatchPutExecute(r ApiObjectsDocumentsBatchPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsBatchPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAnchorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAnchorsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAnchorsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdAnchorsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAnchorsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAnchorsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAnchorsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAnchorsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAnchorsGetExecute(r)
}

/*
ObjectsDocumentsDocIdAnchorsGet Retrieve Anchor IDs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdAnchorsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAnchorsGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdAnchorsGetRequest {
	return ApiObjectsDocumentsDocIdAnchorsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAnchorsGetExecute(r ApiObjectsDocumentsDocIdAnchorsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAnchorsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/anchors"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAnnotationsFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAnnotationsFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAnnotationsFileGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdAnnotationsFileGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAnnotationsFileGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAnnotationsFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAnnotationsFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAnnotationsFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAnnotationsFileGetExecute(r)
}

/*
ObjectsDocumentsDocIdAnnotationsFileGet Export Document Annotations to PDF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdAnnotationsFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAnnotationsFileGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdAnnotationsFileGetRequest {
	return ApiObjectsDocumentsDocIdAnnotationsFileGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAnnotationsFileGetExecute(r ApiObjectsDocumentsDocIdAnnotationsFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAnnotationsFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/annotations/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAnnotationsFilePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAnnotationsFilePostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAnnotationsFilePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdAnnotationsFilePostRequest) Accept(accept string) ApiObjectsDocumentsDocIdAnnotationsFilePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAnnotationsFilePostRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdAnnotationsFilePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAnnotationsFilePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAnnotationsFilePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAnnotationsFilePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAnnotationsFilePostExecute(r)
}

/*
ObjectsDocumentsDocIdAnnotationsFilePost Import Document Annotations from PDF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdAnnotationsFilePostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAnnotationsFilePost(ctx context.Context, docId string) ApiObjectsDocumentsDocIdAnnotationsFilePostRequest {
	return ApiObjectsDocumentsDocIdAnnotationsFilePostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAnnotationsFilePostExecute(r ApiObjectsDocumentsDocIdAnnotationsFilePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAnnotationsFilePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/annotations/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	attachmentId string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsAttachmentIdDelete Delete Single Document Attachment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param attachmentId The attachment id field value.
 @return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdDelete(ctx context.Context, docId string, attachmentId string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest {
	return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteExecute(r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsAttachmentIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/{attachment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	attachmentId string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGet Download Document Attachment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param attachmentId The attachment id field value.
 @return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGet(ctx context.Context, docId string, attachmentId string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest {
	return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetExecute(r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsAttachmentIdFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/{attachment_id}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	attachmentId string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsAttachmentIdGetExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsAttachmentIdGet Retrieve Document Attachment Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param attachmentId The attachment id field value.
 @return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdGet(ctx context.Context, docId string, attachmentId string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest {
	return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdGetExecute(r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsAttachmentIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/{attachment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	attachmentId string
	accept *string
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsAttachmentIdPutExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsAttachmentIdPut Update Document Attachment Description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param attachmentId The attachment id field value.
 @return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdPut(ctx context.Context, docId string, attachmentId string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest {
	return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdPutExecute(r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsAttachmentIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/{attachment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	attachmentId string
	attachmentVersion string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete Delete Single Document Attachment Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param attachmentId The attachment id field value.
 @param attachmentVersion The attachment version__v field value.
 @return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(ctx context.Context, docId string, attachmentId string, attachmentVersion string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
	return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteExecute(r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	attachmentId string
	attachmentVersion string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet Download Document Attachment Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param attachmentId The attachment id field value.
 @param attachmentVersion The attachment version__v field value.
 @return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(ctx context.Context, docId string, attachmentId string, attachmentVersion string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetExecute(r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	attachmentId string
	attachmentVersion string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet Retrieve Document Attachment Version Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param attachmentId The attachment id field value.
 @param attachmentVersion The attachment version__v field value.
 @return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(ctx context.Context, docId string, attachmentId string, attachmentVersion string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetExecute(r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	attachmentId string
	attachmentVersion string
	restore *bool
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

// The parameter restore must be set to true. 
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) Restore(restore bool) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	r.restore = &restore
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost Restore Document Attachment Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param attachmentId The attachment id field value.
 @param attachmentVersion The attachment version__v field value.
 @return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(ctx context.Context, docId string, attachmentId string, attachmentVersion string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostExecute(r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.restore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "restore", r.restore, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	attachmentId string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet Retrieve Document Attachment Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param attachmentId The attachment id field value.
 @return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet(ctx context.Context, docId string, attachmentId string) ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest {
	return ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetExecute(r ApiObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsAttachmentIdVersionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/{attachment_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsFileGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsFileGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsFileGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsFileGetExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsFileGet Download All Document Attachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdAttachmentsFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsFileGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdAttachmentsFileGetRequest {
	return ApiObjectsDocumentsDocIdAttachmentsFileGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsFileGetExecute(r ApiObjectsDocumentsDocIdAttachmentsFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsGetExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsGet Retrieve Document Attachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdAttachmentsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdAttachmentsGetRequest {
	return ApiObjectsDocumentsDocIdAttachmentsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsGetExecute(r ApiObjectsDocumentsDocIdAttachmentsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAttachmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	accept *string
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdAttachmentsPostRequest) Accept(accept string) ApiObjectsDocumentsDocIdAttachmentsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsPostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAttachmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsPostRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdAttachmentsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAttachmentsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAttachmentsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAttachmentsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAttachmentsPostExecute(r)
}

/*
ObjectsDocumentsDocIdAttachmentsPost Create Document Attachment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdAttachmentsPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsPost(ctx context.Context, docId string) ApiObjectsDocumentsDocIdAttachmentsPostRequest {
	return ApiObjectsDocumentsDocIdAttachmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAttachmentsPostExecute(r ApiObjectsDocumentsDocIdAttachmentsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAttachmentsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdAudittrailGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	startDate *string
	endDate *string
	formatResult *string
	limit *string
	offset *string
	events *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Specify a start date to retrieve audit history. This date cannot be more than 30 days ago. Dates must be YYYY-MM-DDTHH:MM:SSZ format, for example, 7AM on January 15, 2018 would use 2018-01-15T07:00:00Z. If omitted, defaults to the vault’s creation date. 
func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) StartDate(startDate string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	r.startDate = &startDate
	return r
}

// Specify an end date to retrieve audit history. This date cannot be more than 30 days ago. Dates must be YYYY-MM-DDTHH:MM:SSZ format, for example, 7AM on January 15, 2018 would use 2018-01-15T07:00:00Z. If omitted, defaults to today’s date. 
func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) EndDate(endDate string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	r.endDate = &endDate
	return r
}

// To request a CSV file of your audit history, use csv. 
func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) FormatResult(formatResult string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	r.formatResult = &formatResult
	return r
}

// Paginate the results by specifying the maximum number of histories per page in the response. This can be any value between 1 and 1000. If omitted, defaults to 200.
func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) Limit(limit string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	r.limit = &limit
	return r
}

// Paginate the results displayed per page by specifying the amount of offset from the entry returned. For example, if you are viewing the first 50 results (page 1) and want to see the next page, set this to offset&#x3D;51. If omitted, defaults to 0.
func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) Offset(offset string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	r.offset = &offset
	return r
}

// Provide a comma-separated list of one or more audit events to retrieve their audit history. See Vault Help for a full list of document audit events. The values passed to this parameter are case sensitive. For example, events&#x3D;WorkflowCompletion,TaskAssignment. If omitted, defaults to all audit events.
func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) Events(events string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	r.events = &events
	return r
}

func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdAudittrailGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdAudittrailGetExecute(r)
}

/*
ObjectsDocumentsDocIdAudittrailGet Retrieve Complete Audit History for a Single Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document ID for which to retrieve audit history.
 @return ApiObjectsDocumentsDocIdAudittrailGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdAudittrailGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdAudittrailGetRequest {
	return ApiObjectsDocumentsDocIdAudittrailGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdAudittrailGetExecute(r ApiObjectsDocumentsDocIdAudittrailGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdAudittrailGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/audittrail"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.formatResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format_result", r.formatResult, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.events != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "events", r.events, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdDeleteRequest) Accept(accept string) ApiObjectsDocumentsDocIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdDeleteExecute(r)
}

/*
ObjectsDocumentsDocIdDelete Delete Single Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdDelete(ctx context.Context, docId string) ApiObjectsDocumentsDocIdDeleteRequest {
	return ApiObjectsDocumentsDocIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdDeleteExecute(r ApiObjectsDocumentsDocIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdEventsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdEventsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdEventsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdEventsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdEventsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdEventsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdEventsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdEventsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdEventsGetExecute(r)
}

/*
ObjectsDocumentsDocIdEventsGet Retrieve Document Events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdEventsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdEventsGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdEventsGetRequest {
	return ApiObjectsDocumentsDocIdEventsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdEventsGetExecute(r ApiObjectsDocumentsDocIdEventsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdEventsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	lockDocument *bool
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

// Set to true to Check Out this document before retrieval. If omitted, defaults to false.
func (r ApiObjectsDocumentsDocIdFileGetRequest) LockDocument(lockDocument bool) ApiObjectsDocumentsDocIdFileGetRequest {
	r.lockDocument = &lockDocument
	return r
}

func (r ApiObjectsDocumentsDocIdFileGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdFileGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdFileGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdFileGetExecute(r)
}

/*
ObjectsDocumentsDocIdFileGet Download Document File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdFileGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdFileGetRequest {
	return ApiObjectsDocumentsDocIdFileGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdFileGetExecute(r ApiObjectsDocumentsDocIdFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lockDocument != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lockDocument", r.lockDocument, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdGetExecute(r)
}

/*
ObjectsDocumentsDocIdGet Retrieve Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdGetRequest {
	return ApiObjectsDocumentsDocIdGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdGetExecute(r ApiObjectsDocumentsDocIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdLockDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdLockDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdLockDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdLockDeleteRequest) Accept(accept string) ApiObjectsDocumentsDocIdLockDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdLockDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdLockDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdLockDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdLockDeleteExecute(r)
}

/*
ObjectsDocumentsDocIdLockDelete Delete Document Lock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdLockDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdLockDelete(ctx context.Context, docId string) ApiObjectsDocumentsDocIdLockDeleteRequest {
	return ApiObjectsDocumentsDocIdLockDeleteRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdLockDeleteExecute(r ApiObjectsDocumentsDocIdLockDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdLockDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/lock"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdLockGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdLockGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdLockGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdLockGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdLockGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdLockGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdLockGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdLockGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdLockGetExecute(r)
}

/*
ObjectsDocumentsDocIdLockGet Retrieve Document Lock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdLockGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdLockGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdLockGetRequest {
	return ApiObjectsDocumentsDocIdLockGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdLockGetExecute(r ApiObjectsDocumentsDocIdLockGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdLockGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/lock"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdLockPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdLockPostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdLockPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdLockPostRequest) Accept(accept string) ApiObjectsDocumentsDocIdLockPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdLockPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdLockPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdLockPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdLockPostExecute(r)
}

/*
ObjectsDocumentsDocIdLockPost Create Document Lock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdLockPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdLockPost(ctx context.Context, docId string) ApiObjectsDocumentsDocIdLockPostRequest {
	return ApiObjectsDocumentsDocIdLockPostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdLockPostExecute(r ApiObjectsDocumentsDocIdLockPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdLockPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/lock"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetExecute(r)
}

/*
ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet Download All Document Version Attachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest {
	return ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetExecute(r ApiObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/{major_version}/{minor_version}/attachments/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	suppressRendition *string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

// Set to true to suppress automatic generation of the viewable rendition. If omitted, defaults to false
func (r ApiObjectsDocumentsDocIdPostRequest) SuppressRendition(suppressRendition string) ApiObjectsDocumentsDocIdPostRequest {
	r.suppressRendition = &suppressRendition
	return r
}

func (r ApiObjectsDocumentsDocIdPostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdPostRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsDocIdPostRequest) Accept(accept string) ApiObjectsDocumentsDocIdPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdPostExecute(r)
}

/*
ObjectsDocumentsDocIdPost Create Single Document Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdPost(ctx context.Context, docId string) ApiObjectsDocumentsDocIdPostRequest {
	return ApiObjectsDocumentsDocIdPostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdPostExecute(r ApiObjectsDocumentsDocIdPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.suppressRendition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suppressRendition", r.suppressRendition, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIMigrationMode *bool
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdPutRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdPutRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsDocIdPutRequest) Accept(accept string) ApiObjectsDocumentsDocIdPutRequest {
	r.accept = &accept
	return r
}

// When set to true, Vault allows you to change the document number. All other Document Migration Mode overrides available at document creation are ignored, but do not generate an error message. You must have the Document Migration permission to use this header. Learn more about &lt;a href&#x3D;\&quot;https://platform.veevavault.help/en/gr/54028\&quot;&gt;Document Migration Mode in Vault Help.&lt;/a&gt;
func (r ApiObjectsDocumentsDocIdPutRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode bool) ApiObjectsDocumentsDocIdPutRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdPutExecute(r)
}

/*
ObjectsDocumentsDocIdPut Update Single Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdPutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdPut(ctx context.Context, docId string) ApiObjectsDocumentsDocIdPutRequest {
	return ApiObjectsDocumentsDocIdPutRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdPutExecute(r ApiObjectsDocumentsDocIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdRenditionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdRenditionsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdRenditionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdRenditionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdRenditionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdRenditionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdRenditionsGetExecute(r)
}

/*
ObjectsDocumentsDocIdRenditionsGet Retrieve Document Renditions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdRenditionsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdRenditionsGetRequest {
	return ApiObjectsDocumentsDocIdRenditionsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsGetExecute(r ApiObjectsDocumentsDocIdRenditionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdRenditionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/renditions"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	renditionType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest) Accept(accept string) ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteExecute(r)
}

/*
ObjectsDocumentsDocIdRenditionsRenditionTypeDelete Delete Single Document Rendition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param renditionType The document rendition type.
 @return ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsRenditionTypeDelete(ctx context.Context, docId string, renditionType string) ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest {
	return ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		renditionType: renditionType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsRenditionTypeDeleteExecute(r ApiObjectsDocumentsDocIdRenditionsRenditionTypeDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdRenditionsRenditionTypeDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/renditions/{rendition_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rendition_type"+"}", url.PathEscape(parameterValueToString(r.renditionType, "renditionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	renditionType string
	steadyState *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Set to true to download a rendition (file) from the latest steady state version (1.0, 2.0, etc.) of a document. 
func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest) SteadyState(steadyState string) ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest {
	r.steadyState = &steadyState
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdRenditionsRenditionTypeGetExecute(r)
}

/*
ObjectsDocumentsDocIdRenditionsRenditionTypeGet Download Document Rendition File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param renditionType The document rendition type.
 @return ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsRenditionTypeGet(ctx context.Context, docId string, renditionType string) ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest {
	return ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		renditionType: renditionType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsRenditionTypeGetExecute(r ApiObjectsDocumentsDocIdRenditionsRenditionTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdRenditionsRenditionTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/renditions/{rendition_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rendition_type"+"}", url.PathEscape(parameterValueToString(r.renditionType, "renditionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.steadyState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "steadyState", r.steadyState, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	renditionType string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest) Accept(accept string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdRenditionsRenditionTypePostExecute(r)
}

/*
ObjectsDocumentsDocIdRenditionsRenditionTypePost Add Single Document Rendition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param renditionType The document rendition type.
 @return ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsRenditionTypePost(ctx context.Context, docId string, renditionType string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest {
	return ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		renditionType: renditionType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsRenditionTypePostExecute(r ApiObjectsDocumentsDocIdRenditionsRenditionTypePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdRenditionsRenditionTypePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/renditions/{rendition_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rendition_type"+"}", url.PathEscape(parameterValueToString(r.renditionType, "renditionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	renditionType string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest) Accept(accept string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdRenditionsRenditionTypePutExecute(r)
}

/*
ObjectsDocumentsDocIdRenditionsRenditionTypePut Replace Document Rendition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param renditionType The document rendition type.
 @return ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsRenditionTypePut(ctx context.Context, docId string, renditionType string) ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest {
	return ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		renditionType: renditionType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdRenditionsRenditionTypePutExecute(r ApiObjectsDocumentsDocIdRenditionsRenditionTypePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdRenditionsRenditionTypePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/renditions/{rendition_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rendition_type"+"}", url.PathEscape(parameterValueToString(r.renditionType, "renditionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	roleNameAndUserOrGroup string
	id string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest) Accept(accept string) ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteExecute(r)
}

/*
ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete Remove Users & Groups from Roles on a Single Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The id value of the document from which to remove roles.
 @param roleNameAndUserOrGroup The name of the role from which to remove the user or group followed by either `user` or `group`. The format is `{role_name}.{user_or_group}`. For example, `consumer__v.user`.
 @param id The id value of the user or group to remove from the role.
 @return ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete(ctx context.Context, docId string, roleNameAndUserOrGroup string, id string) ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest {
	return ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		roleNameAndUserOrGroup: roleNameAndUserOrGroup,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteExecute(r ApiObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/roles/{role_name_and_user_or_group}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role_name_and_user_or_group"+"}", url.PathEscape(parameterValueToString(r.roleNameAndUserOrGroup, "roleNameAndUserOrGroup")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet Retrieve Document Version Attachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest {
	return ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetExecute(r ApiObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/version/{major_version}/{minor_version}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsGet Retrieve Document Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @return ApiObjectsDocumentsDocIdVersionsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsGet(ctx context.Context, docId string) ApiObjectsDocumentsDocIdVersionsGetRequest {
	return ApiObjectsDocumentsDocIdVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsGetExecute(r ApiObjectsDocumentsDocIdVersionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	annotationId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet Read Annotations by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param annotationId The annotation ID, which can be retrieved with Read Annotations by Document Version and Type.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet(ctx context.Context, docId string, majorVersion string, minorVersion string, annotationId string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		annotationId: annotationId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotation_id"+"}", url.PathEscape(parameterValueToString(r.annotationId, "annotationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	annotationId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet Read Replies of Parent Annotation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param annotationId The parent annotation ID, which can be retrieved with Read Annotations by Document Version and Type.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet(ctx context.Context, docId string, majorVersion string, minorVersion string, annotationId string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		annotationId: annotationId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"annotation_id"+"}", url.PathEscape(parameterValueToString(r.annotationId, "annotationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet Export Document Version Annotations to PDF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost Import Document Version Annotations from PDF

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	limit *string
	offset *string
	annotationTypes *string
	paginationId *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Paginate the results by specifying the maximum number of records per page in the response. This can be any value between 1 and 500. If omitted, defaults to 500. Values greater than 500 are ignored.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest) Limit(limit string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest {
	r.limit = &limit
	return r
}

// This parameter is used to paginate the results. It specifies the amount of offset from the first record returned. Vault returns 200 records per page by default. If you are viewing the first 200 results (page 1) and want to see the next page, set this to offset&#x3D;201.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest) Offset(offset string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest {
	r.offset = &offset
	return r
}

// The type(s) of annotations to retrieve. For example, note__sys,anchor__sys. If omitted, Vault returns all annotations. Valid annotation types include: &#x60;note__sys&#x60; &#x60;line__sys&#x60; &#x60;document_link__sys&#x60; &#x60;permalink_link__sys&#x60; &#x60;anchor__sys&#x60; &#x60;reply__sys&#x60; &#x60;external_link__sys&#x60;  The following annotation types are only valid in PromoMats Vaults:  &#x60;suggested_link__sys&#x60; &#x60;approved_link__sys&#x60; &#x60;auto_link__sys&#x60; &#x60;keyword_link__sys&#x60; 
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest) AnnotationTypes(annotationTypes string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest {
	r.annotationTypes = &annotationTypes
	return r
}

// A unique identifier used to load requests with paginated results.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest) PaginationId(paginationId string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest {
	r.paginationId = &paginationId
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet Read Annotations by Document Version and Type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.annotationTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "annotation_types", r.annotationTypes, "form", "")
	}
	if r.paginationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagination_id", r.paginationId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	attachmentId string
	attachmentVersion string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet Download Document Version Attachment Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param attachmentId The id field value of the attachment.
 @param attachmentVersion The version of the attachment.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(ctx context.Context, docId string, majorVersion string, minorVersion string, attachmentId string, attachmentVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	attachmentId string
	attachmentVersion string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet Retrieve Document Version Attachment Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param attachmentId The id of the document attachment to retrieve.
 @param attachmentVersion Optional: The version of the attachment to retrieve. If omitted, the endpoint retrieves all versions of the specified attachment.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet(ctx context.Context, docId string, majorVersion string, minorVersion string, attachmentId string, attachmentVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete Delete Single Document Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet Retrieve Document Version Notes as CSV

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/doc-export-annotations-to-csv"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost Create Document Event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest {
	r.authorization = &authorization
	return r
}

// This &#x60;Accept&#x60; header only changes the format of the response in the case of an error. On &#x60;SUCCESS&#x60;, the HTTP Response Header &#x60;Content-Type&#x60; is set to &#x60;text/plain;charset&#x3D;UnicodeLittle&#x60;.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet Retrieve Video Annotations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The video document id field value.
 @param majorVersion The video document major_version_number__v field value.
 @param minorVersion The video document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/export-video-annotations"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet Download Document Version File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGet Retrieve Document Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIMigrationMode *bool
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest {
	r.accept = &accept
	return r
}

// When set to true, Vault allows you to manually set the document number. All other Document Migration Mode overrides available at document creation are ignored, but do not generate an error message. You must have the Document Migration permission to use this header. Learn more about &lt;a href&#x3D;\&quot;https://platform.veevavault.help/en/gr/54028\&quot;&gt;Document Migration Mode in Vault Help.&lt;/a&gt;
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode bool) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPut Update Document Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPut(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet Retrieve Document Relationships

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost Create Single Document Relationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	relationshipId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete Delete Single Document Relationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param relationshipId The relationship id field value. See Retrieve Document Relationships.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete(ctx context.Context, docId string, majorVersion string, minorVersion string, relationshipId string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		relationshipId: relationshipId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relationship_id"+"}", url.PathEscape(parameterValueToString(r.relationshipId, "relationshipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	relationshipId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet Retrieve Document Relationship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param relationshipId The relationship id field value. See Retrieve Document Relationships.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet(ctx context.Context, docId string, majorVersion string, minorVersion string, relationshipId string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		relationshipId: relationshipId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"relationship_id"+"}", url.PathEscape(parameterValueToString(r.relationshipId, "relationshipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet Retrieve Document Version Renditions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	renditionType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete Delete Document Version Rendition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param renditionType The document rendition type.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete(ctx context.Context, docId string, majorVersion string, minorVersion string, renditionType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		renditionType: renditionType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rendition_type"+"}", url.PathEscape(parameterValueToString(r.renditionType, "renditionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	renditionType string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet Download Document Version Rendition File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param renditionType The document rendition type.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet(ctx context.Context, docId string, majorVersion string, minorVersion string, renditionType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		renditionType: renditionType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rendition_type"+"}", url.PathEscape(parameterValueToString(r.renditionType, "renditionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	renditionType string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost Upload Document Version Rendition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param renditionType The document rendition type.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost(ctx context.Context, docId string, majorVersion string, minorVersion string, renditionType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		renditionType: renditionType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rendition_type"+"}", url.PathEscape(parameterValueToString(r.renditionType, "renditionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	renditionType string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest) ContentType(contentType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut Replace Document Version Rendition

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @param renditionType The document rendition type.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut(ctx context.Context, docId string, majorVersion string, minorVersion string, renditionType string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		renditionType: renditionType,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rendition_type"+"}", url.PathEscape(parameterValueToString(r.renditionType, "renditionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	docId string
	majorVersion string
	minorVersion string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest) Accept(accept string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest) Authorization(authorization string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetExecute(r)
}

/*
ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet Download Document Version Thumbnail File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param docId The document id field value.
 @param majorVersion The document major_version_number__v field value.
 @param minorVersion The document minor_version_number__v field value.
 @return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet(ctx context.Context, docId string, majorVersion string, minorVersion string) ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest {
	return ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest{
		ApiService: a,
		ctx: ctx,
		docId: docId,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetExecute(r ApiObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/thumbnail"
	localVarPath = strings.Replace(localVarPath, "{"+"doc_id"+"}", url.PathEscape(parameterValueToString(r.docId, "docId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	namedFilter *string
	scope *string
	versionscope *string
	search *string
	limit *string
	sort *string
	start *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Retrieves only documents which you have created.
func (r ApiObjectsDocumentsGetRequest) NamedFilter(namedFilter string) ApiObjectsDocumentsGetRequest {
	r.namedFilter = &namedFilter
	return r
}

// Searches only within the document content.
func (r ApiObjectsDocumentsGetRequest) Scope(scope string) ApiObjectsDocumentsGetRequest {
	r.scope = &scope
	return r
}

// Retrieves all document versions, rather than only the latest version.
func (r ApiObjectsDocumentsGetRequest) Versionscope(versionscope string) ApiObjectsDocumentsGetRequest {
	r.versionscope = &versionscope
	return r
}

// Search for documents based on a {keyword} in searchable document fields.
func (r ApiObjectsDocumentsGetRequest) Search(search string) ApiObjectsDocumentsGetRequest {
	r.search = &search
	return r
}

// See VQL documentation for more information.
func (r ApiObjectsDocumentsGetRequest) Limit(limit string) ApiObjectsDocumentsGetRequest {
	r.limit = &limit
	return r
}

// See VQL documentation for more information.
func (r ApiObjectsDocumentsGetRequest) Sort(sort string) ApiObjectsDocumentsGetRequest {
	r.sort = &sort
	return r
}

// See VQL documentation for more information.
func (r ApiObjectsDocumentsGetRequest) Start(start string) ApiObjectsDocumentsGetRequest {
	r.start = &start
	return r
}

func (r ApiObjectsDocumentsGetRequest) Authorization(authorization string) ApiObjectsDocumentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsGetRequest) Accept(accept string) ApiObjectsDocumentsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsGetExecute(r)
}

/*
ObjectsDocumentsGet Retrieve All Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsGet(ctx context.Context) ApiObjectsDocumentsGetRequest {
	return ApiObjectsDocumentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsGetExecute(r ApiObjectsDocumentsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namedFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "named_filter", r.namedFilter, "form", "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "form", "")
	}
	if r.versionscope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionscope", r.versionscope, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsIdRolesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsIdRolesGetRequest) Authorization(authorization string) ApiObjectsDocumentsIdRolesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsIdRolesGetRequest) Accept(accept string) ApiObjectsDocumentsIdRolesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsIdRolesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsIdRolesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsIdRolesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsIdRolesGetExecute(r)
}

/*
ObjectsDocumentsIdRolesGet Retrieve All Document Roles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiObjectsDocumentsIdRolesGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsIdRolesGet(ctx context.Context, id string) ApiObjectsDocumentsIdRolesGetRequest {
	return ApiObjectsDocumentsIdRolesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsIdRolesGetExecute(r ApiObjectsDocumentsIdRolesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsIdRolesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{id}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsIdRolesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsIdRolesPostRequest) Authorization(authorization string) ApiObjectsDocumentsIdRolesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsIdRolesPostRequest) Accept(accept string) ApiObjectsDocumentsIdRolesPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsIdRolesPostRequest) ContentType(contentType string) ApiObjectsDocumentsIdRolesPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsIdRolesPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsIdRolesPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsIdRolesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsIdRolesPostExecute(r)
}

/*
ObjectsDocumentsIdRolesPost Assign Users & Groups to Roles on a Single Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiObjectsDocumentsIdRolesPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsIdRolesPost(ctx context.Context, id string) ApiObjectsDocumentsIdRolesPostRequest {
	return ApiObjectsDocumentsIdRolesPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsIdRolesPostExecute(r ApiObjectsDocumentsIdRolesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsIdRolesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{id}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsIdRolesRoleNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	roleName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsIdRolesRoleNameGetRequest) Authorization(authorization string) ApiObjectsDocumentsIdRolesRoleNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsIdRolesRoleNameGetRequest) Accept(accept string) ApiObjectsDocumentsIdRolesRoleNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsIdRolesRoleNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsIdRolesRoleNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsIdRolesRoleNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsIdRolesRoleNameGetExecute(r)
}

/*
ObjectsDocumentsIdRolesRoleNameGet Retrieve Document Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The document `id`.
 @param roleName The name of the role to retrieve. For example, `owner__v`.
 @return ApiObjectsDocumentsIdRolesRoleNameGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsIdRolesRoleNameGet(ctx context.Context, id string, roleName string) ApiObjectsDocumentsIdRolesRoleNameGetRequest {
	return ApiObjectsDocumentsIdRolesRoleNameGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsIdRolesRoleNameGetExecute(r ApiObjectsDocumentsIdRolesRoleNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsIdRolesRoleNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{id}/roles/{role_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	majorVersion string
	minorVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) Authorization(authorization string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) Accept(accept string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetExecute(r)
}

/*
ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet Retrieve Document User Actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The document id field value from which to retrieve available user actions.
 @param majorVersion The major version number of the document.
 @param minorVersion The minor version number of the document.
 @return ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet(ctx context.Context, id string, majorVersion string, minorVersion string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest {
	return ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetExecute(r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	majorVersion string
	minorVersion string
	nameV string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) Authorization(authorization string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) Accept(accept string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetExecute(r)
}

/*
ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet Retrieve Document Entry Criteria

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The document id field value from which to retrieve available user actions.
 @param majorVersion The major version number of the document.
 @param minorVersion The minor version number of the document.
 @param nameV The lifecycle name__v field value from which to retrieve entry criteria. This is retrieved from the Retrieve User Actions request above.
 @return ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet(ctx context.Context, id string, majorVersion string, minorVersion string, nameV string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest {
	return ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		nameV: nameV,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetExecute(r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name__v"+"}", url.PathEscape(parameterValueToString(r.nameV, "nameV")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	majorVersion string
	minorVersion string
	nameV string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) Authorization(authorization string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) ContentType(contentType string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) Accept(accept string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutExecute(r)
}

/*
ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut Initiate Document User Action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The document id field value from which to retrieve available user actions.
 @param majorVersion The major version number of the document.
 @param minorVersion The minor version number of the document.
 @param nameV The action name__v field value to initiate. This is retrieved from the Retrieve User Action request.
 @return ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut(ctx context.Context, id string, majorVersion string, minorVersion string, nameV string) ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest {
	return ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		majorVersion: majorVersion,
		minorVersion: minorVersion,
		nameV: nameV,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutExecute(r ApiObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"major_version"+"}", url.PathEscape(parameterValueToString(r.majorVersion, "majorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"minor_version"+"}", url.PathEscape(parameterValueToString(r.minorVersion, "minorVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name__v"+"}", url.PathEscape(parameterValueToString(r.nameV, "nameV")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsLifecycleActionsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsLifecycleActionsPostRequest) Authorization(authorization string) ApiObjectsDocumentsLifecycleActionsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsLifecycleActionsPostRequest) Accept(accept string) ApiObjectsDocumentsLifecycleActionsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsLifecycleActionsPostRequest) ContentType(contentType string) ApiObjectsDocumentsLifecycleActionsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsLifecycleActionsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsLifecycleActionsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsLifecycleActionsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsLifecycleActionsPostExecute(r)
}

/*
ObjectsDocumentsLifecycleActionsPost Retrieve User Actions on Multiple Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsLifecycleActionsPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsLifecycleActionsPost(ctx context.Context) ApiObjectsDocumentsLifecycleActionsPostRequest {
	return ApiObjectsDocumentsLifecycleActionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsLifecycleActionsPostExecute(r ApiObjectsDocumentsLifecycleActionsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsLifecycleActionsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/lifecycle_actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	userActionName string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest) Authorization(authorization string) ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest) ContentType(contentType string) ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest) Accept(accept string) ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsLifecycleActionsUserActionNamePutExecute(r)
}

/*
ObjectsDocumentsLifecycleActionsUserActionNamePut Initiate Bulk Document User Actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userActionName The user action name__v field value. Find this value with the Retrieve User Actions on Multiple Documents endpoint.
 @return ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsLifecycleActionsUserActionNamePut(ctx context.Context, userActionName string) ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest {
	return ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest{
		ApiService: a,
		ctx: ctx,
		userActionName: userActionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsLifecycleActionsUserActionNamePutExecute(r ApiObjectsDocumentsLifecycleActionsUserActionNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsLifecycleActionsUserActionNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/lifecycle_actions/{user_action_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_action_name"+"}", url.PathEscape(parameterValueToString(r.userActionName, "userActionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIMigrationMode *bool
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsPostRequest) Authorization(authorization string) ApiObjectsDocumentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsPostRequest) Accept(accept string) ApiObjectsDocumentsPostRequest {
	r.accept = &accept
	return r
}

// When set to true,  you can use the status__v field to create documents in any lifecycle state. Additionally, you can manually set the name, document number, and version number. Vault also bypasses entry criteria, entry actions, and event actions. You must have the Document Migration permission to use this header. Learn more about &lt;a href&#x3D;\&quot;https://platform.veevavault.help/en/gr/54028\&quot;&gt;Document Migration Mode in Vault Help.&lt;/a&gt;
func (r ApiObjectsDocumentsPostRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode bool) ApiObjectsDocumentsPostRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsPostExecute(r)
}

/*
ObjectsDocumentsPost Create Single Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsPost(ctx context.Context) ApiObjectsDocumentsPostRequest {
	return ApiObjectsDocumentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsPostExecute(r ApiObjectsDocumentsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsRelationshipsBatchDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsRelationshipsBatchDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsRelationshipsBatchDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsRelationshipsBatchDeleteRequest) Accept(accept string) ApiObjectsDocumentsRelationshipsBatchDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsRelationshipsBatchDeleteRequest) ContentType(contentType string) ApiObjectsDocumentsRelationshipsBatchDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsRelationshipsBatchDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsRelationshipsBatchDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsRelationshipsBatchDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsRelationshipsBatchDeleteExecute(r)
}

/*
ObjectsDocumentsRelationshipsBatchDelete Delete Multiple Document Relationships

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsRelationshipsBatchDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsRelationshipsBatchDelete(ctx context.Context) ApiObjectsDocumentsRelationshipsBatchDeleteRequest {
	return ApiObjectsDocumentsRelationshipsBatchDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsRelationshipsBatchDeleteExecute(r ApiObjectsDocumentsRelationshipsBatchDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsRelationshipsBatchDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/relationships/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsRelationshipsBatchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsRelationshipsBatchPostRequest) Authorization(authorization string) ApiObjectsDocumentsRelationshipsBatchPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsRelationshipsBatchPostRequest) Accept(accept string) ApiObjectsDocumentsRelationshipsBatchPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsRelationshipsBatchPostRequest) ContentType(contentType string) ApiObjectsDocumentsRelationshipsBatchPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsRelationshipsBatchPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsRelationshipsBatchPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsRelationshipsBatchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsRelationshipsBatchPostExecute(r)
}

/*
ObjectsDocumentsRelationshipsBatchPost Create Multiple Document Relationships

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsRelationshipsBatchPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsRelationshipsBatchPost(ctx context.Context) ApiObjectsDocumentsRelationshipsBatchPostRequest {
	return ApiObjectsDocumentsRelationshipsBatchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsRelationshipsBatchPostExecute(r ApiObjectsDocumentsRelationshipsBatchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsRelationshipsBatchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/relationships/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsRenditionsBatchDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsRenditionsBatchDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsRenditionsBatchDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsRenditionsBatchDeleteRequest) Accept(accept string) ApiObjectsDocumentsRenditionsBatchDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsRenditionsBatchDeleteRequest) ContentType(contentType string) ApiObjectsDocumentsRenditionsBatchDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsRenditionsBatchDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsRenditionsBatchDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsRenditionsBatchDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsRenditionsBatchDeleteExecute(r)
}

/*
ObjectsDocumentsRenditionsBatchDelete Delete Multiple Document Renditions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsRenditionsBatchDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsRenditionsBatchDelete(ctx context.Context) ApiObjectsDocumentsRenditionsBatchDeleteRequest {
	return ApiObjectsDocumentsRenditionsBatchDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsRenditionsBatchDeleteExecute(r ApiObjectsDocumentsRenditionsBatchDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsRenditionsBatchDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/renditions/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsRenditionsBatchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	idParam *string
	largeSizeAsset *string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIMigrationMode *bool
	xVaultAPIClientID *string
}

// If you’re identifying documents in your input by their external ID
func (r ApiObjectsDocumentsRenditionsBatchPostRequest) IdParam(idParam string) ApiObjectsDocumentsRenditionsBatchPostRequest {
	r.idParam = &idParam
	return r
}

// If set to true, indicates that the renditions to add are of the Large Size Asset (large_size_asset__v) rendition type. Vault applies Document Migration Mode limitations to renditions created with the request, but Document Migration permission is not required and your vault need not be in Migration Mode to use the parameter. Note that the request results in an error if the CSV contains any rendition type other than large_size_asset__v.
func (r ApiObjectsDocumentsRenditionsBatchPostRequest) LargeSizeAsset(largeSizeAsset string) ApiObjectsDocumentsRenditionsBatchPostRequest {
	r.largeSizeAsset = &largeSizeAsset
	return r
}

func (r ApiObjectsDocumentsRenditionsBatchPostRequest) Authorization(authorization string) ApiObjectsDocumentsRenditionsBatchPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsRenditionsBatchPostRequest) Accept(accept string) ApiObjectsDocumentsRenditionsBatchPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsRenditionsBatchPostRequest) ContentType(contentType string) ApiObjectsDocumentsRenditionsBatchPostRequest {
	r.contentType = &contentType
	return r
}

// Must be set to true when importing any rendition type other than large_size_asset__v. You must have the Document Migration permission to use this header. Learn more about &lt;a href&#x3D;\&quot;https://platform.veevavault.help/en/gr/54028\&quot;&gt;Document Migration Mode in Vault Help.&lt;/a&gt;
func (r ApiObjectsDocumentsRenditionsBatchPostRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode bool) ApiObjectsDocumentsRenditionsBatchPostRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsRenditionsBatchPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsRenditionsBatchPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsRenditionsBatchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsRenditionsBatchPostExecute(r)
}

/*
ObjectsDocumentsRenditionsBatchPost Add Multiple Document Renditions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsRenditionsBatchPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsRenditionsBatchPost(ctx context.Context) ApiObjectsDocumentsRenditionsBatchPostRequest {
	return ApiObjectsDocumentsRenditionsBatchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsRenditionsBatchPostExecute(r ApiObjectsDocumentsRenditionsBatchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsRenditionsBatchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/renditions/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idParam", r.idParam, "form", "")
	}
	if r.largeSizeAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "largeSizeAsset", r.largeSizeAsset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsRolesBatchDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsRolesBatchDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsRolesBatchDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsRolesBatchDeleteRequest) ContentType(contentType string) ApiObjectsDocumentsRolesBatchDeleteRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsRolesBatchDeleteRequest) Accept(accept string) ApiObjectsDocumentsRolesBatchDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsRolesBatchDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsRolesBatchDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsRolesBatchDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsRolesBatchDeleteExecute(r)
}

/*
ObjectsDocumentsRolesBatchDelete Remove Users and Groups from Roles on Multiple Documents & Binders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsRolesBatchDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsRolesBatchDelete(ctx context.Context) ApiObjectsDocumentsRolesBatchDeleteRequest {
	return ApiObjectsDocumentsRolesBatchDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsRolesBatchDeleteExecute(r ApiObjectsDocumentsRolesBatchDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsRolesBatchDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/roles/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsRolesBatchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsRolesBatchPostRequest) Authorization(authorization string) ApiObjectsDocumentsRolesBatchPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsRolesBatchPostRequest) Accept(accept string) ApiObjectsDocumentsRolesBatchPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsRolesBatchPostRequest) ContentType(contentType string) ApiObjectsDocumentsRolesBatchPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsRolesBatchPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsRolesBatchPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsRolesBatchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsRolesBatchPostExecute(r)
}

/*
ObjectsDocumentsRolesBatchPost Assign Users & Groups to Roles on Multiple Documents & Binders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsRolesBatchPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsRolesBatchPost(ctx context.Context) ApiObjectsDocumentsRolesBatchPostRequest {
	return ApiObjectsDocumentsRolesBatchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsRolesBatchPostExecute(r ApiObjectsDocumentsRolesBatchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsRolesBatchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/roles/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsTemplatesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsTemplatesGetRequest) Authorization(authorization string) ApiObjectsDocumentsTemplatesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsTemplatesGetRequest) Accept(accept string) ApiObjectsDocumentsTemplatesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsTemplatesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsTemplatesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsTemplatesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsTemplatesGetExecute(r)
}

/*
ObjectsDocumentsTemplatesGet Retrieve Document Template Collection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsTemplatesGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsTemplatesGet(ctx context.Context) ApiObjectsDocumentsTemplatesGetRequest {
	return ApiObjectsDocumentsTemplatesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsTemplatesGetExecute(r ApiObjectsDocumentsTemplatesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsTemplatesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsTemplatesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsTemplatesPostRequest) Authorization(authorization string) ApiObjectsDocumentsTemplatesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsTemplatesPostRequest) ContentType(contentType string) ApiObjectsDocumentsTemplatesPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsTemplatesPostRequest) Accept(accept string) ApiObjectsDocumentsTemplatesPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsTemplatesPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsTemplatesPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsTemplatesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsTemplatesPostExecute(r)
}

/*
ObjectsDocumentsTemplatesPost Create Single Document Template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsTemplatesPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsTemplatesPost(ctx context.Context) ApiObjectsDocumentsTemplatesPostRequest {
	return ApiObjectsDocumentsTemplatesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsTemplatesPostExecute(r ApiObjectsDocumentsTemplatesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsTemplatesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsTemplatesPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsTemplatesPutRequest) Authorization(authorization string) ApiObjectsDocumentsTemplatesPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsTemplatesPutRequest) Accept(accept string) ApiObjectsDocumentsTemplatesPutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsTemplatesPutRequest) ContentType(contentType string) ApiObjectsDocumentsTemplatesPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsTemplatesPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsTemplatesPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsTemplatesPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsTemplatesPutExecute(r)
}

/*
ObjectsDocumentsTemplatesPut Update Multiple Document Templates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsTemplatesPutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsTemplatesPut(ctx context.Context) ApiObjectsDocumentsTemplatesPutRequest {
	return ApiObjectsDocumentsTemplatesPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsTemplatesPutExecute(r ApiObjectsDocumentsTemplatesPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsTemplatesPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	templateName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest) Accept(accept string) ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsTemplatesTemplateNameDeleteExecute(r)
}

/*
ObjectsDocumentsTemplatesTemplateNameDelete Delete Basic Document Template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateName The document template name__v field value.
 @return ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsTemplatesTemplateNameDelete(ctx context.Context, templateName string) ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest {
	return ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		templateName: templateName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsTemplatesTemplateNameDeleteExecute(r ApiObjectsDocumentsTemplatesTemplateNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsTemplatesTemplateNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/templates/{template_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_name"+"}", url.PathEscape(parameterValueToString(r.templateName, "templateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	templateName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest) Authorization(authorization string) ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest) Accept(accept string) ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsTemplatesTemplateNameFileGetExecute(r)
}

/*
ObjectsDocumentsTemplatesTemplateNameFileGet Download Document Template File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateName The document template name__v field value.
 @return ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsTemplatesTemplateNameFileGet(ctx context.Context, templateName string) ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest {
	return ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest{
		ApiService: a,
		ctx: ctx,
		templateName: templateName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsTemplatesTemplateNameFileGetExecute(r ApiObjectsDocumentsTemplatesTemplateNameFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsTemplatesTemplateNameFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/templates/{template_name}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"template_name"+"}", url.PathEscape(parameterValueToString(r.templateName, "templateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsTemplatesTemplateNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	templateName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsTemplatesTemplateNameGetRequest) Authorization(authorization string) ApiObjectsDocumentsTemplatesTemplateNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsTemplatesTemplateNameGetRequest) Accept(accept string) ApiObjectsDocumentsTemplatesTemplateNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsTemplatesTemplateNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsTemplatesTemplateNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsTemplatesTemplateNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsTemplatesTemplateNameGetExecute(r)
}

/*
ObjectsDocumentsTemplatesTemplateNameGet Retrieve Document Template Attributes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateName The document template name__v field value.
 @return ApiObjectsDocumentsTemplatesTemplateNameGetRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsTemplatesTemplateNameGet(ctx context.Context, templateName string) ApiObjectsDocumentsTemplatesTemplateNameGetRequest {
	return ApiObjectsDocumentsTemplatesTemplateNameGetRequest{
		ApiService: a,
		ctx: ctx,
		templateName: templateName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsTemplatesTemplateNameGetExecute(r ApiObjectsDocumentsTemplatesTemplateNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsTemplatesTemplateNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/templates/{template_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_name"+"}", url.PathEscape(parameterValueToString(r.templateName, "templateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsTemplatesTemplateNamePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	templateName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsTemplatesTemplateNamePutRequest) Authorization(authorization string) ApiObjectsDocumentsTemplatesTemplateNamePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsTemplatesTemplateNamePutRequest) Accept(accept string) ApiObjectsDocumentsTemplatesTemplateNamePutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsTemplatesTemplateNamePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsTemplatesTemplateNamePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsTemplatesTemplateNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsTemplatesTemplateNamePutExecute(r)
}

/*
ObjectsDocumentsTemplatesTemplateNamePut Update Single Document Template

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param templateName The document template name__v field value.
 @return ApiObjectsDocumentsTemplatesTemplateNamePutRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsTemplatesTemplateNamePut(ctx context.Context, templateName string) ApiObjectsDocumentsTemplatesTemplateNamePutRequest {
	return ApiObjectsDocumentsTemplatesTemplateNamePutRequest{
		ApiService: a,
		ctx: ctx,
		templateName: templateName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsTemplatesTemplateNamePutExecute(r ApiObjectsDocumentsTemplatesTemplateNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsTemplatesTemplateNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/templates/{template_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"template_name"+"}", url.PathEscape(parameterValueToString(r.templateName, "templateName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsTokensPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDocumentsTokensPostRequest) Authorization(authorization string) ApiObjectsDocumentsTokensPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsTokensPostRequest) ContentType(contentType string) ApiObjectsDocumentsTokensPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsTokensPostRequest) Accept(accept string) ApiObjectsDocumentsTokensPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsTokensPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsTokensPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsTokensPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsTokensPostExecute(r)
}

/*
ObjectsDocumentsTokensPost Document Tokens

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsTokensPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsTokensPost(ctx context.Context) ApiObjectsDocumentsTokensPostRequest {
	return ApiObjectsDocumentsTokensPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsTokensPostExecute(r ApiObjectsDocumentsTokensPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsTokensPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	source *bool
	renditions *bool
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: To exclude source files, include a query parameter source&#x3D;false. If omitted, defaults to true.
func (r ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest) Source(source bool) ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest {
	r.source = &source
	return r
}

// Optional: To include renditions, include a query parameter renditions&#x3D;true. If omitted, defaults to false.
func (r ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest) Renditions(renditions bool) ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest {
	r.renditions = &renditions
	return r
}

func (r ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest) Authorization(authorization string) ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest) ContentType(contentType string) ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest) Accept(accept string) ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsVersionsBatchActionsFileextractPostExecute(r)
}

/*
ObjectsDocumentsVersionsBatchActionsFileextractPost Export Document Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsVersionsBatchActionsFileextractPost(ctx context.Context) ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest {
	return ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsVersionsBatchActionsFileextractPostExecute(r ApiObjectsDocumentsVersionsBatchActionsFileextractPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsVersionsBatchActionsFileextractPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/versions/batch/actions/fileextract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	}
	if r.renditions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "renditions", r.renditions, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsVersionsBatchDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	idParam *string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

// If you’re identifying documents in your input by their external ID
func (r ApiObjectsDocumentsVersionsBatchDeleteRequest) IdParam(idParam string) ApiObjectsDocumentsVersionsBatchDeleteRequest {
	r.idParam = &idParam
	return r
}

func (r ApiObjectsDocumentsVersionsBatchDeleteRequest) Authorization(authorization string) ApiObjectsDocumentsVersionsBatchDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsVersionsBatchDeleteRequest) ContentType(contentType string) ApiObjectsDocumentsVersionsBatchDeleteRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsDocumentsVersionsBatchDeleteRequest) Accept(accept string) ApiObjectsDocumentsVersionsBatchDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsVersionsBatchDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsVersionsBatchDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsVersionsBatchDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsVersionsBatchDeleteExecute(r)
}

/*
ObjectsDocumentsVersionsBatchDelete Delete Multiple Document Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsVersionsBatchDeleteRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsVersionsBatchDelete(ctx context.Context) ApiObjectsDocumentsVersionsBatchDeleteRequest {
	return ApiObjectsDocumentsVersionsBatchDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsVersionsBatchDeleteExecute(r ApiObjectsDocumentsVersionsBatchDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsVersionsBatchDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/versions/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idParam", r.idParam, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDocumentsVersionsBatchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	idParam *string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIMigrationMode *string
	xVaultAPIClientID *string
}

// If you’re identifying documents in your input by their external ID
func (r ApiObjectsDocumentsVersionsBatchPostRequest) IdParam(idParam string) ApiObjectsDocumentsVersionsBatchPostRequest {
	r.idParam = &idParam
	return r
}

func (r ApiObjectsDocumentsVersionsBatchPostRequest) Authorization(authorization string) ApiObjectsDocumentsVersionsBatchPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDocumentsVersionsBatchPostRequest) Accept(accept string) ApiObjectsDocumentsVersionsBatchPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDocumentsVersionsBatchPostRequest) ContentType(contentType string) ApiObjectsDocumentsVersionsBatchPostRequest {
	r.contentType = &contentType
	return r
}

// Must be set to true. Vault allows you to manually set the name and version number and to create documents in any lifecycle state using the &#x60;status__v&#x60; field, but does not allow you to change the document number. Vault also bypasses entry criteria, entry actions, and event actions. You must have the Document Migration permission to use this header. Learn more about &lt;a href&#x3D;\&quot;https://platform.veevavault.help/en/gr/54028\&quot;&gt;Document Migration Mode in Vault Help.&lt;/a&gt;
func (r ApiObjectsDocumentsVersionsBatchPostRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode string) ApiObjectsDocumentsVersionsBatchPostRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDocumentsVersionsBatchPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDocumentsVersionsBatchPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDocumentsVersionsBatchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDocumentsVersionsBatchPostExecute(r)
}

/*
ObjectsDocumentsVersionsBatchPost Create Multiple Document Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDocumentsVersionsBatchPostRequest
*/
func (a *DefaultAPIService) ObjectsDocumentsVersionsBatchPost(ctx context.Context) ApiObjectsDocumentsVersionsBatchPostRequest {
	return ApiObjectsDocumentsVersionsBatchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDocumentsVersionsBatchPostExecute(r ApiObjectsDocumentsVersionsBatchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDocumentsVersionsBatchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/documents/versions/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idParam", r.idParam, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDomainGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	includeApplication *bool
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

// To include Vault application type information in the response, set include_application to true. If omitted, defaults to false and application information is not included.
func (r ApiObjectsDomainGetRequest) IncludeApplication(includeApplication bool) ApiObjectsDomainGetRequest {
	r.includeApplication = &includeApplication
	return r
}

func (r ApiObjectsDomainGetRequest) Authorization(authorization string) ApiObjectsDomainGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDomainGetRequest) Accept(accept string) ApiObjectsDomainGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDomainGetRequest) ContentType(contentType string) ApiObjectsDomainGetRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDomainGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDomainGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDomainGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDomainGetExecute(r)
}

/*
ObjectsDomainGet Retrieve Domain Information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDomainGetRequest
*/
func (a *DefaultAPIService) ObjectsDomainGet(ctx context.Context) ApiObjectsDomainGetRequest {
	return ApiObjectsDomainGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDomainGetExecute(r ApiObjectsDomainGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDomainGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/domain"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeApplication != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_application", r.includeApplication, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsDomainsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsDomainsGetRequest) Authorization(authorization string) ApiObjectsDomainsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsDomainsGetRequest) Accept(accept string) ApiObjectsDomainsGetRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsDomainsGetRequest) ContentType(contentType string) ApiObjectsDomainsGetRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsDomainsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsDomainsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsDomainsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsDomainsGetExecute(r)
}

/*
ObjectsDomainsGet Retrieve Domains

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsDomainsGetRequest
*/
func (a *DefaultAPIService) ObjectsDomainsGet(ctx context.Context) ApiObjectsDomainsGetRequest {
	return ApiObjectsDomainsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsDomainsGetExecute(r ApiObjectsDomainsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsDomainsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest) Authorization(authorization string) ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest) ContentType(contentType string) ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest) Accept(accept string) ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsEdlMatchedDocumentsBatchActionsAddPostExecute(r)
}

/*
ObjectsEdlMatchedDocumentsBatchActionsAddPost Add EDL Matched Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest
*/
func (a *DefaultAPIService) ObjectsEdlMatchedDocumentsBatchActionsAddPost(ctx context.Context) ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest {
	return ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsEdlMatchedDocumentsBatchActionsAddPostExecute(r ApiObjectsEdlMatchedDocumentsBatchActionsAddPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsEdlMatchedDocumentsBatchActionsAddPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/edl_matched_documents/batch/actions/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest) Authorization(authorization string) ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest) ContentType(contentType string) ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest) Accept(accept string) ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsEdlMatchedDocumentsBatchActionsRemovePostExecute(r)
}

/*
ObjectsEdlMatchedDocumentsBatchActionsRemovePost Remove EDL Matched Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest
*/
func (a *DefaultAPIService) ObjectsEdlMatchedDocumentsBatchActionsRemovePost(ctx context.Context) ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest {
	return ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsEdlMatchedDocumentsBatchActionsRemovePostExecute(r ApiObjectsEdlMatchedDocumentsBatchActionsRemovePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsEdlMatchedDocumentsBatchActionsRemovePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/edl_matched_documents/batch/actions/remove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsGroupsAutoGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	limit *string
	offset *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Paginate the results by specifying the maximum number of records per page in the response. This can be any value between 1 and 1000. If omitted, defaults to 1000. 
func (r ApiObjectsGroupsAutoGetRequest) Limit(limit string) ApiObjectsGroupsAutoGetRequest {
	r.limit = &limit
	return r
}

// Paginate the results displayed per page by specifying the amount of offset from the entry returned. For example, if you are viewing the first 50 results (page 1) and want to see the next page, set this to offset&#x3D;51. If omitted, defaults to 0.
func (r ApiObjectsGroupsAutoGetRequest) Offset(offset string) ApiObjectsGroupsAutoGetRequest {
	r.offset = &offset
	return r
}

func (r ApiObjectsGroupsAutoGetRequest) Authorization(authorization string) ApiObjectsGroupsAutoGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsGroupsAutoGetRequest) Accept(accept string) ApiObjectsGroupsAutoGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsGroupsAutoGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsGroupsAutoGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsGroupsAutoGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsGroupsAutoGetExecute(r)
}

/*
ObjectsGroupsAutoGet Retrieve Auto Managed Groups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsGroupsAutoGetRequest
*/
func (a *DefaultAPIService) ObjectsGroupsAutoGet(ctx context.Context) ApiObjectsGroupsAutoGetRequest {
	return ApiObjectsGroupsAutoGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsGroupsAutoGetExecute(r ApiObjectsGroupsAutoGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsGroupsAutoGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/groups/auto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsGroupsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	includeImplied *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When true, the response includes the implied_members__v field. These users are automatically added to the group when their security_profiles__v are added to the group. If omitted, the response includes only the members__v field. These users are individually added to a group by an Admin.
func (r ApiObjectsGroupsGetRequest) IncludeImplied(includeImplied string) ApiObjectsGroupsGetRequest {
	r.includeImplied = &includeImplied
	return r
}

func (r ApiObjectsGroupsGetRequest) Authorization(authorization string) ApiObjectsGroupsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsGroupsGetRequest) Accept(accept string) ApiObjectsGroupsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsGroupsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsGroupsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsGroupsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsGroupsGetExecute(r)
}

/*
ObjectsGroupsGet Retrieve All Groups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsGroupsGetRequest
*/
func (a *DefaultAPIService) ObjectsGroupsGet(ctx context.Context) ApiObjectsGroupsGetRequest {
	return ApiObjectsGroupsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsGroupsGetExecute(r ApiObjectsGroupsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsGroupsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeImplied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeImplied", r.includeImplied, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsGroupsGroupIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	groupId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsGroupsGroupIdDeleteRequest) Authorization(authorization string) ApiObjectsGroupsGroupIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsGroupsGroupIdDeleteRequest) Accept(accept string) ApiObjectsGroupsGroupIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsGroupsGroupIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsGroupsGroupIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsGroupsGroupIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsGroupsGroupIdDeleteExecute(r)
}

/*
ObjectsGroupsGroupIdDelete Delete Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The group id field value.
 @return ApiObjectsGroupsGroupIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsGroupsGroupIdDelete(ctx context.Context, groupId string) ApiObjectsGroupsGroupIdDeleteRequest {
	return ApiObjectsGroupsGroupIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsGroupsGroupIdDeleteExecute(r ApiObjectsGroupsGroupIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsGroupsGroupIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsGroupsGroupIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	groupId string
	includeImplied *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When true, the response includes the implied_members__v field. These users are automatically added to the group when their security_profiles__v are added to the group. When not used, the response includes only the members__v field. These users are individually added to a group by Admin.
func (r ApiObjectsGroupsGroupIdGetRequest) IncludeImplied(includeImplied bool) ApiObjectsGroupsGroupIdGetRequest {
	r.includeImplied = &includeImplied
	return r
}

func (r ApiObjectsGroupsGroupIdGetRequest) Authorization(authorization string) ApiObjectsGroupsGroupIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsGroupsGroupIdGetRequest) Accept(accept string) ApiObjectsGroupsGroupIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsGroupsGroupIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsGroupsGroupIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsGroupsGroupIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsGroupsGroupIdGetExecute(r)
}

/*
ObjectsGroupsGroupIdGet Retrieve Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The group id field value.
 @return ApiObjectsGroupsGroupIdGetRequest
*/
func (a *DefaultAPIService) ObjectsGroupsGroupIdGet(ctx context.Context, groupId string) ApiObjectsGroupsGroupIdGetRequest {
	return ApiObjectsGroupsGroupIdGetRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsGroupsGroupIdGetExecute(r ApiObjectsGroupsGroupIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsGroupsGroupIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeImplied != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeImplied", r.includeImplied, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsGroupsGroupIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	groupId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsGroupsGroupIdPutRequest) Authorization(authorization string) ApiObjectsGroupsGroupIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsGroupsGroupIdPutRequest) Accept(accept string) ApiObjectsGroupsGroupIdPutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsGroupsGroupIdPutRequest) ContentType(contentType string) ApiObjectsGroupsGroupIdPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsGroupsGroupIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsGroupsGroupIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsGroupsGroupIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsGroupsGroupIdPutExecute(r)
}

/*
ObjectsGroupsGroupIdPut Update Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId The group id field value.
 @return ApiObjectsGroupsGroupIdPutRequest
*/
func (a *DefaultAPIService) ObjectsGroupsGroupIdPut(ctx context.Context, groupId string) ApiObjectsGroupsGroupIdPutRequest {
	return ApiObjectsGroupsGroupIdPutRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsGroupsGroupIdPutExecute(r ApiObjectsGroupsGroupIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsGroupsGroupIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/groups/{group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_id"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsGroupsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsGroupsPostRequest) Authorization(authorization string) ApiObjectsGroupsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsGroupsPostRequest) Accept(accept string) ApiObjectsGroupsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsGroupsPostRequest) ContentType(contentType string) ApiObjectsGroupsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsGroupsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsGroupsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsGroupsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsGroupsPostExecute(r)
}

/*
ObjectsGroupsPost Create Group 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsGroupsPostRequest
*/
func (a *DefaultAPIService) ObjectsGroupsPost(ctx context.Context) ApiObjectsGroupsPostRequest {
	return ApiObjectsGroupsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsGroupsPostExecute(r ApiObjectsGroupsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsGroupsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsLicensesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsLicensesGetRequest) Authorization(authorization string) ApiObjectsLicensesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsLicensesGetRequest) Accept(accept string) ApiObjectsLicensesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsLicensesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsLicensesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsLicensesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsLicensesGetExecute(r)
}

/*
ObjectsLicensesGet Retrieve Application License Usage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsLicensesGetRequest
*/
func (a *DefaultAPIService) ObjectsLicensesGet(ctx context.Context) ApiObjectsLicensesGetRequest {
	return ApiObjectsLicensesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsLicensesGetExecute(r ApiObjectsLicensesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsLicensesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/licenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsActionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsActionsGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsActionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsActionsGetRequest) Accept(accept string) ApiObjectsObjectworkflowsActionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsActionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsActionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsActionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsActionsGetExecute(r)
}

/*
ObjectsObjectworkflowsActionsGet Retrieve All Multi-Record Workflows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsObjectworkflowsActionsGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsActionsGet(ctx context.Context) ApiObjectsObjectworkflowsActionsGetRequest {
	return ApiObjectsObjectworkflowsActionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsActionsGetExecute(r ApiObjectsObjectworkflowsActionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsActionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	workflowName string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsActionsWorkflowNameGetExecute(r)
}

/*
ObjectsObjectworkflowsActionsWorkflowNameGet Retrieve Multi-Record Workflow Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowName
 @return ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsActionsWorkflowNameGet(ctx context.Context, workflowName string) ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest {
	return ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest{
		ApiService: a,
		ctx: ctx,
		workflowName: workflowName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsActionsWorkflowNameGetExecute(r ApiObjectsObjectworkflowsActionsWorkflowNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsActionsWorkflowNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/actions/{workflow_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_name"+"}", url.PathEscape(parameterValueToString(r.workflowName, "workflowName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	workflowName string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest) Accept(accept string) ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsActionsWorkflowNamePostExecute(r)
}

/*
ObjectsObjectworkflowsActionsWorkflowNamePost Initiate Multi-Record Workflow

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowName
 @return ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsActionsWorkflowNamePost(ctx context.Context, workflowName string) ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest {
	return ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest{
		ApiService: a,
		ctx: ctx,
		workflowName: workflowName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsActionsWorkflowNamePostExecute(r ApiObjectsObjectworkflowsActionsWorkflowNamePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsActionsWorkflowNamePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/actions/{workflow_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_name"+"}", url.PathEscape(parameterValueToString(r.workflowName, "workflowName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectV *string
	recordIdV *string
	participant *string
	statusV *string
	offset *string
	pageSize *string
	loc *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// To retrieve all workflows configured on an object, include the Vault object name__v and object record id field values as ?object__v&#x3D;{name__v}&amp;record_id__v&#x3D;{id}. These two parameters are required when the participant parameter is not used. 
func (r ApiObjectsObjectworkflowsGetRequest) ObjectV(objectV string) ApiObjectsObjectworkflowsGetRequest {
	r.objectV = &objectV
	return r
}

// To retrieve all workflows configured on an object, include the Vault object name__v and object record id field values as ?object__v&#x3D;{name__v}&amp;record_id__v&#x3D;{id}. These two parameters are required when the participant parameter is not used. 
func (r ApiObjectsObjectworkflowsGetRequest) RecordIdV(recordIdV string) ApiObjectsObjectworkflowsGetRequest {
	r.recordIdV = &recordIdV
	return r
}

// To retrieve all workflows available to a particular user, include the user id field value as ?participant&#x3D;{id}. To retrieve your own workflows, set this value to ?participant&#x3D;me. This parameter is required when the object__v and record_id__v parameters are not used. 
func (r ApiObjectsObjectworkflowsGetRequest) Participant(participant string) ApiObjectsObjectworkflowsGetRequest {
	r.participant = &participant
	return r
}

// To retrieve all workflows with specific statuses, include one or more status name__v field values. For example: status__v&#x3D;active__v, status__v&#x3D;active__v,completed__v. Workflows with &#x60;status__v&#x3D;active__v&#x60; are in progress for the indicated object record. Valid statuses include: active__v completed__v cancelled__v
func (r ApiObjectsObjectworkflowsGetRequest) StatusV(statusV string) ApiObjectsObjectworkflowsGetRequest {
	r.statusV = &statusV
	return r
}

// This parameter is used to paginate the results. It specifies the amount of offset from the first record returned. Vault returns 200 records per page by default. If you are viewing the first 200 results (page 1) and want to see the next page, set this to ?offset&#x3D;201. 
func (r ApiObjectsObjectworkflowsGetRequest) Offset(offset string) ApiObjectsObjectworkflowsGetRequest {
	r.offset = &offset
	return r
}

// This parameter is used to paginate the results. It specifies the size number of records to display per page. Vault returns 200 records per page by default. You can set this value lower or as high as 1000 records per page. For example: ?page_size&#x3D;1000. 
func (r ApiObjectsObjectworkflowsGetRequest) PageSize(pageSize string) ApiObjectsObjectworkflowsGetRequest {
	r.pageSize = &pageSize
	return r
}

// When localized (translated) strings are available, retrieve them by including ?loc&#x3D;true. 
func (r ApiObjectsObjectworkflowsGetRequest) Loc(loc string) ApiObjectsObjectworkflowsGetRequest {
	r.loc = &loc
	return r
}

func (r ApiObjectsObjectworkflowsGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsGetRequest) Accept(accept string) ApiObjectsObjectworkflowsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsGetExecute(r)
}

/*
ObjectsObjectworkflowsGet Retrieve Workflows

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsObjectworkflowsGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsGet(ctx context.Context) ApiObjectsObjectworkflowsGetRequest {
	return ApiObjectsObjectworkflowsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsGetExecute(r ApiObjectsObjectworkflowsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.objectV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object__v", r.objectV, "form", "")
	}
	if r.recordIdV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "record_id__v", r.recordIdV, "form", "")
	}
	if r.participant != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "participant", r.participant, "form", "")
	}
	if r.statusV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__v", r.statusV, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectV *string
	recordIdV *string
	assigneeV *string
	statusV *string
	offset *string
	pageSize *string
	loc *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// To retrieve all workflow tasks configured on an object, include the Vault object name__v and object record id field values as ?object__v&#x3D;{name__v}&amp;record_id__v&#x3D;{id}. These two parameters are required when the assignee__v parameter is not used.
func (r ApiObjectsObjectworkflowsTasksGetRequest) ObjectV(objectV string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.objectV = &objectV
	return r
}

// To retrieve all workflow tasks configured on an object, include the Vault object name__v and object record id field values as ?object__v&#x3D;{name__v}&amp;record_id__v&#x3D;{id}. These two parameters are required when the assignee__v parameter is not used.
func (r ApiObjectsObjectworkflowsTasksGetRequest) RecordIdV(recordIdV string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.recordIdV = &recordIdV
	return r
}

// To retrieve all workflow tasks available to a particular user, include the user id field value as ?assignee__v&#x3D;{id}. To retrieve your own workflow tasks, set this value to ?assignee__v&#x3D;me. This parameter is required when the object__v and record_id__v parameters are not used. 
func (r ApiObjectsObjectworkflowsTasksGetRequest) AssigneeV(assigneeV string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.assigneeV = &assigneeV
	return r
}

// To retrieve all workflow tasks with specific statuses, include one or more status name__v field values. For example: ?status__v&#x3D;available__v or ?status__v&#x3D;available__v,completed__v. 
func (r ApiObjectsObjectworkflowsTasksGetRequest) StatusV(statusV string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.statusV = &statusV
	return r
}

// This parameter is used to paginate the results. It specifies the amount of offset from the first record returned. Vault returns 200 records per page by default. If you are viewing the first 200 results (page 1) and want to see the next page, set this to ?offset&#x3D;201. 
func (r ApiObjectsObjectworkflowsTasksGetRequest) Offset(offset string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.offset = &offset
	return r
}

// This parameter is used to paginate the results. It specifies the size number of records to display per page. Vault returns 200 records per page by default. You can set this value lower or as high as 1000 records per page. For example: ?page_size&#x3D;1000. 
func (r ApiObjectsObjectworkflowsTasksGetRequest) PageSize(pageSize string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.pageSize = &pageSize
	return r
}

// When localized (translated) strings are available, retrieve them by including ?loc&#x3D;true. 
func (r ApiObjectsObjectworkflowsTasksGetRequest) Loc(loc string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.loc = &loc
	return r
}

func (r ApiObjectsObjectworkflowsTasksGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksGetRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksGetExecute(r)
}

/*
ObjectsObjectworkflowsTasksGet Retrieve Workflow Tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsObjectworkflowsTasksGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksGet(ctx context.Context) ApiObjectsObjectworkflowsTasksGetRequest {
	return ApiObjectsObjectworkflowsTasksGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksGetExecute(r ApiObjectsObjectworkflowsTasksGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.objectV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "object__v", r.objectV, "form", "")
	}
	if r.recordIdV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "record_id__v", r.recordIdV, "form", "")
	}
	if r.assigneeV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assignee__v", r.assigneeV, "form", "")
	}
	if r.statusV != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status__v", r.statusV, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	}
	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsAcceptPost Accept Single Record Workflow Task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsAcceptPost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsAcceptPostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsAcceptPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsAcceptPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/accept"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsCancelPostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsCancelPost Cancel Workflow Task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsCancelPost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsCancelPostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsCancelPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsCancelPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsCompletePostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsCompletePost Complete Single Record Workflow Task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsCompletePost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsCompletePostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsCompletePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsCompletePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/complete"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsGetExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsGet Retrieve Workflow Task Actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsGet(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsGetExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPost Accept Multi-item Workflow Task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsMdwacceptPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/mdwaccept"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePost Complete Multi-item Workflow Task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsMdwcompletePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/mdwcomplete"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost Manage Multi-Item Workflow Content

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/mdwmanagecontent"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPost Reassign Multi-item Workflow Task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The id of the task to reassign.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsMdwreassignPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/mdwreassign"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsReassignPostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsReassignPost Reassign Single Record Workflow Task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The id of the task to reassign.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsReassignPost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsReassignPostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsReassignPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsReassignPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/reassign"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	taskAction string
	loc *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When localized (translated) strings are available, retrieve them by including loc&#x3D;true. 
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest) Loc(loc string) ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest {
	r.loc = &loc
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGet Retrieve Workflow Task Action Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @param taskAction The name of the task action retrieved from Retrieve Workflow Task Actions.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGet(ctx context.Context, taskId string, taskAction string) ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
		taskAction: taskAction,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsTaskActionGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsTaskActionGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/{task_action}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_action"+"}", url.PathEscape(parameterValueToString(r.taskAction, "taskAction")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPost Undo Workflow Task Acceptance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsUndoacceptPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/undoaccept"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost Update Workflow Task Due Date

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The id of the task.
 @return ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostExecute(r ApiObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdActionsUpdateduedatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}/actions/updateduedate"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsTasksTaskIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	taskId string
	loc *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When localized (translated) strings are available, retrieve them by including loc&#x3D;true.
func (r ApiObjectsObjectworkflowsTasksTaskIdGetRequest) Loc(loc bool) ApiObjectsObjectworkflowsTasksTaskIdGetRequest {
	r.loc = &loc
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsTasksTaskIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdGetRequest) Accept(accept string) ApiObjectsObjectworkflowsTasksTaskIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsTasksTaskIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsTasksTaskIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsTasksTaskIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsTasksTaskIdGetExecute(r)
}

/*
ObjectsObjectworkflowsTasksTaskIdGet Retrieve Workflow Task Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The task id field value.
 @return ApiObjectsObjectworkflowsTasksTaskIdGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdGet(ctx context.Context, taskId string) ApiObjectsObjectworkflowsTasksTaskIdGetRequest {
	return ApiObjectsObjectworkflowsTasksTaskIdGetRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsTasksTaskIdGetExecute(r ApiObjectsObjectworkflowsTasksTaskIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsTasksTaskIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	workflowId string
	loc *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When localized (translated) strings are available, retrieve them by including loc&#x3D;true. 
func (r ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest) Loc(loc string) ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest {
	r.loc = &loc
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest) Accept(accept string) ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsWorkflowIdActionsGetExecute(r)
}

/*
ObjectsObjectworkflowsWorkflowIdActionsGet Retrieve Workflow Actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The workflow id field value.
 @return ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsWorkflowIdActionsGet(ctx context.Context, workflowId string) ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest {
	return ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsWorkflowIdActionsGetExecute(r ApiObjectsObjectworkflowsWorkflowIdActionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsWorkflowIdActionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/{workflow_id}/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	workflowId string
	workflowAction string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest) Accept(accept string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetExecute(r)
}

/*
ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGet Retrieve Workflow Action Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The workflow id field value.
 @param workflowAction The workflow action name retrieved from Retrieve Workflow Actions.
 @return ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGet(ctx context.Context, workflowId string, workflowAction string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest {
	return ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowAction: workflowAction,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetExecute(r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/{workflow_id}/actions/{workflow_action}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_action"+"}", url.PathEscape(parameterValueToString(r.workflowAction, "workflowAction")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	workflowId string
	workflowAction string
	documentsSys *string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

// Include the id or ids as a comma-separated list of the document(s) to be removed from a document workflow when using the removecontent action. If your workflow_action is remove_content, include the id of the document to remove the workflow. To remove multiple documents, use a comma-separated list of ids.
func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest) DocumentsSys(documentsSys string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest {
	r.documentsSys = &documentsSys
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest) Authorization(authorization string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest) ContentType(contentType string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest) Accept(accept string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostExecute(r)
}

/*
ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPost Initiate Workflow Action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The workflow id field value.
 @param workflowAction The workflow action name retrieved from Retrieve Workflow Actions.
 @return ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPost(ctx context.Context, workflowId string, workflowAction string) ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest {
	return ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowAction: workflowAction,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostExecute(r ApiObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsWorkflowIdActionsWorkflowActionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/{workflow_id}/actions/{workflow_action}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_action"+"}", url.PathEscape(parameterValueToString(r.workflowAction, "workflowAction")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.documentsSys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "documents__sys", r.documentsSys, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsObjectworkflowsWorkflowIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	workflowId string
	loc *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When localized (translated) strings are available, retrieve them by including loc&#x3D;true.
func (r ApiObjectsObjectworkflowsWorkflowIdGetRequest) Loc(loc bool) ApiObjectsObjectworkflowsWorkflowIdGetRequest {
	r.loc = &loc
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdGetRequest) Authorization(authorization string) ApiObjectsObjectworkflowsWorkflowIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdGetRequest) Accept(accept string) ApiObjectsObjectworkflowsWorkflowIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsObjectworkflowsWorkflowIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsObjectworkflowsWorkflowIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsObjectworkflowsWorkflowIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsObjectworkflowsWorkflowIdGetExecute(r)
}

/*
ObjectsObjectworkflowsWorkflowIdGet Retrieve Workflow Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The workflow id field value.
 @return ApiObjectsObjectworkflowsWorkflowIdGetRequest
*/
func (a *DefaultAPIService) ObjectsObjectworkflowsWorkflowIdGet(ctx context.Context, workflowId string) ApiObjectsObjectworkflowsWorkflowIdGetRequest {
	return ApiObjectsObjectworkflowsWorkflowIdGetRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsObjectworkflowsWorkflowIdGetExecute(r ApiObjectsObjectworkflowsWorkflowIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsObjectworkflowsWorkflowIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/objectworkflows/{workflow_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsPicklistsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsPicklistsGetRequest) Authorization(authorization string) ApiObjectsPicklistsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsPicklistsGetRequest) Accept(accept string) ApiObjectsPicklistsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsPicklistsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsPicklistsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsPicklistsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsPicklistsGetExecute(r)
}

/*
ObjectsPicklistsGet Retrieve All Picklists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsPicklistsGetRequest
*/
func (a *DefaultAPIService) ObjectsPicklistsGet(ctx context.Context) ApiObjectsPicklistsGetRequest {
	return ApiObjectsPicklistsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsPicklistsGetExecute(r ApiObjectsPicklistsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsPicklistsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/picklists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsPicklistsPicklistNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	picklistName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsPicklistsPicklistNameGetRequest) Authorization(authorization string) ApiObjectsPicklistsPicklistNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsPicklistsPicklistNameGetRequest) Accept(accept string) ApiObjectsPicklistsPicklistNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsPicklistsPicklistNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsPicklistsPicklistNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsPicklistsPicklistNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsPicklistsPicklistNameGetExecute(r)
}

/*
ObjectsPicklistsPicklistNameGet Retrieve Picklist Values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param picklistName The picklist name field value (license_type__v, product_family__c, region__c, etc.)
 @return ApiObjectsPicklistsPicklistNameGetRequest
*/
func (a *DefaultAPIService) ObjectsPicklistsPicklistNameGet(ctx context.Context, picklistName string) ApiObjectsPicklistsPicklistNameGetRequest {
	return ApiObjectsPicklistsPicklistNameGetRequest{
		ApiService: a,
		ctx: ctx,
		picklistName: picklistName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsPicklistsPicklistNameGetExecute(r ApiObjectsPicklistsPicklistNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsPicklistsPicklistNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/picklists/{picklist_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"picklist_name"+"}", url.PathEscape(parameterValueToString(r.picklistName, "picklistName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	picklistName string
	picklistValueName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest) Authorization(authorization string) ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest) Accept(accept string) ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsPicklistsPicklistNamePicklistValueNameDeleteExecute(r)
}

/*
ObjectsPicklistsPicklistNamePicklistValueNameDelete Inactivate Picklist Value

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param picklistName The picklist name field value (license_type__v, product_family__c, region__c, etc.)
 @param picklistValueName The picklist value name field value (north_america__c, south_america__c, etc.)
 @return ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest
*/
func (a *DefaultAPIService) ObjectsPicklistsPicklistNamePicklistValueNameDelete(ctx context.Context, picklistName string, picklistValueName string) ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest {
	return ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		picklistName: picklistName,
		picklistValueName: picklistValueName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsPicklistsPicklistNamePicklistValueNameDeleteExecute(r ApiObjectsPicklistsPicklistNamePicklistValueNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsPicklistsPicklistNamePicklistValueNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/picklists/{picklist_name}/{picklist_value_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"picklist_name"+"}", url.PathEscape(parameterValueToString(r.picklistName, "picklistName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"picklist_value_name"+"}", url.PathEscape(parameterValueToString(r.picklistValueName, "picklistValueName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	picklistName string
	picklistValueName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest) Authorization(authorization string) ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest) Accept(accept string) ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest) ContentType(contentType string) ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsPicklistsPicklistNamePicklistValueNamePutExecute(r)
}

/*
ObjectsPicklistsPicklistNamePicklistValueNamePut Update Picklist Value

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param picklistName The picklist name field value (license_type__v, product_family__c, region__c, etc.)
 @param picklistValueName The picklist value name field value (north_america__c, south_america__c, etc.)
 @return ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest
*/
func (a *DefaultAPIService) ObjectsPicklistsPicklistNamePicklistValueNamePut(ctx context.Context, picklistName string, picklistValueName string) ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest {
	return ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest{
		ApiService: a,
		ctx: ctx,
		picklistName: picklistName,
		picklistValueName: picklistValueName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsPicklistsPicklistNamePicklistValueNamePutExecute(r ApiObjectsPicklistsPicklistNamePicklistValueNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsPicklistsPicklistNamePicklistValueNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/picklists/{picklist_name}/{picklist_value_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"picklist_name"+"}", url.PathEscape(parameterValueToString(r.picklistName, "picklistName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"picklist_value_name"+"}", url.PathEscape(parameterValueToString(r.picklistValueName, "picklistValueName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsPicklistsPicklistNamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	picklistName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsPicklistsPicklistNamePostRequest) Authorization(authorization string) ApiObjectsPicklistsPicklistNamePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsPicklistsPicklistNamePostRequest) Accept(accept string) ApiObjectsPicklistsPicklistNamePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsPicklistsPicklistNamePostRequest) ContentType(contentType string) ApiObjectsPicklistsPicklistNamePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsPicklistsPicklistNamePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsPicklistsPicklistNamePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsPicklistsPicklistNamePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsPicklistsPicklistNamePostExecute(r)
}

/*
ObjectsPicklistsPicklistNamePost Create Picklist Values

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param picklistName The picklist name field value (license_type__v, product_family__c, region__c, etc.)
 @return ApiObjectsPicklistsPicklistNamePostRequest
*/
func (a *DefaultAPIService) ObjectsPicklistsPicklistNamePost(ctx context.Context, picklistName string) ApiObjectsPicklistsPicklistNamePostRequest {
	return ApiObjectsPicklistsPicklistNamePostRequest{
		ApiService: a,
		ctx: ctx,
		picklistName: picklistName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsPicklistsPicklistNamePostExecute(r ApiObjectsPicklistsPicklistNamePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsPicklistsPicklistNamePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/picklists/{picklist_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"picklist_name"+"}", url.PathEscape(parameterValueToString(r.picklistName, "picklistName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsPicklistsPicklistNamePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	picklistName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsPicklistsPicklistNamePutRequest) Authorization(authorization string) ApiObjectsPicklistsPicklistNamePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsPicklistsPicklistNamePutRequest) Accept(accept string) ApiObjectsPicklistsPicklistNamePutRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsPicklistsPicklistNamePutRequest) ContentType(contentType string) ApiObjectsPicklistsPicklistNamePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsPicklistsPicklistNamePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsPicklistsPicklistNamePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsPicklistsPicklistNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsPicklistsPicklistNamePutExecute(r)
}

/*
ObjectsPicklistsPicklistNamePut Update Picklist Value Label

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param picklistName The picklist name field value (license_type__v, product_family__c, region__c, etc.)
 @return ApiObjectsPicklistsPicklistNamePutRequest
*/
func (a *DefaultAPIService) ObjectsPicklistsPicklistNamePut(ctx context.Context, picklistName string) ApiObjectsPicklistsPicklistNamePutRequest {
	return ApiObjectsPicklistsPicklistNamePutRequest{
		ApiService: a,
		ctx: ctx,
		picklistName: picklistName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsPicklistsPicklistNamePutExecute(r ApiObjectsPicklistsPicklistNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsPicklistsPicklistNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/picklists/{picklist_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"picklist_name"+"}", url.PathEscape(parameterValueToString(r.picklistName, "picklistName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxActionsBuildproductionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxActionsBuildproductionPostRequest) Authorization(authorization string) ApiObjectsSandboxActionsBuildproductionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxActionsBuildproductionPostRequest) Accept(accept string) ApiObjectsSandboxActionsBuildproductionPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsSandboxActionsBuildproductionPostRequest) ContentType(contentType string) ApiObjectsSandboxActionsBuildproductionPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxActionsBuildproductionPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxActionsBuildproductionPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxActionsBuildproductionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxActionsBuildproductionPostExecute(r)
}

/*
ObjectsSandboxActionsBuildproductionPost Build Production Vault

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSandboxActionsBuildproductionPostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxActionsBuildproductionPost(ctx context.Context) ApiObjectsSandboxActionsBuildproductionPostRequest {
	return ApiObjectsSandboxActionsBuildproductionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxActionsBuildproductionPostExecute(r ApiObjectsSandboxActionsBuildproductionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxActionsBuildproductionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/actions/buildproduction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxActionsPromoteproductionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxActionsPromoteproductionPostRequest) Authorization(authorization string) ApiObjectsSandboxActionsPromoteproductionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxActionsPromoteproductionPostRequest) Accept(accept string) ApiObjectsSandboxActionsPromoteproductionPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsSandboxActionsPromoteproductionPostRequest) ContentType(contentType string) ApiObjectsSandboxActionsPromoteproductionPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxActionsPromoteproductionPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxActionsPromoteproductionPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxActionsPromoteproductionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxActionsPromoteproductionPostExecute(r)
}

/*
ObjectsSandboxActionsPromoteproductionPost Promote to Production

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSandboxActionsPromoteproductionPostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxActionsPromoteproductionPost(ctx context.Context) ApiObjectsSandboxActionsPromoteproductionPostRequest {
	return ApiObjectsSandboxActionsPromoteproductionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxActionsPromoteproductionPostExecute(r ApiObjectsSandboxActionsPromoteproductionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxActionsPromoteproductionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/actions/promoteproduction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxActionsRecheckusagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxActionsRecheckusagePostRequest) Authorization(authorization string) ApiObjectsSandboxActionsRecheckusagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxActionsRecheckusagePostRequest) Accept(accept string) ApiObjectsSandboxActionsRecheckusagePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsSandboxActionsRecheckusagePostRequest) ContentType(contentType string) ApiObjectsSandboxActionsRecheckusagePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxActionsRecheckusagePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxActionsRecheckusagePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxActionsRecheckusagePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxActionsRecheckusagePostExecute(r)
}

/*
ObjectsSandboxActionsRecheckusagePost Recheck Sandbox Usage Limit

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSandboxActionsRecheckusagePostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxActionsRecheckusagePost(ctx context.Context) ApiObjectsSandboxActionsRecheckusagePostRequest {
	return ApiObjectsSandboxActionsRecheckusagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxActionsRecheckusagePostExecute(r ApiObjectsSandboxActionsRecheckusagePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxActionsRecheckusagePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/actions/recheckusage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxBatchChangesizePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxBatchChangesizePostRequest) Authorization(authorization string) ApiObjectsSandboxBatchChangesizePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxBatchChangesizePostRequest) Accept(accept string) ApiObjectsSandboxBatchChangesizePostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsSandboxBatchChangesizePostRequest) ContentType(contentType string) ApiObjectsSandboxBatchChangesizePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxBatchChangesizePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxBatchChangesizePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxBatchChangesizePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxBatchChangesizePostExecute(r)
}

/*
ObjectsSandboxBatchChangesizePost Change Sandbox Size

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSandboxBatchChangesizePostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxBatchChangesizePost(ctx context.Context) ApiObjectsSandboxBatchChangesizePostRequest {
	return ApiObjectsSandboxBatchChangesizePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxBatchChangesizePostExecute(r ApiObjectsSandboxBatchChangesizePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxBatchChangesizePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/batch/changesize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxEntitlementsSetPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxEntitlementsSetPostRequest) Authorization(authorization string) ApiObjectsSandboxEntitlementsSetPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxEntitlementsSetPostRequest) Accept(accept string) ApiObjectsSandboxEntitlementsSetPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsSandboxEntitlementsSetPostRequest) ContentType(contentType string) ApiObjectsSandboxEntitlementsSetPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxEntitlementsSetPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxEntitlementsSetPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxEntitlementsSetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxEntitlementsSetPostExecute(r)
}

/*
ObjectsSandboxEntitlementsSetPost Set Sandbox Entitlements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSandboxEntitlementsSetPostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxEntitlementsSetPost(ctx context.Context) ApiObjectsSandboxEntitlementsSetPostRequest {
	return ApiObjectsSandboxEntitlementsSetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxEntitlementsSetPostExecute(r ApiObjectsSandboxEntitlementsSetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxEntitlementsSetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/entitlements/set"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxGetRequest) Authorization(authorization string) ApiObjectsSandboxGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxGetRequest) Accept(accept string) ApiObjectsSandboxGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxGetExecute(r)
}

/*
ObjectsSandboxGet Retrieve Sandboxes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSandboxGetRequest
*/
func (a *DefaultAPIService) ObjectsSandboxGet(ctx context.Context) ApiObjectsSandboxGetRequest {
	return ApiObjectsSandboxGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxGetExecute(r ApiObjectsSandboxGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxNameDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxNameDeleteRequest) Authorization(authorization string) ApiObjectsSandboxNameDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxNameDeleteRequest) Accept(accept string) ApiObjectsSandboxNameDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxNameDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxNameDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxNameDeleteExecute(r)
}

/*
ObjectsSandboxNameDelete Delete Sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the sandbox vault to delete. This is the name which appears on the My Vaults page.
 @return ApiObjectsSandboxNameDeleteRequest
*/
func (a *DefaultAPIService) ObjectsSandboxNameDelete(ctx context.Context, name string) ApiObjectsSandboxNameDeleteRequest {
	return ApiObjectsSandboxNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxNameDeleteExecute(r ApiObjectsSandboxNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxPostRequest) Authorization(authorization string) ApiObjectsSandboxPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxPostRequest) Accept(accept string) ApiObjectsSandboxPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsSandboxPostRequest) ContentType(contentType string) ApiObjectsSandboxPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxPostExecute(r)
}

/*
ObjectsSandboxPost Create or Refresh Sandbox

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSandboxPostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxPost(ctx context.Context) ApiObjectsSandboxPostRequest {
	return ApiObjectsSandboxPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxPostExecute(r ApiObjectsSandboxPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	apiName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest) Authorization(authorization string) ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest) Accept(accept string) ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxSnapshotApiNameActionsUpdatePostExecute(r)
}

/*
ObjectsSandboxSnapshotApiNameActionsUpdatePost Update Sandbox Snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiName The Vault ID of the sandbox. Obtain this from the Retrieve Sandbox Snapshots request.
 @return ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxSnapshotApiNameActionsUpdatePost(ctx context.Context, apiName string) ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest {
	return ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest{
		ApiService: a,
		ctx: ctx,
		apiName: apiName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxSnapshotApiNameActionsUpdatePostExecute(r ApiObjectsSandboxSnapshotApiNameActionsUpdatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxSnapshotApiNameActionsUpdatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/snapshot/{api_name}/actions/update"
	localVarPath = strings.Replace(localVarPath, "{"+"api_name"+"}", url.PathEscape(parameterValueToString(r.apiName, "apiName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	apiName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest) Authorization(authorization string) ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest) Accept(accept string) ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxSnapshotApiNameActionsUpgradePostExecute(r)
}

/*
ObjectsSandboxSnapshotApiNameActionsUpgradePost Upgrade Sandbox Snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiName The Vault ID of the sandbox. Obtain this from the Retrieve Sandbox Snapshots request.
 @return ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxSnapshotApiNameActionsUpgradePost(ctx context.Context, apiName string) ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest {
	return ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest{
		ApiService: a,
		ctx: ctx,
		apiName: apiName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxSnapshotApiNameActionsUpgradePostExecute(r ApiObjectsSandboxSnapshotApiNameActionsUpgradePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxSnapshotApiNameActionsUpgradePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/snapshot/{api_name}/actions/upgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"api_name"+"}", url.PathEscape(parameterValueToString(r.apiName, "apiName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxSnapshotApiNameDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	apiName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxSnapshotApiNameDeleteRequest) Authorization(authorization string) ApiObjectsSandboxSnapshotApiNameDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxSnapshotApiNameDeleteRequest) Accept(accept string) ApiObjectsSandboxSnapshotApiNameDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxSnapshotApiNameDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxSnapshotApiNameDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxSnapshotApiNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxSnapshotApiNameDeleteExecute(r)
}

/*
ObjectsSandboxSnapshotApiNameDelete Delete Sandbox Snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiName The Vault ID of the sandbox. Obtain this from the Retrieve Sandbox Snapshots request.
 @return ApiObjectsSandboxSnapshotApiNameDeleteRequest
*/
func (a *DefaultAPIService) ObjectsSandboxSnapshotApiNameDelete(ctx context.Context, apiName string) ApiObjectsSandboxSnapshotApiNameDeleteRequest {
	return ApiObjectsSandboxSnapshotApiNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		apiName: apiName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxSnapshotApiNameDeleteExecute(r ApiObjectsSandboxSnapshotApiNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxSnapshotApiNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/snapshot/{api_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"api_name"+"}", url.PathEscape(parameterValueToString(r.apiName, "apiName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxSnapshotGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxSnapshotGetRequest) Authorization(authorization string) ApiObjectsSandboxSnapshotGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxSnapshotGetRequest) Accept(accept string) ApiObjectsSandboxSnapshotGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxSnapshotGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxSnapshotGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxSnapshotGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxSnapshotGetExecute(r)
}

/*
ObjectsSandboxSnapshotGet Retrieve Sandbox Snapshots

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSandboxSnapshotGetRequest
*/
func (a *DefaultAPIService) ObjectsSandboxSnapshotGet(ctx context.Context) ApiObjectsSandboxSnapshotGetRequest {
	return ApiObjectsSandboxSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxSnapshotGetExecute(r ApiObjectsSandboxSnapshotGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxSnapshotGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxSnapshotPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxSnapshotPostRequest) Authorization(authorization string) ApiObjectsSandboxSnapshotPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxSnapshotPostRequest) Accept(accept string) ApiObjectsSandboxSnapshotPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsSandboxSnapshotPostRequest) ContentType(contentType string) ApiObjectsSandboxSnapshotPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxSnapshotPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxSnapshotPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxSnapshotPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxSnapshotPostExecute(r)
}

/*
ObjectsSandboxSnapshotPost Create Sandbox Snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSandboxSnapshotPostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxSnapshotPost(ctx context.Context) ApiObjectsSandboxSnapshotPostRequest {
	return ApiObjectsSandboxSnapshotPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxSnapshotPostExecute(r ApiObjectsSandboxSnapshotPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxSnapshotPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/snapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxVaultIdActionsRefreshPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	vaultId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxVaultIdActionsRefreshPostRequest) Authorization(authorization string) ApiObjectsSandboxVaultIdActionsRefreshPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxVaultIdActionsRefreshPostRequest) Accept(accept string) ApiObjectsSandboxVaultIdActionsRefreshPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsSandboxVaultIdActionsRefreshPostRequest) ContentType(contentType string) ApiObjectsSandboxVaultIdActionsRefreshPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxVaultIdActionsRefreshPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxVaultIdActionsRefreshPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxVaultIdActionsRefreshPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxVaultIdActionsRefreshPostExecute(r)
}

/*
ObjectsSandboxVaultIdActionsRefreshPost Refresh Sandbox from Snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultId The Vault ID of the sandbox to be refreshed.
 @return ApiObjectsSandboxVaultIdActionsRefreshPostRequest
*/
func (a *DefaultAPIService) ObjectsSandboxVaultIdActionsRefreshPost(ctx context.Context, vaultId string) ApiObjectsSandboxVaultIdActionsRefreshPostRequest {
	return ApiObjectsSandboxVaultIdActionsRefreshPostRequest{
		ApiService: a,
		ctx: ctx,
		vaultId: vaultId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxVaultIdActionsRefreshPostExecute(r ApiObjectsSandboxVaultIdActionsRefreshPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxVaultIdActionsRefreshPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/{vault_id}/actions/refresh"
	localVarPath = strings.Replace(localVarPath, "{"+"vault_id"+"}", url.PathEscape(parameterValueToString(r.vaultId, "vaultId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSandboxVaultIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	vaultId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSandboxVaultIdGetRequest) Authorization(authorization string) ApiObjectsSandboxVaultIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSandboxVaultIdGetRequest) Accept(accept string) ApiObjectsSandboxVaultIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSandboxVaultIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSandboxVaultIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSandboxVaultIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSandboxVaultIdGetExecute(r)
}

/*
ObjectsSandboxVaultIdGet Retrieve Sandbox Details by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param vaultId
 @return ApiObjectsSandboxVaultIdGetRequest
*/
func (a *DefaultAPIService) ObjectsSandboxVaultIdGet(ctx context.Context, vaultId string) ApiObjectsSandboxVaultIdGetRequest {
	return ApiObjectsSandboxVaultIdGetRequest{
		ApiService: a,
		ctx: ctx,
		vaultId: vaultId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSandboxVaultIdGetExecute(r ApiObjectsSandboxVaultIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSandboxVaultIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/sandbox/{vault_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"vault_id"+"}", url.PathEscape(parameterValueToString(r.vaultId, "vaultId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSecuritypoliciesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSecuritypoliciesGetRequest) Authorization(authorization string) ApiObjectsSecuritypoliciesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSecuritypoliciesGetRequest) Accept(accept string) ApiObjectsSecuritypoliciesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSecuritypoliciesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSecuritypoliciesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSecuritypoliciesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSecuritypoliciesGetExecute(r)
}

/*
ObjectsSecuritypoliciesGet Retrieve All Security Policies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsSecuritypoliciesGetRequest
*/
func (a *DefaultAPIService) ObjectsSecuritypoliciesGet(ctx context.Context) ApiObjectsSecuritypoliciesGetRequest {
	return ApiObjectsSecuritypoliciesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSecuritypoliciesGetExecute(r ApiObjectsSecuritypoliciesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSecuritypoliciesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/securitypolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	securityPolicyName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest) Authorization(authorization string) ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest) Accept(accept string) ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsSecuritypoliciesSecurityPolicyNameGetExecute(r)
}

/*
ObjectsSecuritypoliciesSecurityPolicyNameGet Retrieve Security Policy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securityPolicyName Security policy name__v field value (retrieved from previous request). This is typically a numeric value.
 @return ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest
*/
func (a *DefaultAPIService) ObjectsSecuritypoliciesSecurityPolicyNameGet(ctx context.Context, securityPolicyName string) ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest {
	return ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest{
		ApiService: a,
		ctx: ctx,
		securityPolicyName: securityPolicyName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsSecuritypoliciesSecurityPolicyNameGetExecute(r ApiObjectsSecuritypoliciesSecurityPolicyNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsSecuritypoliciesSecurityPolicyNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/securitypolicies/{security_policy_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"security_policy_name"+"}", url.PathEscape(parameterValueToString(r.securityPolicyName, "securityPolicyName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	vaults *string
	excludeVaultMembership *string
	excludeAppLicensing *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Retrieve all users assigned to all Vaults in your domain.
func (r ApiObjectsUsersGetRequest) Vaults(vaults string) ApiObjectsUsersGetRequest {
	r.vaults = &vaults
	return r
}

// Optional: Set to false to include vault_membership fields. If true or omitted, vault_membership fields are not included in the response.
func (r ApiObjectsUsersGetRequest) ExcludeVaultMembership(excludeVaultMembership string) ApiObjectsUsersGetRequest {
	r.excludeVaultMembership = &excludeVaultMembership
	return r
}

// Optional: Set to false to include app_licensing fields. If true or omitted, app_licensing fields are not included in the response.
func (r ApiObjectsUsersGetRequest) ExcludeAppLicensing(excludeAppLicensing string) ApiObjectsUsersGetRequest {
	r.excludeAppLicensing = &excludeAppLicensing
	return r
}

func (r ApiObjectsUsersGetRequest) Authorization(authorization string) ApiObjectsUsersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersGetRequest) Accept(accept string) ApiObjectsUsersGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersGetExecute(r)
}

/*
ObjectsUsersGet Retrieve All Users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsUsersGetRequest
*/
func (a *DefaultAPIService) ObjectsUsersGet(ctx context.Context) ApiObjectsUsersGetRequest {
	return ApiObjectsUsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersGetExecute(r ApiObjectsUsersGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.vaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vaults", r.vaults, "form", "")
	}
	if r.excludeVaultMembership != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_vault_membership", r.excludeVaultMembership, "form", "")
	}
	if r.excludeAppLicensing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_app_licensing", r.excludeAppLicensing, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	excludeVaultMembership *string
	excludeAppLicensing *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: Set to true to omit vault_membership fields. If you don’t need these fields, this may increase performance. If omitted, vault_membership fields are included in the response.
func (r ApiObjectsUsersIdGetRequest) ExcludeVaultMembership(excludeVaultMembership string) ApiObjectsUsersIdGetRequest {
	r.excludeVaultMembership = &excludeVaultMembership
	return r
}

// Optional: Set to true to omit app_licensing fields. If you don’t need these fields, this may increase performance. If omitted, app_licensing fields are included in the response.
func (r ApiObjectsUsersIdGetRequest) ExcludeAppLicensing(excludeAppLicensing string) ApiObjectsUsersIdGetRequest {
	r.excludeAppLicensing = &excludeAppLicensing
	return r
}

func (r ApiObjectsUsersIdGetRequest) Authorization(authorization string) ApiObjectsUsersIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersIdGetRequest) Accept(accept string) ApiObjectsUsersIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersIdGetExecute(r)
}

/*
ObjectsUsersIdGet Retrieve User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The user id field value. Use the value me to get information for the currently authenticated user.
 @return ApiObjectsUsersIdGetRequest
*/
func (a *DefaultAPIService) ObjectsUsersIdGet(ctx context.Context, id string) ApiObjectsUsersIdGetRequest {
	return ApiObjectsUsersIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersIdGetExecute(r ApiObjectsUsersIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeVaultMembership != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_vault_membership", r.excludeVaultMembership, "form", "")
	}
	if r.excludeAppLicensing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_app_licensing", r.excludeAppLicensing, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersIdPermissionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	filter *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Filter the results to show only one specific name__v, which is in the format object.{object name}.{object or field}_actions. Wildcards are not supported. See example below.
func (r ApiObjectsUsersIdPermissionsGetRequest) Filter(filter string) ApiObjectsUsersIdPermissionsGetRequest {
	r.filter = &filter
	return r
}

func (r ApiObjectsUsersIdPermissionsGetRequest) Authorization(authorization string) ApiObjectsUsersIdPermissionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersIdPermissionsGetRequest) Accept(accept string) ApiObjectsUsersIdPermissionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersIdPermissionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersIdPermissionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersIdPermissionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersIdPermissionsGetExecute(r)
}

/*
ObjectsUsersIdPermissionsGet Retrieve User Permissions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the user. Use the value me to retrieve information for the currently authenticated user.
 @return ApiObjectsUsersIdPermissionsGetRequest
*/
func (a *DefaultAPIService) ObjectsUsersIdPermissionsGet(ctx context.Context, id string) ApiObjectsUsersIdPermissionsGetRequest {
	return ApiObjectsUsersIdPermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersIdPermissionsGetExecute(r ApiObjectsUsersIdPermissionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersIdPermissionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/{id}/permissions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsUsersIdPutRequest) Authorization(authorization string) ApiObjectsUsersIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersIdPutRequest) ContentType(contentType string) ApiObjectsUsersIdPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersIdPutExecute(r)
}

/*
ObjectsUsersIdPut Update Single User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The user id field value. Use the value me to get information for the currently authenticated user.
 @return ApiObjectsUsersIdPutRequest
*/
func (a *DefaultAPIService) ObjectsUsersIdPut(ctx context.Context, id string) ApiObjectsUsersIdPutRequest {
	return ApiObjectsUsersIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersIdPutExecute(r ApiObjectsUsersIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersMeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	excludeVaultMembership *string
	excludeAppLicensing *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: Set to true to omit vault_membership fields. If you don’t need these fields, this may increase performance. If omitted, vault_membership fields are included in the response.
func (r ApiObjectsUsersMeGetRequest) ExcludeVaultMembership(excludeVaultMembership string) ApiObjectsUsersMeGetRequest {
	r.excludeVaultMembership = &excludeVaultMembership
	return r
}

// Optional: Set to true to omit app_licensing fields. If you don’t need these fields, this may increase performance. If omitted, app_licensing fields are included in the response.
func (r ApiObjectsUsersMeGetRequest) ExcludeAppLicensing(excludeAppLicensing string) ApiObjectsUsersMeGetRequest {
	r.excludeAppLicensing = &excludeAppLicensing
	return r
}

func (r ApiObjectsUsersMeGetRequest) Authorization(authorization string) ApiObjectsUsersMeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersMeGetRequest) Accept(accept string) ApiObjectsUsersMeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersMeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersMeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersMeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersMeGetExecute(r)
}

/*
ObjectsUsersMeGet Validate Session User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsUsersMeGetRequest
*/
func (a *DefaultAPIService) ObjectsUsersMeGet(ctx context.Context) ApiObjectsUsersMeGetRequest {
	return ApiObjectsUsersMeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersMeGetExecute(r ApiObjectsUsersMeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersMeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeVaultMembership != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_vault_membership", r.excludeVaultMembership, "form", "")
	}
	if r.excludeAppLicensing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_app_licensing", r.excludeAppLicensing, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersMePasswordPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsUsersMePasswordPostRequest) Authorization(authorization string) ApiObjectsUsersMePasswordPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersMePasswordPostRequest) ContentType(contentType string) ApiObjectsUsersMePasswordPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsUsersMePasswordPostRequest) Accept(accept string) ApiObjectsUsersMePasswordPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersMePasswordPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersMePasswordPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersMePasswordPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersMePasswordPostExecute(r)
}

/*
ObjectsUsersMePasswordPost Change My Password

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsUsersMePasswordPostRequest
*/
func (a *DefaultAPIService) ObjectsUsersMePasswordPost(ctx context.Context) ApiObjectsUsersMePasswordPostRequest {
	return ApiObjectsUsersMePasswordPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersMePasswordPostExecute(r ApiObjectsUsersMePasswordPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersMePasswordPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/me/password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersMePermissionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	filter *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Filter the results to show only one specific name__v, which is in the format object.{object name}.{object or field}_actions. Wildcards are not supported. See example below.
func (r ApiObjectsUsersMePermissionsGetRequest) Filter(filter string) ApiObjectsUsersMePermissionsGetRequest {
	r.filter = &filter
	return r
}

func (r ApiObjectsUsersMePermissionsGetRequest) Authorization(authorization string) ApiObjectsUsersMePermissionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersMePermissionsGetRequest) Accept(accept string) ApiObjectsUsersMePermissionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersMePermissionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersMePermissionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersMePermissionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersMePermissionsGetExecute(r)
}

/*
ObjectsUsersMePermissionsGet Retrieve My User Permissions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsUsersMePermissionsGetRequest
*/
func (a *DefaultAPIService) ObjectsUsersMePermissionsGet(ctx context.Context) ApiObjectsUsersMePermissionsGetRequest {
	return ApiObjectsUsersMePermissionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersMePermissionsGetExecute(r ApiObjectsUsersMePermissionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersMePermissionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/me/permissions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersMePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsUsersMePutRequest) Authorization(authorization string) ApiObjectsUsersMePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersMePutRequest) ContentType(contentType string) ApiObjectsUsersMePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersMePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersMePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersMePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersMePutExecute(r)
}

/*
ObjectsUsersMePut Update My User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsUsersMePutRequest
*/
func (a *DefaultAPIService) ObjectsUsersMePut(ctx context.Context) ApiObjectsUsersMePutRequest {
	return ApiObjectsUsersMePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersMePutExecute(r ApiObjectsUsersMePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersMePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsUsersPostRequest) Authorization(authorization string) ApiObjectsUsersPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersPostRequest) Accept(accept string) ApiObjectsUsersPostRequest {
	r.accept = &accept
	return r
}

func (r ApiObjectsUsersPostRequest) ContentType(contentType string) ApiObjectsUsersPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersPostExecute(r)
}

/*
ObjectsUsersPost Create Single User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsUsersPostRequest
*/
func (a *DefaultAPIService) ObjectsUsersPost(ctx context.Context) ApiObjectsUsersPostRequest {
	return ApiObjectsUsersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersPostExecute(r ApiObjectsUsersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsUsersPutRequest) Authorization(authorization string) ApiObjectsUsersPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersPutRequest) ContentType(contentType string) ApiObjectsUsersPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsUsersPutRequest) Accept(accept string) ApiObjectsUsersPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersPutExecute(r)
}

/*
ObjectsUsersPut Update Multiple Users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsUsersPutRequest
*/
func (a *DefaultAPIService) ObjectsUsersPut(ctx context.Context) ApiObjectsUsersPutRequest {
	return ApiObjectsUsersPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersPutExecute(r ApiObjectsUsersPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersUserIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	userId string
	domain *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// When true, this disables the user account in all vaults in the domain.
func (r ApiObjectsUsersUserIdDeleteRequest) Domain(domain bool) ApiObjectsUsersUserIdDeleteRequest {
	r.domain = &domain
	return r
}

func (r ApiObjectsUsersUserIdDeleteRequest) Authorization(authorization string) ApiObjectsUsersUserIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersUserIdDeleteRequest) Accept(accept string) ApiObjectsUsersUserIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersUserIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersUserIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersUserIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersUserIdDeleteExecute(r)
}

/*
ObjectsUsersUserIdDelete Disable User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId The user id field value. 
 @return ApiObjectsUsersUserIdDeleteRequest
*/
func (a *DefaultAPIService) ObjectsUsersUserIdDelete(ctx context.Context, userId string) ApiObjectsUsersUserIdDeleteRequest {
	return ApiObjectsUsersUserIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersUserIdDeleteExecute(r ApiObjectsUsersUserIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersUserIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	userId string
	vaultId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest) Authorization(authorization string) ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest) ContentType(contentType string) ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest) Accept(accept string) ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsUsersUserIdVaultMembershipVaultIdPutExecute(r)
}

/*
ObjectsUsersUserIdVaultMembershipVaultIdPut Update Vault Membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId The user id field value.
 @param vaultId The system-managed id field value assigned to each vault in the domain.
 @return ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest
*/
func (a *DefaultAPIService) ObjectsUsersUserIdVaultMembershipVaultIdPut(ctx context.Context, userId string, vaultId string) ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest {
	return ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
		vaultId: vaultId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsUsersUserIdVaultMembershipVaultIdPutExecute(r ApiObjectsUsersUserIdVaultMembershipVaultIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsUsersUserIdVaultMembershipVaultIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/users/{user_id}/vault_membership/{vault_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vault_id"+"}", url.PathEscape(parameterValueToString(r.vaultId, "vaultId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsVaultActionsComparePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsVaultActionsComparePostRequest) Authorization(authorization string) ApiObjectsVaultActionsComparePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsVaultActionsComparePostRequest) ContentType(contentType string) ApiObjectsVaultActionsComparePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsVaultActionsComparePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsVaultActionsComparePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsVaultActionsComparePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsVaultActionsComparePostExecute(r)
}

/*
ObjectsVaultActionsComparePost Vault Compare

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsVaultActionsComparePostRequest
*/
func (a *DefaultAPIService) ObjectsVaultActionsComparePost(ctx context.Context) ApiObjectsVaultActionsComparePostRequest {
	return ApiObjectsVaultActionsComparePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsVaultActionsComparePostExecute(r ApiObjectsVaultActionsComparePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsVaultActionsComparePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/vault/actions/compare"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiObjectsVaultActionsConfigreportPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiObjectsVaultActionsConfigreportPostRequest) Authorization(authorization string) ApiObjectsVaultActionsConfigreportPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiObjectsVaultActionsConfigreportPostRequest) ContentType(contentType string) ApiObjectsVaultActionsConfigreportPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiObjectsVaultActionsConfigreportPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiObjectsVaultActionsConfigreportPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiObjectsVaultActionsConfigreportPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ObjectsVaultActionsConfigreportPostExecute(r)
}

/*
ObjectsVaultActionsConfigreportPost Vault Configuration Report

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiObjectsVaultActionsConfigreportPostRequest
*/
func (a *DefaultAPIService) ObjectsVaultActionsConfigreportPost(ctx context.Context) ApiObjectsVaultActionsConfigreportPostRequest {
	return ApiObjectsVaultActionsConfigreportPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ObjectsVaultActionsConfigreportPostExecute(r ApiObjectsVaultActionsConfigreportPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ObjectsVaultActionsConfigreportPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/objects/vault/actions/configreport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryComponentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiQueryComponentsPostRequest) Authorization(authorization string) ApiQueryComponentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiQueryComponentsPostRequest) Accept(accept string) ApiQueryComponentsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiQueryComponentsPostRequest) ContentType(contentType string) ApiQueryComponentsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiQueryComponentsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiQueryComponentsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiQueryComponentsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.QueryComponentsPostExecute(r)
}

/*
QueryComponentsPost Component Definition Query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryComponentsPostRequest
*/
func (a *DefaultAPIService) QueryComponentsPost(ctx context.Context) ApiQueryComponentsPostRequest {
	return ApiQueryComponentsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) QueryComponentsPostExecute(r ApiQueryComponentsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QueryComponentsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/components"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryNextPagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	nextPage string
	authorization *string
	accept *string
	xVaultAPIDescribeQuery *bool
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiQueryNextPagePostRequest) Authorization(authorization string) ApiQueryNextPagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiQueryNextPagePostRequest) Accept(accept string) ApiQueryNextPagePostRequest {
	r.accept = &accept
	return r
}

func (r ApiQueryNextPagePostRequest) XVaultAPIDescribeQuery(xVaultAPIDescribeQuery bool) ApiQueryNextPagePostRequest {
	r.xVaultAPIDescribeQuery = &xVaultAPIDescribeQuery
	return r
}

func (r ApiQueryNextPagePostRequest) ContentType(contentType string) ApiQueryNextPagePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiQueryNextPagePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiQueryNextPagePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiQueryNextPagePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.QueryNextPagePostExecute(r)
}

/*
QueryNextPagePost Next Page URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nextPage
 @return ApiQueryNextPagePostRequest
*/
func (a *DefaultAPIService) QueryNextPagePost(ctx context.Context, nextPage string) ApiQueryNextPagePostRequest {
	return ApiQueryNextPagePostRequest{
		ApiService: a,
		ctx: ctx,
		nextPage: nextPage,
	}
}

// Execute executes the request
func (a *DefaultAPIService) QueryNextPagePostExecute(r ApiQueryNextPagePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QueryNextPagePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/{next_page}"
	localVarPath = strings.Replace(localVarPath, "{"+"next_page"+"}", url.PathEscape(parameterValueToString(r.nextPage, "nextPage")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIDescribeQuery != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-DescribeQuery", r.xVaultAPIDescribeQuery, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIDescribeQuery *bool
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiQueryPostRequest) Authorization(authorization string) ApiQueryPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiQueryPostRequest) Accept(accept string) ApiQueryPostRequest {
	r.accept = &accept
	return r
}

func (r ApiQueryPostRequest) XVaultAPIDescribeQuery(xVaultAPIDescribeQuery bool) ApiQueryPostRequest {
	r.xVaultAPIDescribeQuery = &xVaultAPIDescribeQuery
	return r
}

func (r ApiQueryPostRequest) ContentType(contentType string) ApiQueryPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiQueryPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiQueryPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiQueryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.QueryPostExecute(r)
}

/*
QueryPost Submitting a Query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryPostRequest
*/
func (a *DefaultAPIService) QueryPost(ctx context.Context) ApiQueryPostRequest {
	return ApiQueryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) QueryPostExecute(r ApiQueryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QueryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIDescribeQuery != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-DescribeQuery", r.xVaultAPIDescribeQuery, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiQueryPreviousPagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	previousPage string
	authorization *string
	accept *string
	xVaultAPIDescribeQuery *bool
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiQueryPreviousPagePostRequest) Authorization(authorization string) ApiQueryPreviousPagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiQueryPreviousPagePostRequest) Accept(accept string) ApiQueryPreviousPagePostRequest {
	r.accept = &accept
	return r
}

func (r ApiQueryPreviousPagePostRequest) XVaultAPIDescribeQuery(xVaultAPIDescribeQuery bool) ApiQueryPreviousPagePostRequest {
	r.xVaultAPIDescribeQuery = &xVaultAPIDescribeQuery
	return r
}

func (r ApiQueryPreviousPagePostRequest) ContentType(contentType string) ApiQueryPreviousPagePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiQueryPreviousPagePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiQueryPreviousPagePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiQueryPreviousPagePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.QueryPreviousPagePostExecute(r)
}

/*
QueryPreviousPagePost Previous Page URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param previousPage
 @return ApiQueryPreviousPagePostRequest
*/
func (a *DefaultAPIService) QueryPreviousPagePost(ctx context.Context, previousPage string) ApiQueryPreviousPagePostRequest {
	return ApiQueryPreviousPagePostRequest{
		ApiService: a,
		ctx: ctx,
		previousPage: previousPage,
	}
}

// Execute executes the request
func (a *DefaultAPIService) QueryPreviousPagePostExecute(r ApiQueryPreviousPagePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.QueryPreviousPagePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/{previous_page}"
	localVarPath = strings.Replace(localVarPath, "{"+"previous_page"+"}", url.PathEscape(parameterValueToString(r.previousPage, "previousPage")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIDescribeQuery != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-DescribeQuery", r.xVaultAPIDescribeQuery, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2MeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	attributes *string
	excludedAttributes *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: Include specified attributes only. Enter multiple values in a comma separated list. For example, to include only user name and email in the response, attributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned.
func (r ApiScimV2MeGetRequest) Attributes(attributes string) ApiScimV2MeGetRequest {
	r.attributes = &attributes
	return r
}

// Optional: Exclude specific attributes from the response. Enter multiple values in a comma separated list. For example, to exclude user name and email from the response, excludedAttributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned and cannot be excluded.
func (r ApiScimV2MeGetRequest) ExcludedAttributes(excludedAttributes string) ApiScimV2MeGetRequest {
	r.excludedAttributes = &excludedAttributes
	return r
}

func (r ApiScimV2MeGetRequest) Authorization(authorization string) ApiScimV2MeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2MeGetRequest) Accept(accept string) ApiScimV2MeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2MeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2MeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2MeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2MeGetExecute(r)
}

/*
ScimV2MeGet Retrieve Current User with SCIM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScimV2MeGetRequest
*/
func (a *DefaultAPIService) ScimV2MeGet(ctx context.Context) ApiScimV2MeGetRequest {
	return ApiScimV2MeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2MeGetExecute(r ApiScimV2MeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2MeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "form", "")
	}
	if r.excludedAttributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludedAttributes", r.excludedAttributes, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2MePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	attributes *string
	excludedAttributes *string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

// Optional: Include specified attributes only. Enter multiple values in a comma separated list. For example, to include only user name and email in the response, attributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned.
func (r ApiScimV2MePutRequest) Attributes(attributes string) ApiScimV2MePutRequest {
	r.attributes = &attributes
	return r
}

// Optional: Exclude specific attributes from the response. Enter multiple values in a comma separated list. For example, to exclude user name and email from the response, excludedAttributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned and cannot be excluded.
func (r ApiScimV2MePutRequest) ExcludedAttributes(excludedAttributes string) ApiScimV2MePutRequest {
	r.excludedAttributes = &excludedAttributes
	return r
}

func (r ApiScimV2MePutRequest) Authorization(authorization string) ApiScimV2MePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2MePutRequest) Accept(accept string) ApiScimV2MePutRequest {
	r.accept = &accept
	return r
}

func (r ApiScimV2MePutRequest) ContentType(contentType string) ApiScimV2MePutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2MePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2MePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2MePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2MePutExecute(r)
}

/*
ScimV2MePut Update Current User with SCIM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScimV2MePutRequest
*/
func (a *DefaultAPIService) ScimV2MePut(ctx context.Context) ApiScimV2MePutRequest {
	return ApiScimV2MePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2MePutExecute(r ApiScimV2MePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2MePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Me"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "form", "")
	}
	if r.excludedAttributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludedAttributes", r.excludedAttributes, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2ResourceTypesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiScimV2ResourceTypesGetRequest) Authorization(authorization string) ApiScimV2ResourceTypesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2ResourceTypesGetRequest) Accept(accept string) ApiScimV2ResourceTypesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2ResourceTypesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2ResourceTypesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2ResourceTypesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2ResourceTypesGetExecute(r)
}

/*
ScimV2ResourceTypesGet Retrieve All SCIM Resource Types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScimV2ResourceTypesGetRequest
*/
func (a *DefaultAPIService) ScimV2ResourceTypesGet(ctx context.Context) ApiScimV2ResourceTypesGetRequest {
	return ApiScimV2ResourceTypesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2ResourceTypesGetExecute(r ApiScimV2ResourceTypesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2ResourceTypesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/ResourceTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2ResourceTypesTypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	type_ string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiScimV2ResourceTypesTypeGetRequest) Authorization(authorization string) ApiScimV2ResourceTypesTypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2ResourceTypesTypeGetRequest) Accept(accept string) ApiScimV2ResourceTypesTypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2ResourceTypesTypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2ResourceTypesTypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2ResourceTypesTypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2ResourceTypesTypeGetExecute(r)
}

/*
ScimV2ResourceTypesTypeGet Retrieve Single SCIM Resource Type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ A specific resource type. You can retrieve all available types from the Retrieve All SCIM Resource Types endpoint, where the value for this parameter is the id value.
 @return ApiScimV2ResourceTypesTypeGetRequest
*/
func (a *DefaultAPIService) ScimV2ResourceTypesTypeGet(ctx context.Context, type_ string) ApiScimV2ResourceTypesTypeGetRequest {
	return ApiScimV2ResourceTypesTypeGetRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2ResourceTypesTypeGetExecute(r ApiScimV2ResourceTypesTypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2ResourceTypesTypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/ResourceTypes/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2SchemasGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiScimV2SchemasGetRequest) Authorization(authorization string) ApiScimV2SchemasGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2SchemasGetRequest) Accept(accept string) ApiScimV2SchemasGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2SchemasGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2SchemasGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2SchemasGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2SchemasGetExecute(r)
}

/*
ScimV2SchemasGet Retrieve All SCIM Schema Information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScimV2SchemasGetRequest
*/
func (a *DefaultAPIService) ScimV2SchemasGet(ctx context.Context) ApiScimV2SchemasGetRequest {
	return ApiScimV2SchemasGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2SchemasGetExecute(r ApiScimV2SchemasGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2SchemasGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Schemas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2SchemasIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiScimV2SchemasIdGetRequest) Authorization(authorization string) ApiScimV2SchemasIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2SchemasIdGetRequest) Accept(accept string) ApiScimV2SchemasIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2SchemasIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2SchemasIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2SchemasIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2SchemasIdGetExecute(r)
}

/*
ScimV2SchemasIdGet Retrieve Single SCIM Schema Information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of a specific schema. For example, urn:ietf:params:scim:schemas:extension:veevavault:2.0:User.
 @return ApiScimV2SchemasIdGetRequest
*/
func (a *DefaultAPIService) ScimV2SchemasIdGet(ctx context.Context, id string) ApiScimV2SchemasIdGetRequest {
	return ApiScimV2SchemasIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2SchemasIdGetExecute(r ApiScimV2SchemasIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2SchemasIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Schemas/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2ServiceProviderConfigGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiScimV2ServiceProviderConfigGetRequest) Authorization(authorization string) ApiScimV2ServiceProviderConfigGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2ServiceProviderConfigGetRequest) Accept(accept string) ApiScimV2ServiceProviderConfigGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2ServiceProviderConfigGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2ServiceProviderConfigGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2ServiceProviderConfigGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2ServiceProviderConfigGetExecute(r)
}

/*
ScimV2ServiceProviderConfigGet Retrieve SCIM Provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScimV2ServiceProviderConfigGetRequest
*/
func (a *DefaultAPIService) ScimV2ServiceProviderConfigGet(ctx context.Context) ApiScimV2ServiceProviderConfigGetRequest {
	return ApiScimV2ServiceProviderConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2ServiceProviderConfigGetExecute(r ApiScimV2ServiceProviderConfigGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2ServiceProviderConfigGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/ServiceProviderConfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2TypeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	type_ string
	filter *string
	attributes *string
	excludedAttributes *string
	sortBy *string
	sortOrder *string
	startIndex *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: Filter for a specific attribute value. Must be in the format {attribute} eq \&quot;{value}\&quot;. For example, to filter for a particular user name, userName eq \&quot;john\&quot;. Complex expressions are not supported, and eq is the only supported operator.
func (r ApiScimV2TypeGetRequest) Filter(filter string) ApiScimV2TypeGetRequest {
	r.filter = &filter
	return r
}

// Optional: Include specified attributes only. Enter multiple values in a comma separated list. For example, to include only user name and email in the response, attributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned.
func (r ApiScimV2TypeGetRequest) Attributes(attributes string) ApiScimV2TypeGetRequest {
	r.attributes = &attributes
	return r
}

// Optional: Exclude specific attributes from the response. Enter multiple values in a comma separated list. For example, to exclude user name and email from the response, excludedAttributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned and cannot be excluded.
func (r ApiScimV2TypeGetRequest) ExcludedAttributes(excludedAttributes string) ApiScimV2TypeGetRequest {
	r.excludedAttributes = &excludedAttributes
	return r
}

// Optional: Specify an attribute or sub-attribute to order the response. For example, you can sort by the displayName attribute, or the name.familyName sub-attribute. If omitted, the response is sorted by id. Note that the following attributes are not supported: securityPolicy securityProfile locale preferredLanguage
func (r ApiScimV2TypeGetRequest) SortBy(sortBy string) ApiScimV2TypeGetRequest {
	r.sortBy = &sortBy
	return r
}

// Optional: Specify the number of query results per page, for example, 10. Negative values are treated as 0, and 0 returns no results except for totalResults. If omitted, defaults to 1000.
func (r ApiScimV2TypeGetRequest) SortOrder(sortOrder string) ApiScimV2TypeGetRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional: Specify the index of the first result. For example, 10 would omit the first 9 results and begin on result 10. Omission, negative values, and 0 is treated as 1.
func (r ApiScimV2TypeGetRequest) StartIndex(startIndex string) ApiScimV2TypeGetRequest {
	r.startIndex = &startIndex
	return r
}

func (r ApiScimV2TypeGetRequest) Authorization(authorization string) ApiScimV2TypeGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2TypeGetRequest) Accept(accept string) ApiScimV2TypeGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2TypeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2TypeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2TypeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2TypeGetExecute(r)
}

/*
ScimV2TypeGet Retrieve SCIM Resources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ The resource type to retrieve. You can retrieve all available types from the Retrieve All SCIM Resource Types endpoint, where the value for this parameter is the endpoint value.
 @return ApiScimV2TypeGetRequest
*/
func (a *DefaultAPIService) ScimV2TypeGet(ctx context.Context, type_ string) ApiScimV2TypeGetRequest {
	return ApiScimV2TypeGetRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2TypeGetExecute(r ApiScimV2TypeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2TypeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "form", "")
	}
	if r.excludedAttributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludedAttributes", r.excludedAttributes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2TypeIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	type_ string
	id string
	attributes *string
	excludedAttributes *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: Include specified attributes only. Enter multiple values in a comma separated list. For example, to include only user name and email in the response, attributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned.
func (r ApiScimV2TypeIdGetRequest) Attributes(attributes string) ApiScimV2TypeIdGetRequest {
	r.attributes = &attributes
	return r
}

// Optional: Exclude specific attributes from the response. Enter multiple values in a comma separated list. For example, to exclude user name and email from the response, excludedAttributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned and cannot be excluded.
func (r ApiScimV2TypeIdGetRequest) ExcludedAttributes(excludedAttributes string) ApiScimV2TypeIdGetRequest {
	r.excludedAttributes = &excludedAttributes
	return r
}

func (r ApiScimV2TypeIdGetRequest) Authorization(authorization string) ApiScimV2TypeIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2TypeIdGetRequest) Accept(accept string) ApiScimV2TypeIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2TypeIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2TypeIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2TypeIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2TypeIdGetExecute(r)
}

/*
ScimV2TypeIdGet Retrieve Single SCIM Resource

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ The resource type to retrieve. You can retrieve all available types from the Retrieve All SCIM Resource Types endpoint, where the value for this parameter is the endpoint value.
 @param id The ID of the resource to retrieve. You can retrieve all resource IDs from a particular resource type with the Retrieve SCIM Resources endpoint. For example, business_admin__v.
 @return ApiScimV2TypeIdGetRequest
*/
func (a *DefaultAPIService) ScimV2TypeIdGet(ctx context.Context, type_ string, id string) ApiScimV2TypeIdGetRequest {
	return ApiScimV2TypeIdGetRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2TypeIdGetExecute(r ApiScimV2TypeIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2TypeIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/{type}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "form", "")
	}
	if r.excludedAttributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludedAttributes", r.excludedAttributes, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2UsersGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	filter *string
	attributes *string
	excludedAttributes *string
	sortBy *string
	sortOrder *string
	count *string
	startIndex *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: Filter for a specific attribute value. Must be in the format {attribute} eq \&quot;{value}\&quot;. For example, to filter for a particular user name, userName eq \&quot;john\&quot;. Complex expressions are not supported, and eq is the only supported operator.
func (r ApiScimV2UsersGetRequest) Filter(filter string) ApiScimV2UsersGetRequest {
	r.filter = &filter
	return r
}

// Optional: Include specified attributes only. Enter multiple values in a comma separated list. For example, to include only user name and email in the response, attributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned.
func (r ApiScimV2UsersGetRequest) Attributes(attributes string) ApiScimV2UsersGetRequest {
	r.attributes = &attributes
	return r
}

// Optional: Exclude specific attributes from the response. Enter multiple values in a comma separated list. For example, to exclude user name and email from the response, excludedAttributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned and cannot be excluded.
func (r ApiScimV2UsersGetRequest) ExcludedAttributes(excludedAttributes string) ApiScimV2UsersGetRequest {
	r.excludedAttributes = &excludedAttributes
	return r
}

// Optional: Specify an attribute or sub-attribute to order the response. For example, you can sort by the displayName attribute, or the name.familyName sub-attribute. If omitted, the response is sorted by id. Note that the following attributes are not supported: securityPolicy securityProfile locale preferredLanguage
func (r ApiScimV2UsersGetRequest) SortBy(sortBy string) ApiScimV2UsersGetRequest {
	r.sortBy = &sortBy
	return r
}

// Optional: Specify the order in which the sortBy parameter is applied. Allowed values are ascending or descending. If omitted, defaults to ascending.
func (r ApiScimV2UsersGetRequest) SortOrder(sortOrder string) ApiScimV2UsersGetRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional: Specify the number of query results per page, for example, 10. Negative values are treated as 0, and 0 returns no results except for totalResults. If omitted, defaults to 1000.
func (r ApiScimV2UsersGetRequest) Count(count string) ApiScimV2UsersGetRequest {
	r.count = &count
	return r
}

// Optional: Specify the index of the first result. For example, 10 would omit the first 9 results and begin on result 10. Omission, negative values, and 0 is treated as 1.
func (r ApiScimV2UsersGetRequest) StartIndex(startIndex string) ApiScimV2UsersGetRequest {
	r.startIndex = &startIndex
	return r
}

func (r ApiScimV2UsersGetRequest) Authorization(authorization string) ApiScimV2UsersGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2UsersGetRequest) Accept(accept string) ApiScimV2UsersGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2UsersGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2UsersGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2UsersGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2UsersGetExecute(r)
}

/*
ScimV2UsersGet Retrieve All Users with SCIM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScimV2UsersGetRequest
*/
func (a *DefaultAPIService) ScimV2UsersGet(ctx context.Context) ApiScimV2UsersGetRequest {
	return ApiScimV2UsersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2UsersGetExecute(r ApiScimV2UsersGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2UsersGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "form", "")
	}
	if r.excludedAttributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludedAttributes", r.excludedAttributes, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2UsersIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	filter *string
	attributes *string
	excludedAttributes *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: Filter for a specific attribute value. Must be in the format {attribute} eq \&quot;{value}\&quot;. For example, to filter for a particular user name, userName eq \&quot;john\&quot;. Complex expressions are not supported, and eq is the only supported operator.
func (r ApiScimV2UsersIdGetRequest) Filter(filter string) ApiScimV2UsersIdGetRequest {
	r.filter = &filter
	return r
}

// Optional: Include specified attributes only. Enter multiple values in a comma separated list. For example, to include only user name and email in the response, attributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned.
func (r ApiScimV2UsersIdGetRequest) Attributes(attributes string) ApiScimV2UsersIdGetRequest {
	r.attributes = &attributes
	return r
}

// Optional: Exclude specific attributes from the response. Enter multiple values in a comma separated list. For example, to exclude user name and email from the response, excludedAttributes&#x3D;userName,emails. Note that the schemas and id attributes are always returned and cannot be excluded.
func (r ApiScimV2UsersIdGetRequest) ExcludedAttributes(excludedAttributes string) ApiScimV2UsersIdGetRequest {
	r.excludedAttributes = &excludedAttributes
	return r
}

func (r ApiScimV2UsersIdGetRequest) Authorization(authorization string) ApiScimV2UsersIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2UsersIdGetRequest) Accept(accept string) ApiScimV2UsersIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2UsersIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2UsersIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2UsersIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2UsersIdGetExecute(r)
}

/*
ScimV2UsersIdGet Retrieve Single User with SCIM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the user you wish to update.
 @return ApiScimV2UsersIdGetRequest
*/
func (a *DefaultAPIService) ScimV2UsersIdGet(ctx context.Context, id string) ApiScimV2UsersIdGetRequest {
	return ApiScimV2UsersIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2UsersIdGetExecute(r ApiScimV2UsersIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2UsersIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.attributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attributes", r.attributes, "form", "")
	}
	if r.excludedAttributes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludedAttributes", r.excludedAttributes, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2UsersIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	id string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiScimV2UsersIdPutRequest) Authorization(authorization string) ApiScimV2UsersIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2UsersIdPutRequest) Accept(accept string) ApiScimV2UsersIdPutRequest {
	r.accept = &accept
	return r
}

func (r ApiScimV2UsersIdPutRequest) ContentType(contentType string) ApiScimV2UsersIdPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2UsersIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2UsersIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2UsersIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2UsersIdPutExecute(r)
}

/*
ScimV2UsersIdPut Update User with SCIM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The id of the user you wish to update.
 @return ApiScimV2UsersIdPutRequest
*/
func (a *DefaultAPIService) ScimV2UsersIdPut(ctx context.Context, id string) ApiScimV2UsersIdPutRequest {
	return ApiScimV2UsersIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2UsersIdPutExecute(r ApiScimV2UsersIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2UsersIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiScimV2UsersPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiScimV2UsersPostRequest) Authorization(authorization string) ApiScimV2UsersPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiScimV2UsersPostRequest) Accept(accept string) ApiScimV2UsersPostRequest {
	r.accept = &accept
	return r
}

func (r ApiScimV2UsersPostRequest) ContentType(contentType string) ApiScimV2UsersPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiScimV2UsersPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiScimV2UsersPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiScimV2UsersPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ScimV2UsersPostExecute(r)
}

/*
ScimV2UsersPost Create User with SCIM

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScimV2UsersPostRequest
*/
func (a *DefaultAPIService) ScimV2UsersPost(ctx context.Context) ApiScimV2UsersPostRequest {
	return ApiScimV2UsersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ScimV2UsersPostExecute(r ApiScimV2UsersPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ScimV2UsersPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scim/v2/Users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesCertificateCertIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	certId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesCertificateCertIdGetRequest) Authorization(authorization string) ApiServicesCertificateCertIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesCertificateCertIdGetRequest) Accept(accept string) ApiServicesCertificateCertIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesCertificateCertIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesCertificateCertIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesCertificateCertIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesCertificateCertIdGetExecute(r)
}

/*
ServicesCertificateCertIdGet Retrieve Signing Certificate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param certId The cert_id is provided in each Spark message in the X-VaultAPISignature-CertificateId header.
 @return ApiServicesCertificateCertIdGetRequest
*/
func (a *DefaultAPIService) ServicesCertificateCertIdGet(ctx context.Context, certId string) ApiServicesCertificateCertIdGetRequest {
	return ApiServicesCertificateCertIdGetRequest{
		ApiService: a,
		ctx: ctx,
		certId: certId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesCertificateCertIdGetExecute(r ApiServicesCertificateCertIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesCertificateCertIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/certificate/{cert_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"cert_id"+"}", url.PathEscape(parameterValueToString(r.certId, "certId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesConfigurationModeActionsDisablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiServicesConfigurationModeActionsDisablePostRequest) Authorization(authorization string) ApiServicesConfigurationModeActionsDisablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesConfigurationModeActionsDisablePostRequest) Accept(accept string) ApiServicesConfigurationModeActionsDisablePostRequest {
	r.accept = &accept
	return r
}

func (r ApiServicesConfigurationModeActionsDisablePostRequest) ContentType(contentType string) ApiServicesConfigurationModeActionsDisablePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesConfigurationModeActionsDisablePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesConfigurationModeActionsDisablePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesConfigurationModeActionsDisablePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesConfigurationModeActionsDisablePostExecute(r)
}

/*
ServicesConfigurationModeActionsDisablePost Disable Configuration Mode

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesConfigurationModeActionsDisablePostRequest
*/
func (a *DefaultAPIService) ServicesConfigurationModeActionsDisablePost(ctx context.Context) ApiServicesConfigurationModeActionsDisablePostRequest {
	return ApiServicesConfigurationModeActionsDisablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesConfigurationModeActionsDisablePostExecute(r ApiServicesConfigurationModeActionsDisablePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesConfigurationModeActionsDisablePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/configuration_mode/actions/disable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesConfigurationModeActionsEnablePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiServicesConfigurationModeActionsEnablePostRequest) Authorization(authorization string) ApiServicesConfigurationModeActionsEnablePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesConfigurationModeActionsEnablePostRequest) Accept(accept string) ApiServicesConfigurationModeActionsEnablePostRequest {
	r.accept = &accept
	return r
}

func (r ApiServicesConfigurationModeActionsEnablePostRequest) ContentType(contentType string) ApiServicesConfigurationModeActionsEnablePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesConfigurationModeActionsEnablePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesConfigurationModeActionsEnablePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesConfigurationModeActionsEnablePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesConfigurationModeActionsEnablePostExecute(r)
}

/*
ServicesConfigurationModeActionsEnablePost Enable Configuration Mode

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesConfigurationModeActionsEnablePostRequest
*/
func (a *DefaultAPIService) ServicesConfigurationModeActionsEnablePost(ctx context.Context) ApiServicesConfigurationModeActionsEnablePostRequest {
	return ApiServicesConfigurationModeActionsEnablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesConfigurationModeActionsEnablePostExecute(r ApiServicesConfigurationModeActionsEnablePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesConfigurationModeActionsEnablePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/configuration_mode/actions/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesDirectdataFilesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	extractType *string
	startTime *int32
	stopTime *int32
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

// The Direct Data file type: incremental_directdata, full_directdata, or log_directdata. If omitted, returns all files.
func (r ApiServicesDirectdataFilesGetRequest) ExtractType(extractType string) ApiServicesDirectdataFilesGetRequest {
	r.extractType = &extractType
	return r
}

// Specify a time in YYYY-MM-DDTHH:MM:SSZ format. For example, 7AM on January 15, 2024 would use 2024-01-15T07:00:00Z. If omitted, defaults to the Vault’s creation date and time.
func (r ApiServicesDirectdataFilesGetRequest) StartTime(startTime int32) ApiServicesDirectdataFilesGetRequest {
	r.startTime = &startTime
	return r
}

// Specify a time in YYYY-MM-DDTHH:MM:SSZ format. For example, 9AM on January 15, 2024 would use 2024-01-15T09:00:00Z. If omitted, defaults to today’s date and current time.
func (r ApiServicesDirectdataFilesGetRequest) StopTime(stopTime int32) ApiServicesDirectdataFilesGetRequest {
	r.stopTime = &stopTime
	return r
}

func (r ApiServicesDirectdataFilesGetRequest) Accept(accept string) ApiServicesDirectdataFilesGetRequest {
	r.accept = &accept
	return r
}

func (r ApiServicesDirectdataFilesGetRequest) Authorization(authorization string) ApiServicesDirectdataFilesGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesDirectdataFilesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesDirectdataFilesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesDirectdataFilesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesDirectdataFilesGetExecute(r)
}

/*
ServicesDirectdataFilesGet Retrieve Available Direct Data Files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesDirectdataFilesGetRequest
*/
func (a *DefaultAPIService) ServicesDirectdataFilesGet(ctx context.Context) ApiServicesDirectdataFilesGetRequest {
	return ApiServicesDirectdataFilesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesDirectdataFilesGetExecute(r ApiServicesDirectdataFilesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesDirectdataFilesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/directdata/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.extractType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extract_type", r.extractType, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	}
	if r.stopTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stop_time", r.stopTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesDirectdataFilesNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	name string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiServicesDirectdataFilesNameGetRequest) Accept(accept string) ApiServicesDirectdataFilesNameGetRequest {
	r.accept = &accept
	return r
}

func (r ApiServicesDirectdataFilesNameGetRequest) Authorization(authorization string) ApiServicesDirectdataFilesNameGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesDirectdataFilesNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesDirectdataFilesNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesDirectdataFilesNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesDirectdataFilesNameGetExecute(r)
}

/*
ServicesDirectdataFilesNameGet Download Direct Data File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name The name of the Direct Data file part. Obtain this from the Retrieve Available Direct Data Files request. For example, 146478-20240213-0000-F.001.
 @return ApiServicesDirectdataFilesNameGetRequest
*/
func (a *DefaultAPIService) ServicesDirectdataFilesNameGet(ctx context.Context, name string) ApiServicesDirectdataFilesNameGetRequest {
	return ApiServicesDirectdataFilesNameGetRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesDirectdataFilesNameGetExecute(r ApiServicesDirectdataFilesNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesDirectdataFilesNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/directdata/files/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingItemsContentItemGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	item string
	authorization *string
	accept *string
	range_ *string
	xVaultAPIClientID *string
}

func (r ApiServicesFileStagingItemsContentItemGetRequest) Authorization(authorization string) ApiServicesFileStagingItemsContentItemGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingItemsContentItemGetRequest) Accept(accept string) ApiServicesFileStagingItemsContentItemGetRequest {
	r.accept = &accept
	return r
}

// Optional: Specifies a partial range of bytes to include in the upload. Maximum 50 MB. Must be in the format &#x60;bytes&#x3D;{min}-{max}&#x60;. For example, &#x60;bytes&#x3D;0-1000&#x60;.
func (r ApiServicesFileStagingItemsContentItemGetRequest) Range_(range_ string) ApiServicesFileStagingItemsContentItemGetRequest {
	r.range_ = &range_
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingItemsContentItemGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingItemsContentItemGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingItemsContentItemGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingItemsContentItemGetExecute(r)
}

/*
ServicesFileStagingItemsContentItemGet Download Item Content

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param item The absolute path to a file or folder. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
 @return ApiServicesFileStagingItemsContentItemGetRequest
*/
func (a *DefaultAPIService) ServicesFileStagingItemsContentItemGet(ctx context.Context, item string) ApiServicesFileStagingItemsContentItemGetRequest {
	return ApiServicesFileStagingItemsContentItemGetRequest{
		ApiService: a,
		ctx: ctx,
		item: item,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingItemsContentItemGetExecute(r ApiServicesFileStagingItemsContentItemGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingItemsContentItemGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/items/content/{item}"
	localVarPath = strings.Replace(localVarPath, "{"+"item"+"}", url.PathEscape(parameterValueToString(r.item, "item")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.range_ != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Range", r.range_, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingItemsItemDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	item string
	recursive *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Applicable to deleting folders only. If true, the request will delete the contents of a folder and all subfolders. The default is false.
func (r ApiServicesFileStagingItemsItemDeleteRequest) Recursive(recursive string) ApiServicesFileStagingItemsItemDeleteRequest {
	r.recursive = &recursive
	return r
}

func (r ApiServicesFileStagingItemsItemDeleteRequest) Authorization(authorization string) ApiServicesFileStagingItemsItemDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingItemsItemDeleteRequest) Accept(accept string) ApiServicesFileStagingItemsItemDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingItemsItemDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingItemsItemDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingItemsItemDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingItemsItemDeleteExecute(r)
}

/*
ServicesFileStagingItemsItemDelete Delete File or Folder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param item The absolute path to the file or folder to delete. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
 @return ApiServicesFileStagingItemsItemDeleteRequest
*/
func (a *DefaultAPIService) ServicesFileStagingItemsItemDelete(ctx context.Context, item string) ApiServicesFileStagingItemsItemDeleteRequest {
	return ApiServicesFileStagingItemsItemDeleteRequest{
		ApiService: a,
		ctx: ctx,
		item: item,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingItemsItemDeleteExecute(r ApiServicesFileStagingItemsItemDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingItemsItemDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/items/{item}"
	localVarPath = strings.Replace(localVarPath, "{"+"item"+"}", url.PathEscape(parameterValueToString(r.item, "item")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingItemsItemGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	item string
	recursive *string
	limit *string
	formatResult *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// If true, the response will contain the contents of all subfolders. If not specified, the default value is false.
func (r ApiServicesFileStagingItemsItemGetRequest) Recursive(recursive string) ApiServicesFileStagingItemsItemGetRequest {
	r.recursive = &recursive
	return r
}

// Optional: The maximum number of items per page in the response. This can be any value between 1 and 1000. If omitted, the default value is 1000.
func (r ApiServicesFileStagingItemsItemGetRequest) Limit(limit string) ApiServicesFileStagingItemsItemGetRequest {
	r.limit = &limit
	return r
}

// If set to csv, the response includes a job_id. Use the Job ID value to retrieve the status and results of the request.
func (r ApiServicesFileStagingItemsItemGetRequest) FormatResult(formatResult string) ApiServicesFileStagingItemsItemGetRequest {
	r.formatResult = &formatResult
	return r
}

func (r ApiServicesFileStagingItemsItemGetRequest) Authorization(authorization string) ApiServicesFileStagingItemsItemGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingItemsItemGetRequest) Accept(accept string) ApiServicesFileStagingItemsItemGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingItemsItemGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingItemsItemGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingItemsItemGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingItemsItemGetExecute(r)
}

/*
ServicesFileStagingItemsItemGet List Items at a Path

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param item The absolute path to the file or folder to delete. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
 @return ApiServicesFileStagingItemsItemGetRequest
*/
func (a *DefaultAPIService) ServicesFileStagingItemsItemGet(ctx context.Context, item string) ApiServicesFileStagingItemsItemGetRequest {
	return ApiServicesFileStagingItemsItemGetRequest{
		ApiService: a,
		ctx: ctx,
		item: item,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingItemsItemGetExecute(r ApiServicesFileStagingItemsItemGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingItemsItemGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/items/{item}"
	localVarPath = strings.Replace(localVarPath, "{"+"item"+"}", url.PathEscape(parameterValueToString(r.item, "item")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.formatResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format_result", r.formatResult, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingItemsItemPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	item string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesFileStagingItemsItemPutRequest) Authorization(authorization string) ApiServicesFileStagingItemsItemPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingItemsItemPutRequest) Accept(accept string) ApiServicesFileStagingItemsItemPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingItemsItemPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingItemsItemPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingItemsItemPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingItemsItemPutExecute(r)
}

/*
ServicesFileStagingItemsItemPut Update Folder or File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param item The absolute path to the file or folder to delete. This path is specific to the authenticated user. Admin users can access the root directory. All other users can only access their own user directory.
 @return ApiServicesFileStagingItemsItemPutRequest
*/
func (a *DefaultAPIService) ServicesFileStagingItemsItemPut(ctx context.Context, item string) ApiServicesFileStagingItemsItemPutRequest {
	return ApiServicesFileStagingItemsItemPutRequest{
		ApiService: a,
		ctx: ctx,
		item: item,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingItemsItemPutExecute(r ApiServicesFileStagingItemsItemPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingItemsItemPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/items/{item}"
	localVarPath = strings.Replace(localVarPath, "{"+"item"+"}", url.PathEscape(parameterValueToString(r.item, "item")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingItemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentMD5 *string
	xVaultAPIClientID *string
}

func (r ApiServicesFileStagingItemsPostRequest) Authorization(authorization string) ApiServicesFileStagingItemsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingItemsPostRequest) Accept(accept string) ApiServicesFileStagingItemsPostRequest {
	r.accept = &accept
	return r
}

// Optional: The MD5 checksum of the file being uploaded.
func (r ApiServicesFileStagingItemsPostRequest) ContentMD5(contentMD5 string) ApiServicesFileStagingItemsPostRequest {
	r.contentMD5 = &contentMD5
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingItemsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingItemsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingItemsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingItemsPostExecute(r)
}

/*
ServicesFileStagingItemsPost Create Folder or File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesFileStagingItemsPostRequest
*/
func (a *DefaultAPIService) ServicesFileStagingItemsPost(ctx context.Context) ApiServicesFileStagingItemsPostRequest {
	return ApiServicesFileStagingItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingItemsPostExecute(r ApiServicesFileStagingItemsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingItemsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-MD5", r.contentMD5, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingUploadGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesFileStagingUploadGetRequest) Authorization(authorization string) ApiServicesFileStagingUploadGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingUploadGetRequest) Accept(accept string) ApiServicesFileStagingUploadGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingUploadGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingUploadGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingUploadGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingUploadGetExecute(r)
}

/*
ServicesFileStagingUploadGet List Upload Sessions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesFileStagingUploadGetRequest
*/
func (a *DefaultAPIService) ServicesFileStagingUploadGet(ctx context.Context) ApiServicesFileStagingUploadGetRequest {
	return ApiServicesFileStagingUploadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingUploadGetExecute(r ApiServicesFileStagingUploadGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingUploadGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/upload/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingUploadPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesFileStagingUploadPostRequest) Authorization(authorization string) ApiServicesFileStagingUploadPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingUploadPostRequest) Accept(accept string) ApiServicesFileStagingUploadPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingUploadPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingUploadPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingUploadPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingUploadPostExecute(r)
}

/*
ServicesFileStagingUploadPost Create Resumable Upload Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesFileStagingUploadPostRequest
*/
func (a *DefaultAPIService) ServicesFileStagingUploadPost(ctx context.Context) ApiServicesFileStagingUploadPostRequest {
	return ApiServicesFileStagingUploadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingUploadPostExecute(r ApiServicesFileStagingUploadPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingUploadPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingUploadUploadSessionIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	uploadSessionId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesFileStagingUploadUploadSessionIdDeleteRequest) Authorization(authorization string) ApiServicesFileStagingUploadUploadSessionIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdDeleteRequest) Accept(accept string) ApiServicesFileStagingUploadUploadSessionIdDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingUploadUploadSessionIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingUploadUploadSessionIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingUploadUploadSessionIdDeleteExecute(r)
}

/*
ServicesFileStagingUploadUploadSessionIdDelete Abort Upload Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uploadSessionId
 @return ApiServicesFileStagingUploadUploadSessionIdDeleteRequest
*/
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdDelete(ctx context.Context, uploadSessionId string) ApiServicesFileStagingUploadUploadSessionIdDeleteRequest {
	return ApiServicesFileStagingUploadUploadSessionIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		uploadSessionId: uploadSessionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdDeleteExecute(r ApiServicesFileStagingUploadUploadSessionIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingUploadUploadSessionIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/upload/{upload_session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"upload_session_id"+"}", url.PathEscape(parameterValueToString(r.uploadSessionId, "uploadSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingUploadUploadSessionIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	uploadSessionId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesFileStagingUploadUploadSessionIdGetRequest) Authorization(authorization string) ApiServicesFileStagingUploadUploadSessionIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdGetRequest) Accept(accept string) ApiServicesFileStagingUploadUploadSessionIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingUploadUploadSessionIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingUploadUploadSessionIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingUploadUploadSessionIdGetExecute(r)
}

/*
ServicesFileStagingUploadUploadSessionIdGet Get Upload Session Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uploadSessionId
 @return ApiServicesFileStagingUploadUploadSessionIdGetRequest
*/
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdGet(ctx context.Context, uploadSessionId string) ApiServicesFileStagingUploadUploadSessionIdGetRequest {
	return ApiServicesFileStagingUploadUploadSessionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		uploadSessionId: uploadSessionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdGetExecute(r ApiServicesFileStagingUploadUploadSessionIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingUploadUploadSessionIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/upload/{upload_session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"upload_session_id"+"}", url.PathEscape(parameterValueToString(r.uploadSessionId, "uploadSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	uploadSessionId string
	limit *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: The maximum number of items per page in the response. This can be any value between 1 and 1000. If omitted, the default value is 1000.
func (r ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest) Limit(limit string) ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest) Authorization(authorization string) ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest) Accept(accept string) ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingUploadUploadSessionIdPartsGetExecute(r)
}

/*
ServicesFileStagingUploadUploadSessionIdPartsGet List File Parts Uploaded to Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uploadSessionId
 @return ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest
*/
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdPartsGet(ctx context.Context, uploadSessionId string) ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest {
	return ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest{
		ApiService: a,
		ctx: ctx,
		uploadSessionId: uploadSessionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdPartsGetExecute(r ApiServicesFileStagingUploadUploadSessionIdPartsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingUploadUploadSessionIdPartsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/upload/{upload_session_id}/parts"
	localVarPath = strings.Replace(localVarPath, "{"+"upload_session_id"+"}", url.PathEscape(parameterValueToString(r.uploadSessionId, "uploadSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingUploadUploadSessionIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	uploadSessionId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesFileStagingUploadUploadSessionIdPostRequest) Authorization(authorization string) ApiServicesFileStagingUploadUploadSessionIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdPostRequest) Accept(accept string) ApiServicesFileStagingUploadUploadSessionIdPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingUploadUploadSessionIdPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingUploadUploadSessionIdPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingUploadUploadSessionIdPostExecute(r)
}

/*
ServicesFileStagingUploadUploadSessionIdPost Commit Upload Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uploadSessionId
 @return ApiServicesFileStagingUploadUploadSessionIdPostRequest
*/
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdPost(ctx context.Context, uploadSessionId string) ApiServicesFileStagingUploadUploadSessionIdPostRequest {
	return ApiServicesFileStagingUploadUploadSessionIdPostRequest{
		ApiService: a,
		ctx: ctx,
		uploadSessionId: uploadSessionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdPostExecute(r ApiServicesFileStagingUploadUploadSessionIdPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingUploadUploadSessionIdPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/upload/{upload_session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"upload_session_id"+"}", url.PathEscape(parameterValueToString(r.uploadSessionId, "uploadSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesFileStagingUploadUploadSessionIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	uploadSessionId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIFilePartNumber *string
	contentMD5 *string
	xVaultAPIClientID *string
}

func (r ApiServicesFileStagingUploadUploadSessionIdPutRequest) Authorization(authorization string) ApiServicesFileStagingUploadUploadSessionIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdPutRequest) Accept(accept string) ApiServicesFileStagingUploadUploadSessionIdPutRequest {
	r.accept = &accept
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdPutRequest) ContentType(contentType string) ApiServicesFileStagingUploadUploadSessionIdPutRequest {
	r.contentType = &contentType
	return r
}

// The part number, which uniquely identifies a file part and defines its position within the file as a whole. If a part is uploaded using a part number that has already been used, Vault overwrites the previously uploaded file part. You must upload parts in numerical order. For example, you cannot upload part 3 without first uploading parts 1 and 2.
func (r ApiServicesFileStagingUploadUploadSessionIdPutRequest) XVaultAPIFilePartNumber(xVaultAPIFilePartNumber string) ApiServicesFileStagingUploadUploadSessionIdPutRequest {
	r.xVaultAPIFilePartNumber = &xVaultAPIFilePartNumber
	return r
}

// Optional: The MD5 checksum of the file part being uploaded.
func (r ApiServicesFileStagingUploadUploadSessionIdPutRequest) ContentMD5(contentMD5 string) ApiServicesFileStagingUploadUploadSessionIdPutRequest {
	r.contentMD5 = &contentMD5
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesFileStagingUploadUploadSessionIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesFileStagingUploadUploadSessionIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesFileStagingUploadUploadSessionIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesFileStagingUploadUploadSessionIdPutExecute(r)
}

/*
ServicesFileStagingUploadUploadSessionIdPut Upload to a Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uploadSessionId
 @return ApiServicesFileStagingUploadUploadSessionIdPutRequest
*/
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdPut(ctx context.Context, uploadSessionId string) ApiServicesFileStagingUploadUploadSessionIdPutRequest {
	return ApiServicesFileStagingUploadUploadSessionIdPutRequest{
		ApiService: a,
		ctx: ctx,
		uploadSessionId: uploadSessionId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesFileStagingUploadUploadSessionIdPutExecute(r ApiServicesFileStagingUploadUploadSessionIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesFileStagingUploadUploadSessionIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/file_staging/upload/{upload_session_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"upload_session_id"+"}", url.PathEscape(parameterValueToString(r.uploadSessionId, "uploadSessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIFilePartNumber != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-FilePartNumber", r.xVaultAPIFilePartNumber, "simple", "")
	}
	if r.contentMD5 != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-MD5", r.contentMD5, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesJobsHistoriesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	startDate *string
	endDate *string
	status *string
	limit *string
	offset *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Sets the date to start retrieving completed jobs, in the format YYYY-MM-DDTHH:MM:SSZ. For example, for 7AM on January 15, 2016, use 2016-01-15T07:00:00Z. If omitted, defaults to the first completed job.
func (r ApiServicesJobsHistoriesGetRequest) StartDate(startDate string) ApiServicesJobsHistoriesGetRequest {
	r.startDate = &startDate
	return r
}

// Sets the date to end retrieving completed jobs, in the format YYYY-MM-DDTHH:MM:SSZ. For example, for 7AM on January 15, 2016, use 2016-01-15T07:00:00Z. If omitted, defaults to the current date and time.
func (r ApiServicesJobsHistoriesGetRequest) EndDate(endDate string) ApiServicesJobsHistoriesGetRequest {
	r.endDate = &endDate
	return r
}

// Filter to only retrieve jobs in a certain status. Allowed values are success, errors_encountered, failed_to_run, missed_schedule, cancelled. If omitted, retrieves all statuses.
func (r ApiServicesJobsHistoriesGetRequest) Status(status string) ApiServicesJobsHistoriesGetRequest {
	r.status = &status
	return r
}

// Paginate the results by specifying the maximum number of histories per page in the response. This can be any value between 1 and 200. If omitted, defaults to 50.
func (r ApiServicesJobsHistoriesGetRequest) Limit(limit string) ApiServicesJobsHistoriesGetRequest {
	r.limit = &limit
	return r
}

// Paginate the results displayed per page by specifying the amount of offset from the first job history returned. If omitted, defaults to 0. If you are viewing the first 50 results (page 1) and want to see the next page, set this to offset&#x3D;51.
func (r ApiServicesJobsHistoriesGetRequest) Offset(offset string) ApiServicesJobsHistoriesGetRequest {
	r.offset = &offset
	return r
}

func (r ApiServicesJobsHistoriesGetRequest) Authorization(authorization string) ApiServicesJobsHistoriesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesJobsHistoriesGetRequest) Accept(accept string) ApiServicesJobsHistoriesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesJobsHistoriesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesJobsHistoriesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesJobsHistoriesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesJobsHistoriesGetExecute(r)
}

/*
ServicesJobsHistoriesGet Retrieve Job Histories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesJobsHistoriesGetRequest
*/
func (a *DefaultAPIService) ServicesJobsHistoriesGet(ctx context.Context) ApiServicesJobsHistoriesGetRequest {
	return ApiServicesJobsHistoriesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesJobsHistoriesGetExecute(r ApiServicesJobsHistoriesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesJobsHistoriesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/jobs/histories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesJobsJobIdErrorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesJobsJobIdErrorsGetRequest) Authorization(authorization string) ApiServicesJobsJobIdErrorsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesJobsJobIdErrorsGetRequest) Accept(accept string) ApiServicesJobsJobIdErrorsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesJobsJobIdErrorsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesJobsJobIdErrorsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesJobsJobIdErrorsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesJobsJobIdErrorsGetExecute(r)
}

/*
ServicesJobsJobIdErrorsGet Retrieve Import Bulk Translation File Job Errors

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The id value of the requested import job. This was returned from the Import Bulk Translation File request.
 @return ApiServicesJobsJobIdErrorsGetRequest
*/
func (a *DefaultAPIService) ServicesJobsJobIdErrorsGet(ctx context.Context, jobId string) ApiServicesJobsJobIdErrorsGetRequest {
	return ApiServicesJobsJobIdErrorsGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesJobsJobIdErrorsGetExecute(r ApiServicesJobsJobIdErrorsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesJobsJobIdErrorsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/jobs/{job_id}/errors"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesJobsJobIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesJobsJobIdGetRequest) Authorization(authorization string) ApiServicesJobsJobIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesJobsJobIdGetRequest) Accept(accept string) ApiServicesJobsJobIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesJobsJobIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesJobsJobIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesJobsJobIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesJobsJobIdGetExecute(r)
}

/*
ServicesJobsJobIdGet Retrieve Job Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The ID of the job, returned from the original job request.
 @return ApiServicesJobsJobIdGetRequest
*/
func (a *DefaultAPIService) ServicesJobsJobIdGet(ctx context.Context, jobId string) ApiServicesJobsJobIdGetRequest {
	return ApiServicesJobsJobIdGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesJobsJobIdGetExecute(r ApiServicesJobsJobIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesJobsJobIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/jobs/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesJobsJobIdSummaryGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesJobsJobIdSummaryGetRequest) Authorization(authorization string) ApiServicesJobsJobIdSummaryGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesJobsJobIdSummaryGetRequest) Accept(accept string) ApiServicesJobsJobIdSummaryGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesJobsJobIdSummaryGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesJobsJobIdSummaryGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesJobsJobIdSummaryGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesJobsJobIdSummaryGetExecute(r)
}

/*
ServicesJobsJobIdSummaryGet Retrieve Import Bulk Translation File Job Summary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The id value of the requested import job. This was returned from the Import Bulk Translation File request.
 @return ApiServicesJobsJobIdSummaryGetRequest
*/
func (a *DefaultAPIService) ServicesJobsJobIdSummaryGet(ctx context.Context, jobId string) ApiServicesJobsJobIdSummaryGetRequest {
	return ApiServicesJobsJobIdSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesJobsJobIdSummaryGetExecute(r ApiServicesJobsJobIdSummaryGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesJobsJobIdSummaryGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/jobs/{job_id}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesJobsJobIdTasksGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesJobsJobIdTasksGetRequest) Authorization(authorization string) ApiServicesJobsJobIdTasksGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesJobsJobIdTasksGetRequest) Accept(accept string) ApiServicesJobsJobIdTasksGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesJobsJobIdTasksGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesJobsJobIdTasksGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesJobsJobIdTasksGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesJobsJobIdTasksGetExecute(r)
}

/*
ServicesJobsJobIdTasksGet Retrieve SDK Job Tasks

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The ID of the SDK job, returned from the original job request.
 @return ApiServicesJobsJobIdTasksGetRequest
*/
func (a *DefaultAPIService) ServicesJobsJobIdTasksGet(ctx context.Context, jobId string) ApiServicesJobsJobIdTasksGetRequest {
	return ApiServicesJobsJobIdTasksGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesJobsJobIdTasksGetExecute(r ApiServicesJobsJobIdTasksGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesJobsJobIdTasksGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/jobs/{job_id}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesJobsMonitorsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	startDate *string
	endDate *string
	status *string
	limit *string
	offset *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Sets the date to start retrieving uncompleted jobs, based on the date and time the job instance was created. Value must be in the format YYYY-MM-DDTHH:MM:SSZ. For example, for 7AM on January 15, 2016, use 2016-01-15T07:00:00Z. If omitted, defaults to the first completed job.
func (r ApiServicesJobsMonitorsGetRequest) StartDate(startDate string) ApiServicesJobsMonitorsGetRequest {
	r.startDate = &startDate
	return r
}

// Sets the date to end retrieving uncompleted jobs, based on the date and time the job instance was created. Value must be in the format YYYY-MM-DDTHH:MM:SSZ. For example, for 7AM on January 15, 2016, use 2016-01-15T07:00:00Z. If omitted, defaults to the current date and time.
func (r ApiServicesJobsMonitorsGetRequest) EndDate(endDate string) ApiServicesJobsMonitorsGetRequest {
	r.endDate = &endDate
	return r
}

// Filter to only retrieve jobs in a certain status. Allowed values are scheduled, queued, running. If omitted, retrieves all statuses.
func (r ApiServicesJobsMonitorsGetRequest) Status(status string) ApiServicesJobsMonitorsGetRequest {
	r.status = &status
	return r
}

// Paginate the results by specifying the maximum number of jobs per page in the response. This can be any value between 1 and 200. If omitted, defaults to 50.
func (r ApiServicesJobsMonitorsGetRequest) Limit(limit string) ApiServicesJobsMonitorsGetRequest {
	r.limit = &limit
	return r
}

// Paginate the results displayed per page by specifying the amount of offset from the first job instance returned. If omitted, defaults to 0. If you are viewing the first 50 results (page 1) and want to see the next page, set this to offset&#x3D;51.
func (r ApiServicesJobsMonitorsGetRequest) Offset(offset string) ApiServicesJobsMonitorsGetRequest {
	r.offset = &offset
	return r
}

func (r ApiServicesJobsMonitorsGetRequest) Authorization(authorization string) ApiServicesJobsMonitorsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesJobsMonitorsGetRequest) Accept(accept string) ApiServicesJobsMonitorsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesJobsMonitorsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesJobsMonitorsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesJobsMonitorsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesJobsMonitorsGetExecute(r)
}

/*
ServicesJobsMonitorsGet Retrieve Job Monitors

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesJobsMonitorsGetRequest
*/
func (a *DefaultAPIService) ServicesJobsMonitorsGet(ctx context.Context) ApiServicesJobsMonitorsGetRequest {
	return ApiServicesJobsMonitorsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesJobsMonitorsGetExecute(r ApiServicesJobsMonitorsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesJobsMonitorsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/jobs/monitors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesJobsStartNowJobIdPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesJobsStartNowJobIdPostRequest) Authorization(authorization string) ApiServicesJobsStartNowJobIdPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesJobsStartNowJobIdPostRequest) Accept(accept string) ApiServicesJobsStartNowJobIdPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesJobsStartNowJobIdPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesJobsStartNowJobIdPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesJobsStartNowJobIdPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesJobsStartNowJobIdPostExecute(r)
}

/*
ServicesJobsStartNowJobIdPost Start Job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The ID of the scheduled job instance to start.
 @return ApiServicesJobsStartNowJobIdPostRequest
*/
func (a *DefaultAPIService) ServicesJobsStartNowJobIdPost(ctx context.Context, jobId string) ApiServicesJobsStartNowJobIdPostRequest {
	return ApiServicesJobsStartNowJobIdPostRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesJobsStartNowJobIdPostExecute(r ApiServicesJobsStartNowJobIdPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesJobsStartNowJobIdPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/jobs/start_now/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesLoaderExtractPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiServicesLoaderExtractPostRequest) Authorization(authorization string) ApiServicesLoaderExtractPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesLoaderExtractPostRequest) Accept(accept string) ApiServicesLoaderExtractPostRequest {
	r.accept = &accept
	return r
}

func (r ApiServicesLoaderExtractPostRequest) ContentType(contentType string) ApiServicesLoaderExtractPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesLoaderExtractPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesLoaderExtractPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesLoaderExtractPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesLoaderExtractPostExecute(r)
}

/*
ServicesLoaderExtractPost Extract Data Files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesLoaderExtractPostRequest
*/
func (a *DefaultAPIService) ServicesLoaderExtractPost(ctx context.Context) ApiServicesLoaderExtractPostRequest {
	return ApiServicesLoaderExtractPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesLoaderExtractPostExecute(r ApiServicesLoaderExtractPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesLoaderExtractPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/loader/extract"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	taskId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest) Authorization(authorization string) ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest) Accept(accept string) ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesLoaderJobIdTasksTaskIdFailurelogGetExecute(r)
}

/*
ServicesLoaderJobIdTasksTaskIdFailurelogGet Retrieve Load Failure Log Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The id value of the requested extract job.
 @param taskId The id value of the requested extract task.
 @return ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest
*/
func (a *DefaultAPIService) ServicesLoaderJobIdTasksTaskIdFailurelogGet(ctx context.Context, jobId string, taskId string) ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest {
	return ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesLoaderJobIdTasksTaskIdFailurelogGetExecute(r ApiServicesLoaderJobIdTasksTaskIdFailurelogGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesLoaderJobIdTasksTaskIdFailurelogGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/loader/{job_id}/tasks/{task_id}/failurelog"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	taskId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest) Authorization(authorization string) ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest) Accept(accept string) ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesLoaderJobIdTasksTaskIdResultsGetExecute(r)
}

/*
ServicesLoaderJobIdTasksTaskIdResultsGet Retrieve Loader Extract Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The id value of the requested extract job.
 @param taskId The id value of the requested extract task.
 @return ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest
*/
func (a *DefaultAPIService) ServicesLoaderJobIdTasksTaskIdResultsGet(ctx context.Context, jobId string, taskId string) ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest {
	return ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesLoaderJobIdTasksTaskIdResultsGetExecute(r ApiServicesLoaderJobIdTasksTaskIdResultsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesLoaderJobIdTasksTaskIdResultsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/loader/{job_id}/tasks/{task_id}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	taskId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest) Authorization(authorization string) ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest) Accept(accept string) ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetExecute(r)
}

/*
ServicesLoaderJobIdTasksTaskIdResultsRenditionsGet Retrieve Loader Extract Renditions Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The id value of the requested extract job.
 @param taskId The id value of the requested extract task.
 @return ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest
*/
func (a *DefaultAPIService) ServicesLoaderJobIdTasksTaskIdResultsRenditionsGet(ctx context.Context, jobId string, taskId string) ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest {
	return ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesLoaderJobIdTasksTaskIdResultsRenditionsGetExecute(r ApiServicesLoaderJobIdTasksTaskIdResultsRenditionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesLoaderJobIdTasksTaskIdResultsRenditionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/loader/{job_id}/tasks/{task_id}/results/renditions"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	taskId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest) Authorization(authorization string) ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest) Accept(accept string) ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesLoaderJobIdTasksTaskIdSuccesslogGetExecute(r)
}

/*
ServicesLoaderJobIdTasksTaskIdSuccesslogGet Retrieve Load Success Log Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The id value of the requested extract job.
 @param taskId The id value of the requested extract task.
 @return ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest
*/
func (a *DefaultAPIService) ServicesLoaderJobIdTasksTaskIdSuccesslogGet(ctx context.Context, jobId string, taskId string) ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest {
	return ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesLoaderJobIdTasksTaskIdSuccesslogGetExecute(r ApiServicesLoaderJobIdTasksTaskIdSuccesslogGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesLoaderJobIdTasksTaskIdSuccesslogGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/loader/{job_id}/tasks/{task_id}/successlog"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesLoaderLoadPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesLoaderLoadPostRequest) Authorization(authorization string) ApiServicesLoaderLoadPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesLoaderLoadPostRequest) ContentType(contentType string) ApiServicesLoaderLoadPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiServicesLoaderLoadPostRequest) Accept(accept string) ApiServicesLoaderLoadPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesLoaderLoadPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesLoaderLoadPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesLoaderLoadPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesLoaderLoadPostExecute(r)
}

/*
ServicesLoaderLoadPost Load Data Objects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesLoaderLoadPostRequest
*/
func (a *DefaultAPIService) ServicesLoaderLoadPost(ctx context.Context) ApiServicesLoaderLoadPostRequest {
	return ApiServicesLoaderLoadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesLoaderLoadPostExecute(r ApiServicesLoaderLoadPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesLoaderLoadPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/loader/load"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesPackageActionsValidatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiServicesPackageActionsValidatePostRequest) Authorization(authorization string) ApiServicesPackageActionsValidatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesPackageActionsValidatePostRequest) ContentType(contentType string) ApiServicesPackageActionsValidatePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesPackageActionsValidatePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesPackageActionsValidatePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesPackageActionsValidatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesPackageActionsValidatePostExecute(r)
}

/*
ServicesPackageActionsValidatePost Validate Package

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesPackageActionsValidatePostRequest
*/
func (a *DefaultAPIService) ServicesPackageActionsValidatePost(ctx context.Context) ApiServicesPackageActionsValidatePostRequest {
	return ApiServicesPackageActionsValidatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesPackageActionsValidatePostExecute(r ApiServicesPackageActionsValidatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesPackageActionsValidatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/package/actions/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesPackagePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiServicesPackagePostRequest) Authorization(authorization string) ApiServicesPackagePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesPackagePostRequest) ContentType(contentType string) ApiServicesPackagePostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesPackagePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesPackagePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesPackagePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesPackagePostExecute(r)
}

/*
ServicesPackagePost Export Package

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesPackagePostRequest
*/
func (a *DefaultAPIService) ServicesPackagePost(ctx context.Context) ApiServicesPackagePostRequest {
	return ApiServicesPackagePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesPackagePostExecute(r ApiServicesPackagePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesPackagePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/package"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesPackagePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesPackagePutRequest) Authorization(authorization string) ApiServicesPackagePutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesPackagePutRequest) ContentType(contentType string) ApiServicesPackagePutRequest {
	r.contentType = &contentType
	return r
}

func (r ApiServicesPackagePutRequest) Accept(accept string) ApiServicesPackagePutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesPackagePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesPackagePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesPackagePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesPackagePutExecute(r)
}

/*
ServicesPackagePut Import Package

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesPackagePutRequest
*/
func (a *DefaultAPIService) ServicesPackagePut(ctx context.Context) ApiServicesPackagePutRequest {
	return ApiServicesPackagePutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesPackagePutExecute(r ApiServicesPackagePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesPackagePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/package"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesQueuesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesQueuesGetRequest) Authorization(authorization string) ApiServicesQueuesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesQueuesGetRequest) Accept(accept string) ApiServicesQueuesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesQueuesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesQueuesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesQueuesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesQueuesGetExecute(r)
}

/*
ServicesQueuesGet Retrieve All Queues

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServicesQueuesGetRequest
*/
func (a *DefaultAPIService) ServicesQueuesGet(ctx context.Context) ApiServicesQueuesGetRequest {
	return ApiServicesQueuesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesQueuesGetExecute(r ApiServicesQueuesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesQueuesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/queues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	queueName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest) Authorization(authorization string) ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest) Accept(accept string) ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesQueuesQueueNameActionsDisableDeliveryPutExecute(r)
}

/*
ServicesQueuesQueueNameActionsDisableDeliveryPut Disable Delivery

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param queueName The name of a specific Queue.
 @return ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest
*/
func (a *DefaultAPIService) ServicesQueuesQueueNameActionsDisableDeliveryPut(ctx context.Context, queueName string) ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest {
	return ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest{
		ApiService: a,
		ctx: ctx,
		queueName: queueName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesQueuesQueueNameActionsDisableDeliveryPutExecute(r ApiServicesQueuesQueueNameActionsDisableDeliveryPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesQueuesQueueNameActionsDisableDeliveryPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/queues/{queue_name}/actions/disable_delivery"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_name"+"}", url.PathEscape(parameterValueToString(r.queueName, "queueName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	queueName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest) Authorization(authorization string) ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest) Accept(accept string) ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesQueuesQueueNameActionsEnableDeliveryPutExecute(r)
}

/*
ServicesQueuesQueueNameActionsEnableDeliveryPut Enable Delivery

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param queueName The name of a specific Queue.
 @return ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest
*/
func (a *DefaultAPIService) ServicesQueuesQueueNameActionsEnableDeliveryPut(ctx context.Context, queueName string) ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest {
	return ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest{
		ApiService: a,
		ctx: ctx,
		queueName: queueName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesQueuesQueueNameActionsEnableDeliveryPutExecute(r ApiServicesQueuesQueueNameActionsEnableDeliveryPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesQueuesQueueNameActionsEnableDeliveryPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/queues/{queue_name}/actions/enable_delivery"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_name"+"}", url.PathEscape(parameterValueToString(r.queueName, "queueName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesQueuesQueueNameActionsResetPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	queueName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesQueuesQueueNameActionsResetPutRequest) Authorization(authorization string) ApiServicesQueuesQueueNameActionsResetPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesQueuesQueueNameActionsResetPutRequest) Accept(accept string) ApiServicesQueuesQueueNameActionsResetPutRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesQueuesQueueNameActionsResetPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesQueuesQueueNameActionsResetPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesQueuesQueueNameActionsResetPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesQueuesQueueNameActionsResetPutExecute(r)
}

/*
ServicesQueuesQueueNameActionsResetPut Reset Queue

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param queueName The name of a specific Queue.
 @return ApiServicesQueuesQueueNameActionsResetPutRequest
*/
func (a *DefaultAPIService) ServicesQueuesQueueNameActionsResetPut(ctx context.Context, queueName string) ApiServicesQueuesQueueNameActionsResetPutRequest {
	return ApiServicesQueuesQueueNameActionsResetPutRequest{
		ApiService: a,
		ctx: ctx,
		queueName: queueName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesQueuesQueueNameActionsResetPutExecute(r ApiServicesQueuesQueueNameActionsResetPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesQueuesQueueNameActionsResetPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/queues/{queue_name}/actions/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_name"+"}", url.PathEscape(parameterValueToString(r.queueName, "queueName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesQueuesQueueNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	queueName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesQueuesQueueNameGetRequest) Authorization(authorization string) ApiServicesQueuesQueueNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesQueuesQueueNameGetRequest) Accept(accept string) ApiServicesQueuesQueueNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesQueuesQueueNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesQueuesQueueNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesQueuesQueueNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesQueuesQueueNameGetExecute(r)
}

/*
ServicesQueuesQueueNameGet Retrieve Queue Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param queueName The name of a specific queue. For example, queue__c.
 @return ApiServicesQueuesQueueNameGetRequest
*/
func (a *DefaultAPIService) ServicesQueuesQueueNameGet(ctx context.Context, queueName string) ApiServicesQueuesQueueNameGetRequest {
	return ApiServicesQueuesQueueNameGetRequest{
		ApiService: a,
		ctx: ctx,
		queueName: queueName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesQueuesQueueNameGetExecute(r ApiServicesQueuesQueueNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesQueuesQueueNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/queues/{queue_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"queue_name"+"}", url.PathEscape(parameterValueToString(r.queueName, "queueName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	packageId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest) Authorization(authorization string) ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest) Accept(accept string) ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ServicesVobjectVaultPackageVPackageIdActionsValidatePostExecute(r)
}

/*
ServicesVobjectVaultPackageVPackageIdActionsValidatePost Validate Imported Package

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageId The ID of the package to validate. You can find this in the API response of a package import, or in the URL of package in the Vault UI.
 @return ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest
*/
func (a *DefaultAPIService) ServicesVobjectVaultPackageVPackageIdActionsValidatePost(ctx context.Context, packageId string) ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest {
	return ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest{
		ApiService: a,
		ctx: ctx,
		packageId: packageId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ServicesVobjectVaultPackageVPackageIdActionsValidatePostExecute(r ApiServicesVobjectVaultPackageVPackageIdActionsValidatePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ServicesVobjectVaultPackageVPackageIdActionsValidatePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/services/vobject/vault_package__v/{package_id}/actions/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSessionDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiSessionDeleteRequest) Accept(accept string) ApiSessionDeleteRequest {
	r.accept = &accept
	return r
}

// The Vault sessionId to end.
func (r ApiSessionDeleteRequest) Authorization(authorization string) ApiSessionDeleteRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiSessionDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiSessionDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiSessionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.SessionDeleteExecute(r)
}

/*
SessionDelete End Session

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSessionDeleteRequest
*/
func (a *DefaultAPIService) SessionDelete(ctx context.Context) ApiSessionDeleteRequest {
	return ApiSessionDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) SessionDeleteExecute(r ApiSessionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.SessionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUicodeDistributionsDistributionNameCodeGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	distributionName string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiUicodeDistributionsDistributionNameCodeGetRequest) Accept(accept string) ApiUicodeDistributionsDistributionNameCodeGetRequest {
	r.accept = &accept
	return r
}

func (r ApiUicodeDistributionsDistributionNameCodeGetRequest) Authorization(authorization string) ApiUicodeDistributionsDistributionNameCodeGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiUicodeDistributionsDistributionNameCodeGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiUicodeDistributionsDistributionNameCodeGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiUicodeDistributionsDistributionNameCodeGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.UicodeDistributionsDistributionNameCodeGetExecute(r)
}

/*
UicodeDistributionsDistributionNameCodeGet Download Single Client Code Distribution

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param distributionName The name attribute of the client code distribution to download.
 @return ApiUicodeDistributionsDistributionNameCodeGetRequest
*/
func (a *DefaultAPIService) UicodeDistributionsDistributionNameCodeGet(ctx context.Context, distributionName string) ApiUicodeDistributionsDistributionNameCodeGetRequest {
	return ApiUicodeDistributionsDistributionNameCodeGetRequest{
		ApiService: a,
		ctx: ctx,
		distributionName: distributionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UicodeDistributionsDistributionNameCodeGetExecute(r ApiUicodeDistributionsDistributionNameCodeGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UicodeDistributionsDistributionNameCodeGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uicode/distributions/{distribution_name}/code"
	localVarPath = strings.Replace(localVarPath, "{"+"distribution_name"+"}", url.PathEscape(parameterValueToString(r.distributionName, "distributionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUicodeDistributionsDistributionNameDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	distributionName string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiUicodeDistributionsDistributionNameDeleteRequest) Accept(accept string) ApiUicodeDistributionsDistributionNameDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiUicodeDistributionsDistributionNameDeleteRequest) Authorization(authorization string) ApiUicodeDistributionsDistributionNameDeleteRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiUicodeDistributionsDistributionNameDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiUicodeDistributionsDistributionNameDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiUicodeDistributionsDistributionNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UicodeDistributionsDistributionNameDeleteExecute(r)
}

/*
UicodeDistributionsDistributionNameDelete Delete Single Client Code Distribution

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param distributionName The name attribute of the client code distribution to delete.
 @return ApiUicodeDistributionsDistributionNameDeleteRequest
*/
func (a *DefaultAPIService) UicodeDistributionsDistributionNameDelete(ctx context.Context, distributionName string) ApiUicodeDistributionsDistributionNameDeleteRequest {
	return ApiUicodeDistributionsDistributionNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		distributionName: distributionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UicodeDistributionsDistributionNameDeleteExecute(r ApiUicodeDistributionsDistributionNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UicodeDistributionsDistributionNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uicode/distributions/{distribution_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"distribution_name"+"}", url.PathEscape(parameterValueToString(r.distributionName, "distributionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUicodeDistributionsDistributionNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	distributionName string
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiUicodeDistributionsDistributionNameGetRequest) Accept(accept string) ApiUicodeDistributionsDistributionNameGetRequest {
	r.accept = &accept
	return r
}

func (r ApiUicodeDistributionsDistributionNameGetRequest) Authorization(authorization string) ApiUicodeDistributionsDistributionNameGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiUicodeDistributionsDistributionNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiUicodeDistributionsDistributionNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiUicodeDistributionsDistributionNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.UicodeDistributionsDistributionNameGetExecute(r)
}

/*
UicodeDistributionsDistributionNameGet Retrieve Single Client Code Distribution Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param distributionName The name attribute of the client code distribution to delete.
 @return ApiUicodeDistributionsDistributionNameGetRequest
*/
func (a *DefaultAPIService) UicodeDistributionsDistributionNameGet(ctx context.Context, distributionName string) ApiUicodeDistributionsDistributionNameGetRequest {
	return ApiUicodeDistributionsDistributionNameGetRequest{
		ApiService: a,
		ctx: ctx,
		distributionName: distributionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UicodeDistributionsDistributionNameGetExecute(r ApiUicodeDistributionsDistributionNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UicodeDistributionsDistributionNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uicode/distributions/{distribution_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"distribution_name"+"}", url.PathEscape(parameterValueToString(r.distributionName, "distributionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUicodeDistributionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	accept *string
	authorization *string
	xVaultAPIClientID *string
}

func (r ApiUicodeDistributionsGetRequest) Accept(accept string) ApiUicodeDistributionsGetRequest {
	r.accept = &accept
	return r
}

func (r ApiUicodeDistributionsGetRequest) Authorization(authorization string) ApiUicodeDistributionsGetRequest {
	r.authorization = &authorization
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiUicodeDistributionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiUicodeDistributionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiUicodeDistributionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.UicodeDistributionsGetExecute(r)
}

/*
UicodeDistributionsGet Retrieve All Client Code Distribution Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUicodeDistributionsGetRequest
*/
func (a *DefaultAPIService) UicodeDistributionsGet(ctx context.Context) ApiUicodeDistributionsGetRequest {
	return ApiUicodeDistributionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UicodeDistributionsGetExecute(r ApiUicodeDistributionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UicodeDistributionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uicode/distributions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUicodeDistributionsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	accept *string
	authorization *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiUicodeDistributionsPostRequest) Accept(accept string) ApiUicodeDistributionsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiUicodeDistributionsPostRequest) Authorization(authorization string) ApiUicodeDistributionsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiUicodeDistributionsPostRequest) ContentType(contentType string) ApiUicodeDistributionsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiUicodeDistributionsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiUicodeDistributionsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiUicodeDistributionsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.UicodeDistributionsPostExecute(r)
}

/*
UicodeDistributionsPost Add or Replace Single Client Code Distribution

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUicodeDistributionsPostRequest
*/
func (a *DefaultAPIService) UicodeDistributionsPost(ctx context.Context) ApiUicodeDistributionsPostRequest {
	return ApiUicodeDistributionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) UicodeDistributionsPostExecute(r ApiUicodeDistributionsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.UicodeDistributionsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uicode/distributions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	packageId string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest) Authorization(authorization string) ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest) ContentType(contentType string) ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest) Accept(accept string) ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectVaultPackageVPackageIdActionsDeployPostExecute(r)
}

/*
VobjectVaultPackageVPackageIdActionsDeployPost Deploy Package

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageId The id field value of the vault_package__v object record used for deployment. See Import Package.
 @return ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest
*/
func (a *DefaultAPIService) VobjectVaultPackageVPackageIdActionsDeployPost(ctx context.Context, packageId string) ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest {
	return ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest{
		ApiService: a,
		ctx: ctx,
		packageId: packageId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectVaultPackageVPackageIdActionsDeployPostExecute(r ApiVobjectVaultPackageVPackageIdActionsDeployPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectVaultPackageVPackageIdActionsDeployPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobject/vault_package__v/{package_id}/actions/deploy"
	localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	packageId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest) Authorization(authorization string) ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest) Accept(accept string) ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectVaultPackageVPackageIdActionsDeployResultsGetExecute(r)
}

/*
VobjectVaultPackageVPackageIdActionsDeployResultsGet Retrieve Package Deploy Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageId The id field value of the vault_package__v object record used for deployment. See Deploy Package.
 @return ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest
*/
func (a *DefaultAPIService) VobjectVaultPackageVPackageIdActionsDeployResultsGet(ctx context.Context, packageId string) ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest {
	return ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest{
		ApiService: a,
		ctx: ctx,
		packageId: packageId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectVaultPackageVPackageIdActionsDeployResultsGetExecute(r ApiVobjectVaultPackageVPackageIdActionsDeployResultsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectVaultPackageVPackageIdActionsDeployResultsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobject/vault_package__v/{package_id}/actions/deploy/results"
	localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	jobStatus string
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest) Authorization(authorization string) ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest) Accept(accept string) ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetExecute(r)
}

/*
VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet Retrieve Results of Cascade Delete Job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param jobStatus
 @param jobId
 @return ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest
*/
func (a *DefaultAPIService) VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet(ctx context.Context, objectName string, jobStatus string, jobId string) ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest {
	return ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		jobStatus: jobStatus,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetExecute(r ApiVobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsCascadedeleteResultsObjectNameJobStatusJobIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/cascadedelete/results/{object_name}/{job_status}/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_status"+"}", url.PathEscape(parameterValueToString(r.jobStatus, "jobStatus")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	jobStatus string
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest) Authorization(authorization string) ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest) Accept(accept string) ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetExecute(r)
}

/*
VobjectsDeepcopyResultsObjectNameJobStatusJobIdGet Retrieve Results of Deep Copy Job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param jobStatus The ID of the job, retrieved from the response of the job request.
 @param jobId Possible values are success or failure. Find if your job succeeded or failed by retrieving the job status.
 @return ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest
*/
func (a *DefaultAPIService) VobjectsDeepcopyResultsObjectNameJobStatusJobIdGet(ctx context.Context, objectName string, jobStatus string, jobId string) ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest {
	return ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		jobStatus: jobStatus,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsDeepcopyResultsObjectNameJobStatusJobIdGetExecute(r ApiVobjectsDeepcopyResultsObjectNameJobStatusJobIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsDeepcopyResultsObjectNameJobStatusJobIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/deepcopy/results/{object_name}/{job_status}/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_status"+"}", url.PathEscape(parameterValueToString(r.jobStatus, "jobStatus")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest) Authorization(authorization string) ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest) ContentType(contentType string) ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest) Accept(accept string) ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsEdlItemVActionsCreateplaceholderPostExecute(r)
}

/*
VobjectsEdlItemVActionsCreateplaceholderPost Create a Placeholder from an EDL Item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest
*/
func (a *DefaultAPIService) VobjectsEdlItemVActionsCreateplaceholderPost(ctx context.Context) ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest {
	return ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsEdlItemVActionsCreateplaceholderPostExecute(r ApiVobjectsEdlItemVActionsCreateplaceholderPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsEdlItemVActionsCreateplaceholderPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/edl_item__v/actions/createplaceholder"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsMergesJobIdLogGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsMergesJobIdLogGetRequest) Authorization(authorization string) ApiVobjectsMergesJobIdLogGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsMergesJobIdLogGetRequest) Accept(accept string) ApiVobjectsMergesJobIdLogGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsMergesJobIdLogGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsMergesJobIdLogGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsMergesJobIdLogGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsMergesJobIdLogGetExecute(r)
}

/*
VobjectsMergesJobIdLogGet Download Merge Records Job Log

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The job_id field value returned from the merge operation. You can start merge operations with the Initiate Record Merge API request or with the Vault Java SDK.
 @return ApiVobjectsMergesJobIdLogGetRequest
*/
func (a *DefaultAPIService) VobjectsMergesJobIdLogGet(ctx context.Context, jobId string) ApiVobjectsMergesJobIdLogGetRequest {
	return ApiVobjectsMergesJobIdLogGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsMergesJobIdLogGetExecute(r ApiVobjectsMergesJobIdLogGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsMergesJobIdLogGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/merges/{job_id}/log"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsMergesJobIdResultsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsMergesJobIdResultsGetRequest) Authorization(authorization string) ApiVobjectsMergesJobIdResultsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsMergesJobIdResultsGetRequest) Accept(accept string) ApiVobjectsMergesJobIdResultsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsMergesJobIdResultsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsMergesJobIdResultsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsMergesJobIdResultsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsMergesJobIdResultsGetExecute(r)
}

/*
VobjectsMergesJobIdResultsGet Retrieve Record Merge Results

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The job_id field value returned from the merge operation. You can start merge operations with the Initiate Record Merge API request or with the Vault Java SDK.
 @return ApiVobjectsMergesJobIdResultsGetRequest
*/
func (a *DefaultAPIService) VobjectsMergesJobIdResultsGet(ctx context.Context, jobId string) ApiVobjectsMergesJobIdResultsGetRequest {
	return ApiVobjectsMergesJobIdResultsGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsMergesJobIdResultsGetExecute(r ApiVobjectsMergesJobIdResultsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsMergesJobIdResultsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/merges/{job_id}/results"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsMergesJobIdStatusGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	jobId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsMergesJobIdStatusGetRequest) Authorization(authorization string) ApiVobjectsMergesJobIdStatusGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsMergesJobIdStatusGetRequest) Accept(accept string) ApiVobjectsMergesJobIdStatusGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsMergesJobIdStatusGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsMergesJobIdStatusGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsMergesJobIdStatusGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsMergesJobIdStatusGetExecute(r)
}

/*
VobjectsMergesJobIdStatusGet Retrieve Record Merge Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The job_id field value returned from the merge operation. You can start merge operations with the Initiate Record Merge API request or with the Vault Java SDK.
 @return ApiVobjectsMergesJobIdStatusGetRequest
*/
func (a *DefaultAPIService) VobjectsMergesJobIdStatusGet(ctx context.Context, jobId string) ApiVobjectsMergesJobIdStatusGetRequest {
	return ApiVobjectsMergesJobIdStatusGetRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsMergesJobIdStatusGetExecute(r ApiVobjectsMergesJobIdStatusGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsMergesJobIdStatusGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/merges/{job_id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameActionsActionNamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	actionName string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameActionsActionNamePostRequest) Authorization(authorization string) ApiVobjectsObjectNameActionsActionNamePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameActionsActionNamePostRequest) ContentType(contentType string) ApiVobjectsObjectNameActionsActionNamePostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiVobjectsObjectNameActionsActionNamePostRequest) Accept(accept string) ApiVobjectsObjectNameActionsActionNamePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameActionsActionNamePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameActionsActionNamePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameActionsActionNamePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameActionsActionNamePostExecute(r)
}

/*
VobjectsObjectNameActionsActionNamePost Initiate Object Action on Multiple Records

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value.
 @param actionName Either the name of the Objectaction or Objectlifecyclestateuseraction to initiate. This is obtained from the Retrieve User Actions request. The format for action_name is Objectaction.vobject.action or Objectlifecyclestateuseraction.vobject.state.action.
 @return ApiVobjectsObjectNameActionsActionNamePostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameActionsActionNamePost(ctx context.Context, objectName string, actionName string) ApiVobjectsObjectNameActionsActionNamePostRequest {
	return ApiVobjectsObjectNameActionsActionNamePostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		actionName: actionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameActionsActionNamePostExecute(r ApiVobjectsObjectNameActionsActionNamePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameActionsActionNamePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/actions/{action_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"action_name"+"}", url.PathEscape(parameterValueToString(r.actionName, "actionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameActionsChangetypePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameActionsChangetypePostRequest) Authorization(authorization string) ApiVobjectsObjectNameActionsChangetypePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameActionsChangetypePostRequest) ContentType(contentType string) ApiVobjectsObjectNameActionsChangetypePostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiVobjectsObjectNameActionsChangetypePostRequest) Accept(accept string) ApiVobjectsObjectNameActionsChangetypePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameActionsChangetypePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameActionsChangetypePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameActionsChangetypePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameActionsChangetypePostExecute(r)
}

/*
VobjectsObjectNameActionsChangetypePost Change Object Type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The name of the object.
 @return ApiVobjectsObjectNameActionsChangetypePostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameActionsChangetypePost(ctx context.Context, objectName string) ApiVobjectsObjectNameActionsChangetypePostRequest {
	return ApiVobjectsObjectNameActionsChangetypePostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameActionsChangetypePostExecute(r ApiVobjectsObjectNameActionsChangetypePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameActionsChangetypePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/actions/changetype"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameActionsMergePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
	vobjectsObjectNameActionsMergePostRequestInner *[]VobjectsObjectNameActionsMergePostRequestInner
}

func (r ApiVobjectsObjectNameActionsMergePostRequest) Authorization(authorization string) ApiVobjectsObjectNameActionsMergePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameActionsMergePostRequest) ContentType(contentType string) ApiVobjectsObjectNameActionsMergePostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiVobjectsObjectNameActionsMergePostRequest) Accept(accept string) ApiVobjectsObjectNameActionsMergePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameActionsMergePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameActionsMergePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameActionsMergePostRequest) VobjectsObjectNameActionsMergePostRequestInner(vobjectsObjectNameActionsMergePostRequestInner []VobjectsObjectNameActionsMergePostRequestInner) ApiVobjectsObjectNameActionsMergePostRequest {
	r.vobjectsObjectNameActionsMergePostRequestInner = &vobjectsObjectNameActionsMergePostRequestInner
	return r
}

func (r ApiVobjectsObjectNameActionsMergePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameActionsMergePostExecute(r)
}

/*
VobjectsObjectNameActionsMergePost Initiate Record Merge

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value. For example, account__v. This object must have Enable Merges configured.
 @return ApiVobjectsObjectNameActionsMergePostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameActionsMergePost(ctx context.Context, objectName string) ApiVobjectsObjectNameActionsMergePostRequest {
	return ApiVobjectsObjectNameActionsMergePostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameActionsMergePostExecute(r ApiVobjectsObjectNameActionsMergePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameActionsMergePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/actions/merge"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	// body params
	localVarPostBody = r.vobjectsObjectNameActionsMergePostRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest) Authorization(authorization string) ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest) Accept(accept string) ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameActionsRecalculaterollupsGetExecute(r)
}

/*
VobjectsObjectNameActionsRecalculaterollupsGet Retrieve Roll-up Field Recalculation Status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The name of the object for which to check the status of a Roll-up field recalculation.
 @return ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameActionsRecalculaterollupsGet(ctx context.Context, objectName string) ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest {
	return ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameActionsRecalculaterollupsGetExecute(r ApiVobjectsObjectNameActionsRecalculaterollupsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameActionsRecalculaterollupsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/actions/recalculaterollups"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest) Authorization(authorization string) ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest) Accept(accept string) ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameActionsRecalculaterollupsPostExecute(r)
}

/*
VobjectsObjectNameActionsRecalculaterollupsPost Recalculate Roll-up Fields

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The name of the object for which to check the status of a Roll-up field recalculation.
 @return ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameActionsRecalculaterollupsPost(ctx context.Context, objectName string) ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest {
	return ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameActionsRecalculaterollupsPostExecute(r ApiVobjectsObjectNameActionsRecalculaterollupsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameActionsRecalculaterollupsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/actions/recalculaterollups"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest) Authorization(authorization string) ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest) Accept(accept string) ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest) ContentType(contentType string) ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameActionsUpdatecorporatecurrencyPutExecute(r)
}

/*
VobjectsObjectNameActionsUpdatecorporatecurrencyPut Update Corporate Currency Fields

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @return ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameActionsUpdatecorporatecurrencyPut(ctx context.Context, objectName string) ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest {
	return ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameActionsUpdatecorporatecurrencyPutExecute(r ApiVobjectsObjectNameActionsUpdatecorporatecurrencyPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameActionsUpdatecorporatecurrencyPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/actions/updatecorporatecurrency"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameAttachmentsBatchDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	idParam *string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameAttachmentsBatchDeleteRequest) IdParam(idParam string) ApiVobjectsObjectNameAttachmentsBatchDeleteRequest {
	r.idParam = &idParam
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchDeleteRequest) Authorization(authorization string) ApiVobjectsObjectNameAttachmentsBatchDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchDeleteRequest) Accept(accept string) ApiVobjectsObjectNameAttachmentsBatchDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchDeleteRequest) ContentType(contentType string) ApiVobjectsObjectNameAttachmentsBatchDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameAttachmentsBatchDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameAttachmentsBatchDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameAttachmentsBatchDeleteExecute(r)
}

/*
VobjectsObjectNameAttachmentsBatchDelete Delete Multiple Object Record Attachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @return ApiVobjectsObjectNameAttachmentsBatchDeleteRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameAttachmentsBatchDelete(ctx context.Context, objectName string) ApiVobjectsObjectNameAttachmentsBatchDeleteRequest {
	return ApiVobjectsObjectNameAttachmentsBatchDeleteRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameAttachmentsBatchDeleteExecute(r ApiVobjectsObjectNameAttachmentsBatchDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameAttachmentsBatchDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/attachments/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idParam", r.idParam, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameAttachmentsBatchPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameAttachmentsBatchPostRequest) Authorization(authorization string) ApiVobjectsObjectNameAttachmentsBatchPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchPostRequest) Accept(accept string) ApiVobjectsObjectNameAttachmentsBatchPostRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchPostRequest) ContentType(contentType string) ApiVobjectsObjectNameAttachmentsBatchPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameAttachmentsBatchPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameAttachmentsBatchPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameAttachmentsBatchPostExecute(r)
}

/*
VobjectsObjectNameAttachmentsBatchPost Create Multiple Object Record Attachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @return ApiVobjectsObjectNameAttachmentsBatchPostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameAttachmentsBatchPost(ctx context.Context, objectName string) ApiVobjectsObjectNameAttachmentsBatchPostRequest {
	return ApiVobjectsObjectNameAttachmentsBatchPostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameAttachmentsBatchPostExecute(r ApiVobjectsObjectNameAttachmentsBatchPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameAttachmentsBatchPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/attachments/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameAttachmentsBatchPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameAttachmentsBatchPutRequest) Authorization(authorization string) ApiVobjectsObjectNameAttachmentsBatchPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchPutRequest) Accept(accept string) ApiVobjectsObjectNameAttachmentsBatchPutRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchPutRequest) ContentType(contentType string) ApiVobjectsObjectNameAttachmentsBatchPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameAttachmentsBatchPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameAttachmentsBatchPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameAttachmentsBatchPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameAttachmentsBatchPutExecute(r)
}

/*
VobjectsObjectNameAttachmentsBatchPut Update Multiple Object Record Attachment Descriptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @return ApiVobjectsObjectNameAttachmentsBatchPutRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameAttachmentsBatchPut(ctx context.Context, objectName string) ApiVobjectsObjectNameAttachmentsBatchPutRequest {
	return ApiVobjectsObjectNameAttachmentsBatchPutRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameAttachmentsBatchPutExecute(r ApiVobjectsObjectNameAttachmentsBatchPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameAttachmentsBatchPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/attachments/batch"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameDeleteRequest) Authorization(authorization string) ApiVobjectsObjectNameDeleteRequest {
	r.authorization = &authorization
	return r
}

// Can be text/csv or application/json
func (r ApiVobjectsObjectNameDeleteRequest) ContentType(contentType string) ApiVobjectsObjectNameDeleteRequest {
	r.contentType = &contentType
	return r
}

// Can be text/csv or application/json
func (r ApiVobjectsObjectNameDeleteRequest) Accept(accept string) ApiVobjectsObjectNameDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameDeleteExecute(r)
}

/*
VobjectsObjectNameDelete Delete Object Records

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @return ApiVobjectsObjectNameDeleteRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameDelete(ctx context.Context, objectName string) ApiVobjectsObjectNameDeleteRequest {
	return ApiVobjectsObjectNameDeleteRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameDeleteExecute(r ApiVobjectsObjectNameDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameIdRolesRoleNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	id string
	roleName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameIdRolesRoleNameGetRequest) Authorization(authorization string) ApiVobjectsObjectNameIdRolesRoleNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameIdRolesRoleNameGetRequest) Accept(accept string) ApiVobjectsObjectNameIdRolesRoleNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameIdRolesRoleNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameIdRolesRoleNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameIdRolesRoleNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameIdRolesRoleNameGetExecute(r)
}

/*
VobjectsObjectNameIdRolesRoleNameGet Retrieve Object Record Roles

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name.
 @param id The id of the document, binder, or object record.
 @param roleName Optional: Include a role name to filter for a specific role. For example, owner__v.
 @return ApiVobjectsObjectNameIdRolesRoleNameGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameIdRolesRoleNameGet(ctx context.Context, objectName string, id string, roleName string) ApiVobjectsObjectNameIdRolesRoleNameGetRequest {
	return ApiVobjectsObjectNameIdRolesRoleNameGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		id: id,
		roleName: roleName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameIdRolesRoleNameGetExecute(r ApiVobjectsObjectNameIdRolesRoleNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameIdRolesRoleNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{id}/roles/{role_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"role_name"+"}", url.PathEscape(parameterValueToString(r.roleName, "roleName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	actionName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdActionsActionNameGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdActionsActionNameGet Retrieve Object User Actions Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value.
 @param objectRecordId The object record id field value from which to retrieve user actions.
 @param actionName The name of the Objectaction or Objectlifecyclestateuseraction to initiate. You can retrieve this from the Retrieve User Actions request. The format for action_name is Objectaction.vobject.action or Objectlifecyclestateuseraction.vobject.state.action.
 @return ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsActionNameGet(ctx context.Context, objectName string, objectRecordId string, actionName string) ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		actionName: actionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsActionNameGetExecute(r ApiVobjectsObjectNameObjectRecordIdActionsActionNameGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdActionsActionNameGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/actions/{action_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"action_name"+"}", url.PathEscape(parameterValueToString(r.actionName, "actionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	actionName string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest) ContentType(contentType string) ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest {
	r.contentType = &contentType
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdActionsActionNamePostExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdActionsActionNamePost Initiate Object Action on a Single Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value.
 @param objectRecordId The object record id field value from which to retrieve user actions.
 @param actionName The name of the Objectaction or Objectlifecyclestateuseraction to initiate. You can retrieve this from the Retrieve User Actions request. The format for action_name is Objectaction.vobject.action or Objectlifecyclestateuseraction.vobject.state.action.
 @return ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsActionNamePost(ctx context.Context, objectName string, objectRecordId string, actionName string) ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest {
	return ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		actionName: actionName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsActionNamePostExecute(r ApiVobjectsObjectNameObjectRecordIdActionsActionNamePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdActionsActionNamePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/actions/{action_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"action_name"+"}", url.PathEscape(parameterValueToString(r.actionName, "actionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdActionsCascadedeletePostExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdActionsCascadedeletePost Cascade Delete Object Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @return ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsCascadedeletePost(ctx context.Context, objectName string, objectRecordId string) ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest {
	return ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsCascadedeletePostExecute(r ApiVobjectsObjectNameObjectRecordIdActionsCascadedeletePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdActionsCascadedeletePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/actions/cascadedelete"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest) ContentType(contentType string) ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdActionsDeepcopyPostExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdActionsDeepcopyPost Deep Copy Object Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @return ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsDeepcopyPost(ctx context.Context, objectName string, objectRecordId string) ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest {
	return ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsDeepcopyPostExecute(r ApiVobjectsObjectNameObjectRecordIdActionsDeepcopyPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdActionsDeepcopyPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/actions/deepcopy"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdActionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	loc *bool
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Optional: When true, retrieves localized (translated) strings for the label. 
func (r ApiVobjectsObjectNameObjectRecordIdActionsGetRequest) Loc(loc bool) ApiVobjectsObjectNameObjectRecordIdActionsGetRequest {
	r.loc = &loc
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdActionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdActionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdActionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdActionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdActionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdActionsGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdActionsGet Retrieve Object Record User Actions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value.
 @param objectRecordId The object record id field value.
 @return ApiVobjectsObjectNameObjectRecordIdActionsGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsGet(ctx context.Context, objectName string, objectRecordId string) ApiVobjectsObjectNameObjectRecordIdActionsGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdActionsGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdActionsGetExecute(r ApiVobjectsObjectNameObjectRecordIdActionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdActionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loc", r.loc, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentFieldName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet Download Attachment Field File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value. For example, product__v.
 @param objectRecordId The object record id field value.
 @param attachmentFieldName The name of the Attachment field to update.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet(ctx context.Context, objectName string, objectRecordId string, attachmentFieldName string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentFieldName: attachmentFieldName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_field_name"+"}", url.PathEscape(parameterValueToString(r.attachmentFieldName, "attachmentFieldName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentFieldName string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost Update Attachment Field File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value. For example, product__v.
 @param objectRecordId The object record id field value.
 @param attachmentFieldName The name of the Attachment field to update.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost(ctx context.Context, objectName string, objectRecordId string, attachmentFieldName string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentFieldName: attachmentFieldName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_field_name"+"}", url.PathEscape(parameterValueToString(r.attachmentFieldName, "attachmentFieldName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet Download All Attachment Field Files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value. For example, product__v.
 @param objectRecordId The object record id field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet(ctx context.Context, objectName string, objectRecordId string) ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentFieldsFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachment_fields/file"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest) ContentType(contentType string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete Delete Object Record Attachment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @param attachmentId The attachment id field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete(ctx context.Context, objectName string, objectRecordId string, attachmentId string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet Retrieve Object Record Attachment Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @param attachmentId The attachment id field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet(ctx context.Context, objectName string, objectRecordId string, attachmentId string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest) ContentType(contentType string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut Update Object Record Attachment Description

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @param attachmentId The attachment id field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut(ctx context.Context, objectName string, objectRecordId string, attachmentId string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentId string
	attachmentVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete Delete Object Record Attachment Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @param attachmentId The attachment id field value.
 @param attachmentVersion The attachment version__v field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete(ctx context.Context, objectName string, objectRecordId string, attachmentId string, attachmentVersion string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentId string
	attachmentVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet Download Object Record Attachment File

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @param attachmentId The attachment id field value.
 @param attachmentVersion
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet(ctx context.Context, objectName string, objectRecordId string, attachmentId string, attachmentVersion string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentId string
	attachmentVersion string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet Retrieve Object Record Attachment Version Metadata

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @param attachmentId The attachment id field value.
 @param attachmentVersion The attachment version__v field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet(ctx context.Context, objectName string, objectRecordId string, attachmentId string, attachmentVersion string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentId string
	attachmentVersion string
	restore *bool
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) Restore(restore bool) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	r.restore = &restore
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) ContentType(contentType string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost Restore Object Record Attachment Version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @param attachmentId The attachment id field value.
 @param attachmentVersion The attachment version__v field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost(ctx context.Context, objectName string, objectRecordId string, attachmentId string, attachmentVersion string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentId: attachmentId,
		attachmentVersion: attachmentVersion,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_version"+"}", url.PathEscape(parameterValueToString(r.attachmentVersion, "attachmentVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.restore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "restore", r.restore, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	attachmentId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet Retrieve Object Record Attachment Versions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @param attachmentId The attachment id field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet(ctx context.Context, objectName string, objectRecordId string, attachmentId string) ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
		attachmentId: attachmentId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"attachment_id"+"}", url.PathEscape(parameterValueToString(r.attachmentId, "attachmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsFileGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsFileGet Download All Object Record Attachment Files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsFileGet(ctx context.Context, objectName string, objectRecordId string) ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsFileGetExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsFileGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsFileGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments/file"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsGet Retrieve Object Record Attachments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsGet(ctx context.Context, objectName string, objectRecordId string) ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsGetExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest) ContentType(contentType string) ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAttachmentsPostExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAttachmentsPost Create Object Record Attachment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @return ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsPost(ctx context.Context, objectName string, objectRecordId string) ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest {
	return ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAttachmentsPostExecute(r ApiVobjectsObjectNameObjectRecordIdAttachmentsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAttachmentsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	startDate *string
	endDate *string
	formatResult *string
	limit *string
	offset *string
	events *string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

// Specify a start date to retrieve audit history. This date cannot be more than 30 days ago. Dates must be YYYY-MM-DDTHH:MM:SSZ format, for example, 7AM on January 15, 2018 would use 2018-01-15T07:00:00Z. If omitted, defaults to the vVault’s creation date. 
func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) StartDate(startDate string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	r.startDate = &startDate
	return r
}

// Specify an end date to retrieve audit history. This date cannot be more than 30 days ago. Dates must be YYYY-MM-DDTHH:MM:SSZ format, for example, 7AM on January 15, 2018 would use 2018-01-15T07:00:00Z. If omitted, defaults to today’s date. 
func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) EndDate(endDate string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	r.endDate = &endDate
	return r
}

// To request a CSV file of your audit history, use csv. 
func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) FormatResult(formatResult string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	r.formatResult = &formatResult
	return r
}

// Paginate the results by specifying the maximum number of histories per page in the response. This can be any value between 1 and 1000. If omitted, defaults to 200.
func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) Limit(limit string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	r.limit = &limit
	return r
}

// Paginate the results displayed per page by specifying the amount of offset from the entry returned. For example, if you are viewing the first 50 results (page 1) and want to see the next page, set this to offset&#x3D;51. If omitted, defaults to 0.
func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) Offset(offset string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	r.offset = &offset
	return r
}

// Provide a comma-separated list of one or more audit events to retrieve their audit history. See Vault Help for a full list of object audit events. The values passed to this parameter are case sensitive. For example, events&#x3D;Copy,Edit,Delete. If omitted, defaults to all audit events.
func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) Events(events string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	r.events = &events
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdAudittrailGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdAudittrailGet Retrieve Complete Audit History for a Single Object Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value.
 @param objectRecordId The object record id field value from which to retrieve user actions.
 @return ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAudittrailGet(ctx context.Context, objectName string, objectRecordId string) ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdAudittrailGetExecute(r ApiVobjectsObjectNameObjectRecordIdAudittrailGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdAudittrailGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}/audittrail"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.formatResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format_result", r.formatResult, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.events != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "events", r.events, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameObjectRecordIdGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	objectRecordId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameObjectRecordIdGetRequest) Authorization(authorization string) ApiVobjectsObjectNameObjectRecordIdGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdGetRequest) Accept(accept string) ApiVobjectsObjectNameObjectRecordIdGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameObjectRecordIdGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameObjectRecordIdGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameObjectRecordIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameObjectRecordIdGetExecute(r)
}

/*
VobjectsObjectNameObjectRecordIdGet Retrieve Object Record

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @param objectRecordId The object record id field value.
 @return ApiVobjectsObjectNameObjectRecordIdGetRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdGet(ctx context.Context, objectName string, objectRecordId string) ApiVobjectsObjectNameObjectRecordIdGetRequest {
	return ApiVobjectsObjectNameObjectRecordIdGetRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
		objectRecordId: objectRecordId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameObjectRecordIdGetExecute(r ApiVobjectsObjectNameObjectRecordIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameObjectRecordIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/{object_record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"object_record_id"+"}", url.PathEscape(parameterValueToString(r.objectRecordId, "objectRecordId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNamePostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	idParam *string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIMigrationMode *bool
	xVaultAPINoTriggers *bool
	xVaultAPIClientID *string
}

// To upsert object records, add &#x60;idParam&#x3D;{field_name}&#x60; to the request endpoint. You can use any object field which has &#x60;unique&#x60; set to &#x60;true&#x60; in the object metadata. For example, &#x60;idParam&#x3D;external_id__v&#x60;.
func (r ApiVobjectsObjectNamePostRequest) IdParam(idParam string) ApiVobjectsObjectNamePostRequest {
	r.idParam = &idParam
	return r
}

func (r ApiVobjectsObjectNamePostRequest) Authorization(authorization string) ApiVobjectsObjectNamePostRequest {
	r.authorization = &authorization
	return r
}

// Can be text/csv or application/json
func (r ApiVobjectsObjectNamePostRequest) ContentType(contentType string) ApiVobjectsObjectNamePostRequest {
	r.contentType = &contentType
	return r
}

// Can be text/csv or application/json
func (r ApiVobjectsObjectNamePostRequest) Accept(accept string) ApiVobjectsObjectNamePostRequest {
	r.accept = &accept
	return r
}

// If set to &#x60;true&#x60;, Vault allows you to create or update object records in a noninitial state and with minimal validation, create inactive records, and set standard and system-managed fields such as &#x60;created_by__v&#x60;. Does not bypass record triggers. Use the &#x60;X-VaultAPI-NoTriggers&#x60; header to bypass all standard and custom SDK triggers. You must have the Record Migration permission to use this header.
func (r ApiVobjectsObjectNamePostRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode bool) ApiVobjectsObjectNamePostRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// If set to &#x60;true&#x60; and Record Migration Mode is enabled, it bypasses all standard and custom SDK triggers.
func (r ApiVobjectsObjectNamePostRequest) XVaultAPINoTriggers(xVaultAPINoTriggers bool) ApiVobjectsObjectNamePostRequest {
	r.xVaultAPINoTriggers = &xVaultAPINoTriggers
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNamePostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNamePostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNamePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNamePostExecute(r)
}

/*
VobjectsObjectNamePost Create & Upsert Object Records

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @return ApiVobjectsObjectNamePostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNamePost(ctx context.Context, objectName string) ApiVobjectsObjectNamePostRequest {
	return ApiVobjectsObjectNamePostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNamePostExecute(r ApiVobjectsObjectNamePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNamePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idParam != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idParam", r.idParam, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPINoTriggers != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-NoTriggers", r.xVaultAPINoTriggers, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNamePutRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	contentType *string
	accept *string
	xVaultAPIMigrationMode *bool
	xVaultAPINoTriggers *bool
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNamePutRequest) Authorization(authorization string) ApiVobjectsObjectNamePutRequest {
	r.authorization = &authorization
	return r
}

// Can be text/csv or application/json
func (r ApiVobjectsObjectNamePutRequest) ContentType(contentType string) ApiVobjectsObjectNamePutRequest {
	r.contentType = &contentType
	return r
}

// Can be text/csv or application/json
func (r ApiVobjectsObjectNamePutRequest) Accept(accept string) ApiVobjectsObjectNamePutRequest {
	r.accept = &accept
	return r
}

// If set to &#x60;true&#x60;, Vault allows you to update object records in a noninitial state and with minimal validation, create inactive records, and set standard and system-managed fields such as &#x60;created_by__v&#x60;. Does not bypass record triggers. Use the &#x60;X-VaultAPI-NoTriggers&#x60; header to bypass all standard and custom SDK triggers. You must have the Record Migration permission to use this header.
func (r ApiVobjectsObjectNamePutRequest) XVaultAPIMigrationMode(xVaultAPIMigrationMode bool) ApiVobjectsObjectNamePutRequest {
	r.xVaultAPIMigrationMode = &xVaultAPIMigrationMode
	return r
}

// If set to &#x60;true&#x60; and Record Migration Mode is enabled, it bypasses all standard and custom SDK triggers.
func (r ApiVobjectsObjectNamePutRequest) XVaultAPINoTriggers(xVaultAPINoTriggers bool) ApiVobjectsObjectNamePutRequest {
	r.xVaultAPINoTriggers = &xVaultAPINoTriggers
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNamePutRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNamePutRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNamePutRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNamePutExecute(r)
}

/*
VobjectsObjectNamePut Update Object Records

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The object name__v field value (product__v, country__v, custom_object__c, etc.).
 @return ApiVobjectsObjectNamePutRequest
*/
func (a *DefaultAPIService) VobjectsObjectNamePut(ctx context.Context, objectName string) ApiVobjectsObjectNamePutRequest {
	return ApiVobjectsObjectNamePutRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNamePutExecute(r ApiVobjectsObjectNamePutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNamePut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIMigrationMode != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-MigrationMode", r.xVaultAPIMigrationMode, "simple", "")
	}
	if r.xVaultAPINoTriggers != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-NoTriggers", r.xVaultAPINoTriggers, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameRolesDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameRolesDeleteRequest) Authorization(authorization string) ApiVobjectsObjectNameRolesDeleteRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameRolesDeleteRequest) Accept(accept string) ApiVobjectsObjectNameRolesDeleteRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameRolesDeleteRequest) ContentType(contentType string) ApiVobjectsObjectNameRolesDeleteRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameRolesDeleteRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameRolesDeleteRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameRolesDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameRolesDeleteExecute(r)
}

/*
VobjectsObjectNameRolesDelete Remove Users & Groups from Roles on Object Records

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The name of the object where you want to remove roles.
 @return ApiVobjectsObjectNameRolesDeleteRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameRolesDelete(ctx context.Context, objectName string) ApiVobjectsObjectNameRolesDeleteRequest {
	return ApiVobjectsObjectNameRolesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameRolesDeleteExecute(r ApiVobjectsObjectNameRolesDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameRolesDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsObjectNameRolesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	objectName string
	authorization *string
	accept *string
	contentType *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsObjectNameRolesPostRequest) Authorization(authorization string) ApiVobjectsObjectNameRolesPostRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsObjectNameRolesPostRequest) Accept(accept string) ApiVobjectsObjectNameRolesPostRequest {
	r.accept = &accept
	return r
}

func (r ApiVobjectsObjectNameRolesPostRequest) ContentType(contentType string) ApiVobjectsObjectNameRolesPostRequest {
	r.contentType = &contentType
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsObjectNameRolesPostRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsObjectNameRolesPostRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsObjectNameRolesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsObjectNameRolesPostExecute(r)
}

/*
VobjectsObjectNameRolesPost Assign Users & Groups to Roles on Object Records

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectName The name of the object where you want to remove roles.
 @return ApiVobjectsObjectNameRolesPostRequest
*/
func (a *DefaultAPIService) VobjectsObjectNameRolesPost(ctx context.Context, objectName string) ApiVobjectsObjectNameRolesPostRequest {
	return ApiVobjectsObjectNameRolesPostRequest{
		ApiService: a,
		ctx: ctx,
		objectName: objectName,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsObjectNameRolesPostExecute(r ApiVobjectsObjectNameRolesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsObjectNameRolesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/{object_name}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"object_name"+"}", url.PathEscape(parameterValueToString(r.objectName, "objectName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	packageId string
	authorization *string
	accept *string
	xVaultAPIClientID *string
}

func (r ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest) Authorization(authorization string) ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest) Accept(accept string) ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest {
	r.accept = &accept
	return r
}

// Include a Client ID to identify this request. This ID appears in the API Usage Logs, which is avaiable to download from Admin &gt; Logs &gt; API Usage Logs or through the Vault REST API with the Download Daily API Usage request. If omitted, the value will appear as &#x60;unknown&#x60; in the API Usage Log.
func (r ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest) XVaultAPIClientID(xVaultAPIClientID string) ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest {
	r.xVaultAPIClientID = &xVaultAPIClientID
	return r
}

func (r ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.VobjectsOutboundPackageVPackageIdDependenciesGetExecute(r)
}

/*
VobjectsOutboundPackageVPackageIdDependenciesGet Retrieve Outbound Package Dependencies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param packageId The ID of the outbound_package__v record from which to retrieve dependencies.
 @return ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest
*/
func (a *DefaultAPIService) VobjectsOutboundPackageVPackageIdDependenciesGet(ctx context.Context, packageId string) ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest {
	return ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest{
		ApiService: a,
		ctx: ctx,
		packageId: packageId,
	}
}

// Execute executes the request
func (a *DefaultAPIService) VobjectsOutboundPackageVPackageIdDependenciesGetExecute(r ApiVobjectsOutboundPackageVPackageIdDependenciesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.VobjectsOutboundPackageVPackageIdDependenciesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vobjects/outbound_package__v/{package_id}/dependencies"
	localVarPath = strings.Replace(localVarPath, "{"+"package_id"+"}", url.PathEscape(parameterValueToString(r.packageId, "packageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Authorization", r.authorization, "simple", "")
	}
	if r.accept != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "Accept", r.accept, "simple", "")
	}
	if r.xVaultAPIClientID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-VaultAPI-ClientID", r.xVaultAPIClientID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
