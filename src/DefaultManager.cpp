#include <glib-object.h>
#include <json-glib/json-glib.h>

#include "DefaultManager.h"
#include "NetClient.h"
#include "Helpers.h"
#include "Error.h"
#include "RequestInfo.h"

using namespace std;
using namespace Tizen::ArtikCloud;


DefaultManager::DefaultManager()
{

}

DefaultManager::~DefaultManager()
{

}

static gboolean __DefaultManagerresponseHandler(gpointer data)
{
	RequestInfo *request = static_cast<RequestInfo*>(data);
	g_thread_join(request->thread);

	// invoke the callback function
	bool retval = request->processor(*(request->p_chunk), *(request->code), request->errormsg, request->userData, request->handler);

	delete request;
	return FALSE;
}

static gpointer __DefaultManagerthreadFunc(gpointer data)
{
	RequestInfo *request = static_cast<RequestInfo*>(data);

	// handle the request
	NetClient::easycurl(request->host, request->path, request->method, request->queryParams,
	request->mBody, request->headerList, request->p_chunk, request->code, request->errormsg);

	request->thread = g_thread_self();
	g_idle_add(__DefaultManagerresponseHandler, static_cast<gpointer>(request));

	return NULL;
}


static bool apiGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool apiGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/api/");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = apiGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), apiGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::apiGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::apiGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool apiMdlComponentsComponentTypeAndRecordNameFilesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool apiMdlComponentsComponentTypeAndRecordNameFilesGetHelper(char * accessToken,
	std::string componentTypeAndRecordName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/api/mdl/components/{component_type_and_record_name}/files");
	int pos;

	string s_componentTypeAndRecordName("{");
	s_componentTypeAndRecordName.append("component_type_and_record_name");
	s_componentTypeAndRecordName.append("}");
	pos = url.find(s_componentTypeAndRecordName);
	url.erase(pos, s_componentTypeAndRecordName.length());
	url.insert(pos, stringify(&componentTypeAndRecordName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = apiMdlComponentsComponentTypeAndRecordNameFilesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), apiMdlComponentsComponentTypeAndRecordNameFilesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::apiMdlComponentsComponentTypeAndRecordNameFilesGetAsync(char * accessToken,
	std::string componentTypeAndRecordName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlComponentsComponentTypeAndRecordNameFilesGetHelper(accessToken,
	componentTypeAndRecordName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::apiMdlComponentsComponentTypeAndRecordNameFilesGetSync(char * accessToken,
	std::string componentTypeAndRecordName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlComponentsComponentTypeAndRecordNameFilesGetHelper(accessToken,
	componentTypeAndRecordName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool apiMdlComponentsComponentTypeAndRecordNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool apiMdlComponentsComponentTypeAndRecordNameGetHelper(char * accessToken,
	std::string componentTypeAndRecordName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/api/mdl/components/{component_type_and_record_name}");
	int pos;

	string s_componentTypeAndRecordName("{");
	s_componentTypeAndRecordName.append("component_type_and_record_name");
	s_componentTypeAndRecordName.append("}");
	pos = url.find(s_componentTypeAndRecordName);
	url.erase(pos, s_componentTypeAndRecordName.length());
	url.insert(pos, stringify(&componentTypeAndRecordName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = apiMdlComponentsComponentTypeAndRecordNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), apiMdlComponentsComponentTypeAndRecordNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::apiMdlComponentsComponentTypeAndRecordNameGetAsync(char * accessToken,
	std::string componentTypeAndRecordName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlComponentsComponentTypeAndRecordNameGetHelper(accessToken,
	componentTypeAndRecordName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::apiMdlComponentsComponentTypeAndRecordNameGetSync(char * accessToken,
	std::string componentTypeAndRecordName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlComponentsComponentTypeAndRecordNameGetHelper(accessToken,
	componentTypeAndRecordName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool apiMdlExecuteAsyncJobIdResultsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool apiMdlExecuteAsyncJobIdResultsGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/api/mdl/execute_async/{job_id}/results");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = apiMdlExecuteAsyncJobIdResultsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), apiMdlExecuteAsyncJobIdResultsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::apiMdlExecuteAsyncJobIdResultsGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlExecuteAsyncJobIdResultsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::apiMdlExecuteAsyncJobIdResultsGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlExecuteAsyncJobIdResultsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool apiMdlExecuteAsyncPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool apiMdlExecuteAsyncPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/api/mdl/execute_async");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = apiMdlExecuteAsyncPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), apiMdlExecuteAsyncPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::apiMdlExecuteAsyncPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlExecuteAsyncPostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::apiMdlExecuteAsyncPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlExecuteAsyncPostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool apiMdlExecutePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool apiMdlExecutePostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/api/mdl/execute");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = apiMdlExecutePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), apiMdlExecutePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::apiMdlExecutePostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlExecutePostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::apiMdlExecutePostSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlExecutePostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool apiMdlFilesPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool apiMdlFilesPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/api/mdl/files");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = apiMdlFilesPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), apiMdlFilesPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::apiMdlFilesPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlFilesPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::apiMdlFilesPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return apiMdlFilesPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool audittrailAuditTrailTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool audittrailAuditTrailTypeGetHelper(char * accessToken,
	std::string auditTrailType, std::string startDate, std::string endDate, std::string allDates, std::string formatResult, std::string limit, std::string offset, std::string objects, std::string events, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&startDate, "std::string");
	queryParams.insert(pair<string, string>("start_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("start_date");
	}


	itemAtq = stringify(&endDate, "std::string");
	queryParams.insert(pair<string, string>("end_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("end_date");
	}


	itemAtq = stringify(&allDates, "std::string");
	queryParams.insert(pair<string, string>("all_dates", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("all_dates");
	}


	itemAtq = stringify(&formatResult, "std::string");
	queryParams.insert(pair<string, string>("format_result", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("format_result");
	}


	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}


	itemAtq = stringify(&objects, "std::string");
	queryParams.insert(pair<string, string>("objects", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("objects");
	}


	itemAtq = stringify(&events, "std::string");
	queryParams.insert(pair<string, string>("events", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("events");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/audittrail/{audit_trail_type}");
	int pos;

	string s_auditTrailType("{");
	s_auditTrailType.append("audit_trail_type");
	s_auditTrailType.append("}");
	pos = url.find(s_auditTrailType);
	url.erase(pos, s_auditTrailType.length());
	url.insert(pos, stringify(&auditTrailType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = audittrailAuditTrailTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), audittrailAuditTrailTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::audittrailAuditTrailTypeGetAsync(char * accessToken,
	std::string auditTrailType, std::string startDate, std::string endDate, std::string allDates, std::string formatResult, std::string limit, std::string offset, std::string objects, std::string events, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return audittrailAuditTrailTypeGetHelper(accessToken,
	auditTrailType, startDate, endDate, allDates, formatResult, limit, offset, objects, events, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::audittrailAuditTrailTypeGetSync(char * accessToken,
	std::string auditTrailType, std::string startDate, std::string endDate, std::string allDates, std::string formatResult, std::string limit, std::string offset, std::string objects, std::string events, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return audittrailAuditTrailTypeGetHelper(accessToken,
	auditTrailType, startDate, endDate, allDates, formatResult, limit, offset, objects, events, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool authDiscoveryPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool authDiscoveryPostHelper(char * accessToken,
	std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/auth/discovery");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = authDiscoveryPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), authDiscoveryPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::authDiscoveryPostAsync(char * accessToken,
	std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return authDiscoveryPostHelper(accessToken,
	accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::authDiscoveryPostSync(char * accessToken,
	std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return authDiscoveryPostHelper(accessToken,
	accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool authOauthSessionOathOidcProfileIdPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool authOauthSessionOathOidcProfileIdPostHelper(char * accessToken,
	std::string oathOidcProfileId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/auth/oauth/session/{oath_oidc_profile_id}");
	int pos;

	string s_oathOidcProfileId("{");
	s_oathOidcProfileId.append("oath_oidc_profile_id");
	s_oathOidcProfileId.append("}");
	pos = url.find(s_oathOidcProfileId);
	url.erase(pos, s_oathOidcProfileId.length());
	url.insert(pos, stringify(&oathOidcProfileId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = authOauthSessionOathOidcProfileIdPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), authOauthSessionOathOidcProfileIdPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::authOauthSessionOathOidcProfileIdPostAsync(char * accessToken,
	std::string oathOidcProfileId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return authOauthSessionOathOidcProfileIdPostHelper(accessToken,
	oathOidcProfileId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::authOauthSessionOathOidcProfileIdPostSync(char * accessToken,
	std::string oathOidcProfileId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return authOauthSessionOathOidcProfileIdPostHelper(accessToken,
	oathOidcProfileId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool authPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool authPostHelper(char * accessToken,
	std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/auth");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = authPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), authPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::authPostAsync(char * accessToken,
	std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return authPostHelper(accessToken,
	contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::authPostSync(char * accessToken,
	std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return authPostHelper(accessToken,
	contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeClassNameDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeClassNameDeleteHelper(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/{class_name}");
	int pos;

	string s_className("{");
	s_className.append("class_name");
	s_className.append("}");
	pos = url.find(s_className);
	url.erase(pos, s_className.length());
	url.insert(pos, stringify(&className, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeClassNameDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeClassNameDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeClassNameDeleteAsync(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeClassNameDeleteHelper(accessToken,
	className, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeClassNameDeleteSync(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeClassNameDeleteHelper(accessToken,
	className, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeClassNameDisablePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeClassNameDisablePutHelper(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/{class_name}/disable");
	int pos;

	string s_className("{");
	s_className.append("class_name");
	s_className.append("}");
	pos = url.find(s_className);
	url.erase(pos, s_className.length());
	url.insert(pos, stringify(&className, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeClassNameDisablePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeClassNameDisablePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeClassNameDisablePutAsync(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeClassNameDisablePutHelper(accessToken,
	className, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeClassNameDisablePutSync(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeClassNameDisablePutHelper(accessToken,
	className, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeClassNameEnablePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeClassNameEnablePutHelper(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/{class_name}/enable");
	int pos;

	string s_className("{");
	s_className.append("class_name");
	s_className.append("}");
	pos = url.find(s_className);
	url.erase(pos, s_className.length());
	url.insert(pos, stringify(&className, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeClassNameEnablePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeClassNameEnablePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeClassNameEnablePutAsync(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeClassNameEnablePutHelper(accessToken,
	className, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeClassNameEnablePutSync(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeClassNameEnablePutHelper(accessToken,
	className, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeClassNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeClassNameGetHelper(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/{class_name}");
	int pos;

	string s_className("{");
	s_className.append("class_name");
	s_className.append("}");
	pos = url.find(s_className);
	url.erase(pos, s_className.length());
	url.insert(pos, stringify(&className, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeClassNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeClassNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeClassNameGetAsync(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeClassNameGetHelper(accessToken,
	className, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeClassNameGetSync(char * accessToken,
	std::string className, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeClassNameGetHelper(accessToken,
	className, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeProfilerGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeProfilerGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/profiler");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeProfilerGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeProfilerGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeProfilerGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeProfilerGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeProfilerPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeProfilerPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/profiler");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeProfilerPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeProfilerPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeProfilerPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeProfilerPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeProfilerSessionNameActionsEndPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeProfilerSessionNameActionsEndPostHelper(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/profiler/{session_name}/actions/end");
	int pos;

	string s_sessionName("{");
	s_sessionName.append("session_name");
	s_sessionName.append("}");
	pos = url.find(s_sessionName);
	url.erase(pos, s_sessionName.length());
	url.insert(pos, stringify(&sessionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeProfilerSessionNameActionsEndPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeProfilerSessionNameActionsEndPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeProfilerSessionNameActionsEndPostAsync(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerSessionNameActionsEndPostHelper(accessToken,
	sessionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeProfilerSessionNameActionsEndPostSync(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerSessionNameActionsEndPostHelper(accessToken,
	sessionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeProfilerSessionNameDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeProfilerSessionNameDeleteHelper(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/profiler/{session_name}");
	int pos;

	string s_sessionName("{");
	s_sessionName.append("session_name");
	s_sessionName.append("}");
	pos = url.find(s_sessionName);
	url.erase(pos, s_sessionName.length());
	url.insert(pos, stringify(&sessionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeProfilerSessionNameDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeProfilerSessionNameDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeProfilerSessionNameDeleteAsync(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerSessionNameDeleteHelper(accessToken,
	sessionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeProfilerSessionNameDeleteSync(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerSessionNameDeleteHelper(accessToken,
	sessionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeProfilerSessionNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeProfilerSessionNameGetHelper(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/profiler/{session_name}");
	int pos;

	string s_sessionName("{");
	s_sessionName.append("session_name");
	s_sessionName.append("}");
	pos = url.find(s_sessionName);
	url.erase(pos, s_sessionName.length());
	url.insert(pos, stringify(&sessionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeProfilerSessionNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeProfilerSessionNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeProfilerSessionNameGetAsync(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerSessionNameGetHelper(accessToken,
	sessionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeProfilerSessionNameGetSync(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerSessionNameGetHelper(accessToken,
	sessionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codeProfilerSessionNameResultsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codeProfilerSessionNameResultsGetHelper(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code/profiler/{session_name}/results");
	int pos;

	string s_sessionName("{");
	s_sessionName.append("session_name");
	s_sessionName.append("}");
	pos = url.find(s_sessionName);
	url.erase(pos, s_sessionName.length());
	url.insert(pos, stringify(&sessionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codeProfilerSessionNameResultsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codeProfilerSessionNameResultsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codeProfilerSessionNameResultsGetAsync(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerSessionNameResultsGetHelper(accessToken,
	sessionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codeProfilerSessionNameResultsGetSync(char * accessToken,
	std::string sessionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codeProfilerSessionNameResultsGetHelper(accessToken,
	sessionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool codePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool codePutHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/code");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = codePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), codePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::codePutAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codePutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::codePutSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return codePutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool compositesTreesEdlHierarchyOrTemplateActionsListnodesPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool compositesTreesEdlHierarchyOrTemplateActionsListnodesPostHelper(char * accessToken,
	std::string edlHierarchyOrTemplate, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/composites/trees/{edl_hierarchy_or_template}/actions/listnodes");
	int pos;

	string s_edlHierarchyOrTemplate("{");
	s_edlHierarchyOrTemplate.append("edl_hierarchy_or_template");
	s_edlHierarchyOrTemplate.append("}");
	pos = url.find(s_edlHierarchyOrTemplate);
	url.erase(pos, s_edlHierarchyOrTemplate.length());
	url.insert(pos, stringify(&edlHierarchyOrTemplate, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = compositesTreesEdlHierarchyOrTemplateActionsListnodesPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), compositesTreesEdlHierarchyOrTemplateActionsListnodesPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::compositesTreesEdlHierarchyOrTemplateActionsListnodesPostAsync(char * accessToken,
	std::string edlHierarchyOrTemplate, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return compositesTreesEdlHierarchyOrTemplateActionsListnodesPostHelper(accessToken,
	edlHierarchyOrTemplate, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::compositesTreesEdlHierarchyOrTemplateActionsListnodesPostSync(char * accessToken,
	std::string edlHierarchyOrTemplate, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return compositesTreesEdlHierarchyOrTemplateActionsListnodesPostHelper(accessToken,
	edlHierarchyOrTemplate, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool compositesTreesEdlHierarchyOrTemplateGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool compositesTreesEdlHierarchyOrTemplateGetHelper(char * accessToken,
	std::string edlHierarchyOrTemplate, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/composites/trees/{edl_hierarchy_or_template}");
	int pos;

	string s_edlHierarchyOrTemplate("{");
	s_edlHierarchyOrTemplate.append("edl_hierarchy_or_template");
	s_edlHierarchyOrTemplate.append("}");
	pos = url.find(s_edlHierarchyOrTemplate);
	url.erase(pos, s_edlHierarchyOrTemplate.length());
	url.insert(pos, stringify(&edlHierarchyOrTemplate, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = compositesTreesEdlHierarchyOrTemplateGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), compositesTreesEdlHierarchyOrTemplateGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::compositesTreesEdlHierarchyOrTemplateGetAsync(char * accessToken,
	std::string edlHierarchyOrTemplate, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return compositesTreesEdlHierarchyOrTemplateGetHelper(accessToken,
	edlHierarchyOrTemplate, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::compositesTreesEdlHierarchyOrTemplateGetSync(char * accessToken,
	std::string edlHierarchyOrTemplate, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return compositesTreesEdlHierarchyOrTemplateGetHelper(accessToken,
	edlHierarchyOrTemplate, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool compositesTreesEdlHierarchyVParentNodeIdChildrenGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool compositesTreesEdlHierarchyVParentNodeIdChildrenGetHelper(char * accessToken,
	std::string parentNodeId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/composites/trees/edl_hierarchy__v/{parent_node_id}/children");
	int pos;

	string s_parentNodeId("{");
	s_parentNodeId.append("parent_node_id");
	s_parentNodeId.append("}");
	pos = url.find(s_parentNodeId);
	url.erase(pos, s_parentNodeId.length());
	url.insert(pos, stringify(&parentNodeId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = compositesTreesEdlHierarchyVParentNodeIdChildrenGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), compositesTreesEdlHierarchyVParentNodeIdChildrenGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::compositesTreesEdlHierarchyVParentNodeIdChildrenGetAsync(char * accessToken,
	std::string parentNodeId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return compositesTreesEdlHierarchyVParentNodeIdChildrenGetHelper(accessToken,
	parentNodeId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::compositesTreesEdlHierarchyVParentNodeIdChildrenGetSync(char * accessToken,
	std::string parentNodeId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return compositesTreesEdlHierarchyVParentNodeIdChildrenGetHelper(accessToken,
	parentNodeId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool compositesTreesEdlHierarchyVParentNodeIdChildrenPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool compositesTreesEdlHierarchyVParentNodeIdChildrenPutHelper(char * accessToken,
	std::string parentNodeId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/composites/trees/edl_hierarchy__v/{parent_node_id}/children");
	int pos;

	string s_parentNodeId("{");
	s_parentNodeId.append("parent_node_id");
	s_parentNodeId.append("}");
	pos = url.find(s_parentNodeId);
	url.erase(pos, s_parentNodeId.length());
	url.insert(pos, stringify(&parentNodeId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = compositesTreesEdlHierarchyVParentNodeIdChildrenPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), compositesTreesEdlHierarchyVParentNodeIdChildrenPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::compositesTreesEdlHierarchyVParentNodeIdChildrenPutAsync(char * accessToken,
	std::string parentNodeId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return compositesTreesEdlHierarchyVParentNodeIdChildrenPutHelper(accessToken,
	parentNodeId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::compositesTreesEdlHierarchyVParentNodeIdChildrenPutSync(char * accessToken,
	std::string parentNodeId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return compositesTreesEdlHierarchyVParentNodeIdChildrenPutHelper(accessToken,
	parentNodeId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool configurationComponentTypeAndRecordNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool configurationComponentTypeAndRecordNameGetHelper(char * accessToken,
	std::string componentTypeAndRecordName, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "std::string");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/configuration/{component_type_and_record_name}");
	int pos;

	string s_componentTypeAndRecordName("{");
	s_componentTypeAndRecordName.append("component_type_and_record_name");
	s_componentTypeAndRecordName.append("}");
	pos = url.find(s_componentTypeAndRecordName);
	url.erase(pos, s_componentTypeAndRecordName.length());
	url.insert(pos, stringify(&componentTypeAndRecordName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = configurationComponentTypeAndRecordNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), configurationComponentTypeAndRecordNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::configurationComponentTypeAndRecordNameGetAsync(char * accessToken,
	std::string componentTypeAndRecordName, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationComponentTypeAndRecordNameGetHelper(accessToken,
	componentTypeAndRecordName, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::configurationComponentTypeAndRecordNameGetSync(char * accessToken,
	std::string componentTypeAndRecordName, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationComponentTypeAndRecordNameGetHelper(accessToken,
	componentTypeAndRecordName, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool configurationComponentTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool configurationComponentTypeGetHelper(char * accessToken,
	std::string componentType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/configuration/{component_type}");
	int pos;

	string s_componentType("{");
	s_componentType.append("component_type");
	s_componentType.append("}");
	pos = url.find(s_componentType);
	url.erase(pos, s_componentType.length());
	url.insert(pos, stringify(&componentType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = configurationComponentTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), configurationComponentTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::configurationComponentTypeGetAsync(char * accessToken,
	std::string componentType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationComponentTypeGetHelper(accessToken,
	componentType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::configurationComponentTypeGetSync(char * accessToken,
	std::string componentType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationComponentTypeGetHelper(accessToken,
	componentType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool configurationObjectNameAndObjectTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool configurationObjectNameAndObjectTypeGetHelper(char * accessToken,
	std::string objectNameAndObjectType, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "std::string");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/configuration/{object_name_and_object_type}");
	int pos;

	string s_objectNameAndObjectType("{");
	s_objectNameAndObjectType.append("object_name_and_object_type");
	s_objectNameAndObjectType.append("}");
	pos = url.find(s_objectNameAndObjectType);
	url.erase(pos, s_objectNameAndObjectType.length());
	url.insert(pos, stringify(&objectNameAndObjectType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = configurationObjectNameAndObjectTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), configurationObjectNameAndObjectTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::configurationObjectNameAndObjectTypeGetAsync(char * accessToken,
	std::string objectNameAndObjectType, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationObjectNameAndObjectTypeGetHelper(accessToken,
	objectNameAndObjectType, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::configurationObjectNameAndObjectTypeGetSync(char * accessToken,
	std::string objectNameAndObjectType, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationObjectNameAndObjectTypeGetHelper(accessToken,
	objectNameAndObjectType, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool configurationObjecttypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool configurationObjecttypeGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/configuration/Objecttype");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = configurationObjecttypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), configurationObjecttypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::configurationObjecttypeGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationObjecttypeGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::configurationObjecttypeGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationObjecttypeGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool configurationRoleAssignmentRuleDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool configurationRoleAssignmentRuleDeleteHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/configuration/role_assignment_rule");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = configurationRoleAssignmentRuleDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), configurationRoleAssignmentRuleDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::configurationRoleAssignmentRuleDeleteAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationRoleAssignmentRuleDeleteHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::configurationRoleAssignmentRuleDeleteSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationRoleAssignmentRuleDeleteHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool configurationRoleAssignmentRuleGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool configurationRoleAssignmentRuleGetHelper(char * accessToken,
	std::string lifecycleV, std::string roleV, std::string productV, std::string countryV, std::string studyV, std::string studyCountryV, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&lifecycleV, "std::string");
	queryParams.insert(pair<string, string>("lifecycle__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("lifecycle__v");
	}


	itemAtq = stringify(&roleV, "std::string");
	queryParams.insert(pair<string, string>("role__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("role__v");
	}


	itemAtq = stringify(&productV, "std::string");
	queryParams.insert(pair<string, string>("product__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("product__v");
	}


	itemAtq = stringify(&countryV, "std::string");
	queryParams.insert(pair<string, string>("country__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("country__v");
	}


	itemAtq = stringify(&studyV, "std::string");
	queryParams.insert(pair<string, string>("study__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("study__v");
	}


	itemAtq = stringify(&studyCountryV, "std::string");
	queryParams.insert(pair<string, string>("study_country__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("study_country__v");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/configuration/role_assignment_rule");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = configurationRoleAssignmentRuleGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), configurationRoleAssignmentRuleGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::configurationRoleAssignmentRuleGetAsync(char * accessToken,
	std::string lifecycleV, std::string roleV, std::string productV, std::string countryV, std::string studyV, std::string studyCountryV, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationRoleAssignmentRuleGetHelper(accessToken,
	lifecycleV, roleV, productV, countryV, studyV, studyCountryV, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::configurationRoleAssignmentRuleGetSync(char * accessToken,
	std::string lifecycleV, std::string roleV, std::string productV, std::string countryV, std::string studyV, std::string studyCountryV, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationRoleAssignmentRuleGetHelper(accessToken,
	lifecycleV, roleV, productV, countryV, studyV, studyCountryV, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool configurationRoleAssignmentRulePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool configurationRoleAssignmentRulePostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/configuration/role_assignment_rule");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = configurationRoleAssignmentRulePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), configurationRoleAssignmentRulePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::configurationRoleAssignmentRulePostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationRoleAssignmentRulePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::configurationRoleAssignmentRulePostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationRoleAssignmentRulePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool configurationRoleAssignmentRulePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool configurationRoleAssignmentRulePutHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/configuration/role_assignment_rule");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = configurationRoleAssignmentRulePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), configurationRoleAssignmentRulePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::configurationRoleAssignmentRulePutAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationRoleAssignmentRulePutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::configurationRoleAssignmentRulePutSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return configurationRoleAssignmentRulePutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool delegationLoginPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool delegationLoginPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/delegation/login");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = delegationLoginPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), delegationLoginPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::delegationLoginPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return delegationLoginPostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::delegationLoginPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return delegationLoginPostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool delegationVaultsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool delegationVaultsGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/delegation/vaults");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = delegationVaultsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), delegationVaultsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::delegationVaultsGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return delegationVaultsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::delegationVaultsGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return delegationVaultsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool keepAlivePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool keepAlivePostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/keep-alive");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = keepAlivePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), keepAlivePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::keepAlivePostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return keepAlivePostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::keepAlivePostSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return keepAlivePostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool limitsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool limitsGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/limits");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = limitsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), limitsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::limitsGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return limitsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::limitsGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return limitsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool logsApiUsageGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool logsApiUsageGetHelper(char * accessToken,
	std::string date, std::string logFormat, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&date, "std::string");
	queryParams.insert(pair<string, string>("date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("date");
	}


	itemAtq = stringify(&logFormat, "std::string");
	queryParams.insert(pair<string, string>("log_format", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("log_format");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/logs/api_usage");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = logsApiUsageGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), logsApiUsageGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::logsApiUsageGetAsync(char * accessToken,
	std::string date, std::string logFormat, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsApiUsageGetHelper(accessToken,
	date, logFormat, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::logsApiUsageGetSync(char * accessToken,
	std::string date, std::string logFormat, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsApiUsageGetHelper(accessToken,
	date, logFormat, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool logsCodeDebugGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool logsCodeDebugGetHelper(char * accessToken,
	std::string userId, bool includeInactive, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&userId, "std::string");
	queryParams.insert(pair<string, string>("user_id", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("user_id");
	}


	itemAtq = stringify(&includeInactive, "bool");
	queryParams.insert(pair<string, string>("include_inactive", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("include_inactive");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/logs/code/debug");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = logsCodeDebugGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), logsCodeDebugGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::logsCodeDebugGetAsync(char * accessToken,
	std::string userId, bool includeInactive, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugGetHelper(accessToken,
	userId, includeInactive, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::logsCodeDebugGetSync(char * accessToken,
	std::string userId, bool includeInactive, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugGetHelper(accessToken,
	userId, includeInactive, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool logsCodeDebugIdActionsResetDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool logsCodeDebugIdActionsResetDeleteHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/logs/code/debug/{id}/actions/reset");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = logsCodeDebugIdActionsResetDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), logsCodeDebugIdActionsResetDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::logsCodeDebugIdActionsResetDeleteAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugIdActionsResetDeleteHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::logsCodeDebugIdActionsResetDeleteSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugIdActionsResetDeleteHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool logsCodeDebugIdActionsResetPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool logsCodeDebugIdActionsResetPostHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/logs/code/debug/{id}/actions/reset");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = logsCodeDebugIdActionsResetPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), logsCodeDebugIdActionsResetPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::logsCodeDebugIdActionsResetPostAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugIdActionsResetPostHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::logsCodeDebugIdActionsResetPostSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugIdActionsResetPostHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool logsCodeDebugIdFilesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool logsCodeDebugIdFilesGetHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/logs/code/debug/{id}/files");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = logsCodeDebugIdFilesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), logsCodeDebugIdFilesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::logsCodeDebugIdFilesGetAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugIdFilesGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::logsCodeDebugIdFilesGetSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugIdFilesGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool logsCodeDebugIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool logsCodeDebugIdGetHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/logs/code/debug/{id}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = logsCodeDebugIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), logsCodeDebugIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::logsCodeDebugIdGetAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugIdGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::logsCodeDebugIdGetSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugIdGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool logsCodeDebugPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool logsCodeDebugPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/logs/code/debug");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = logsCodeDebugPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), logsCodeDebugPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::logsCodeDebugPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::logsCodeDebugPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeDebugPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool logsCodeRuntimeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool logsCodeRuntimeGetHelper(char * accessToken,
	std::string date, std::string logFormat, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&date, "std::string");
	queryParams.insert(pair<string, string>("date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("date");
	}


	itemAtq = stringify(&logFormat, "std::string");
	queryParams.insert(pair<string, string>("log_format", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("log_format");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/logs/code/runtime");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = logsCodeRuntimeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), logsCodeRuntimeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::logsCodeRuntimeGetAsync(char * accessToken,
	std::string date, std::string logFormat, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeRuntimeGetHelper(accessToken,
	date, logFormat, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::logsCodeRuntimeGetSync(char * accessToken,
	std::string date, std::string logFormat, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return logsCodeRuntimeGetHelper(accessToken,
	date, logFormat, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool messagesMessageTypeActionsImportPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool messagesMessageTypeActionsImportPostHelper(char * accessToken,
	std::string messageType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/messages/{message_type}/actions/import");
	int pos;

	string s_messageType("{");
	s_messageType.append("message_type");
	s_messageType.append("}");
	pos = url.find(s_messageType);
	url.erase(pos, s_messageType.length());
	url.insert(pos, stringify(&messageType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = messagesMessageTypeActionsImportPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), messagesMessageTypeActionsImportPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::messagesMessageTypeActionsImportPostAsync(char * accessToken,
	std::string messageType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return messagesMessageTypeActionsImportPostHelper(accessToken,
	messageType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::messagesMessageTypeActionsImportPostSync(char * accessToken,
	std::string messageType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return messagesMessageTypeActionsImportPostHelper(accessToken,
	messageType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool messagesMessageTypeLanguageLangActionsExportPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool messagesMessageTypeLanguageLangActionsExportPostHelper(char * accessToken,
	std::string messageType, std::string lang, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/messages/{message_type}/language/{lang}/actions/export");
	int pos;

	string s_messageType("{");
	s_messageType.append("message_type");
	s_messageType.append("}");
	pos = url.find(s_messageType);
	url.erase(pos, s_messageType.length());
	url.insert(pos, stringify(&messageType, "std::string"));
	string s_lang("{");
	s_lang.append("lang");
	s_lang.append("}");
	pos = url.find(s_lang);
	url.erase(pos, s_lang.length());
	url.insert(pos, stringify(&lang, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = messagesMessageTypeLanguageLangActionsExportPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), messagesMessageTypeLanguageLangActionsExportPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::messagesMessageTypeLanguageLangActionsExportPostAsync(char * accessToken,
	std::string messageType, std::string lang, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return messagesMessageTypeLanguageLangActionsExportPostHelper(accessToken,
	messageType, lang, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::messagesMessageTypeLanguageLangActionsExportPostSync(char * accessToken,
	std::string messageType, std::string lang, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return messagesMessageTypeLanguageLangActionsExportPostHelper(accessToken,
	messageType, lang, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataAudittrailAuditTrailTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataAudittrailAuditTrailTypeGetHelper(char * accessToken,
	std::string auditTrailType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/audittrail/{audit_trail_type}");
	int pos;

	string s_auditTrailType("{");
	s_auditTrailType.append("audit_trail_type");
	s_auditTrailType.append("}");
	pos = url.find(s_auditTrailType);
	url.erase(pos, s_auditTrailType.length());
	url.insert(pos, stringify(&auditTrailType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataAudittrailAuditTrailTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataAudittrailAuditTrailTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataAudittrailAuditTrailTypeGetAsync(char * accessToken,
	std::string auditTrailType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataAudittrailAuditTrailTypeGetHelper(accessToken,
	auditTrailType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataAudittrailAuditTrailTypeGetSync(char * accessToken,
	std::string auditTrailType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataAudittrailAuditTrailTypeGetHelper(accessToken,
	auditTrailType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataAudittrailGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataAudittrailGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/audittrail");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataAudittrailGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataAudittrailGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataAudittrailGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataAudittrailGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataAudittrailGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataAudittrailGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataComponentsComponentTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataComponentsComponentTypeGetHelper(char * accessToken,
	std::string componentType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/components/{component_type}");
	int pos;

	string s_componentType("{");
	s_componentType.append("component_type");
	s_componentType.append("}");
	pos = url.find(s_componentType);
	url.erase(pos, s_componentType.length());
	url.insert(pos, stringify(&componentType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataComponentsComponentTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataComponentsComponentTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataComponentsComponentTypeGetAsync(char * accessToken,
	std::string componentType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataComponentsComponentTypeGetHelper(accessToken,
	componentType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataComponentsComponentTypeGetSync(char * accessToken,
	std::string componentType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataComponentsComponentTypeGetHelper(accessToken,
	componentType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataComponentsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataComponentsGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/components");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataComponentsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataComponentsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataComponentsGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataComponentsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataComponentsGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataComponentsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsBindersTemplatesBindernodesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsBindersTemplatesBindernodesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/binders/templates/bindernodes");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsBindersTemplatesBindernodesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsBindersTemplatesBindernodesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsBindersTemplatesBindernodesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsBindersTemplatesBindernodesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsBindersTemplatesBindernodesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsBindersTemplatesBindernodesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsBindersTemplatesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsBindersTemplatesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/binders/templates");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsBindersTemplatesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsBindersTemplatesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsBindersTemplatesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsBindersTemplatesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsBindersTemplatesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsBindersTemplatesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetHelper(char * accessToken,
	std::string placemarkType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/annotations/placemarks/types/{placemark_type}");
	int pos;

	string s_placemarkType("{");
	s_placemarkType.append("placemark_type");
	s_placemarkType.append("}");
	pos = url.find(s_placemarkType);
	url.erase(pos, s_placemarkType.length());
	url.insert(pos, stringify(&placemarkType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetAsync(char * accessToken,
	std::string placemarkType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetHelper(accessToken,
	placemarkType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetSync(char * accessToken,
	std::string placemarkType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsAnnotationsPlacemarksTypesPlacemarkTypeGetHelper(accessToken,
	placemarkType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetHelper(char * accessToken,
	std::string referenceType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/annotations/references/types/{reference_type}");
	int pos;

	string s_referenceType("{");
	s_referenceType.append("reference_type");
	s_referenceType.append("}");
	pos = url.find(s_referenceType);
	url.erase(pos, s_referenceType.length());
	url.insert(pos, stringify(&referenceType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetAsync(char * accessToken,
	std::string referenceType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetHelper(accessToken,
	referenceType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetSync(char * accessToken,
	std::string referenceType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsAnnotationsReferencesTypesReferenceTypeGetHelper(accessToken,
	referenceType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetHelper(char * accessToken,
	std::string annotationType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/annotations/types/{annotation_type}");
	int pos;

	string s_annotationType("{");
	s_annotationType.append("annotation_type");
	s_annotationType.append("}");
	pos = url.find(s_annotationType);
	url.erase(pos, s_annotationType.length());
	url.insert(pos, stringify(&annotationType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetAsync(char * accessToken,
	std::string annotationType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetHelper(accessToken,
	annotationType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetSync(char * accessToken,
	std::string annotationType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsAnnotationsTypesAnnotationTypeGetHelper(accessToken,
	annotationType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetHelper(char * accessToken,
	std::string eventType, std::string eventSubtype, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/events/{event_type}/types/{event_subtype}");
	int pos;

	string s_eventType("{");
	s_eventType.append("event_type");
	s_eventType.append("}");
	pos = url.find(s_eventType);
	url.erase(pos, s_eventType.length());
	url.insert(pos, stringify(&eventType, "std::string"));
	string s_eventSubtype("{");
	s_eventSubtype.append("event_subtype");
	s_eventSubtype.append("}");
	pos = url.find(s_eventSubtype);
	url.erase(pos, s_eventSubtype.length());
	url.insert(pos, stringify(&eventSubtype, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetAsync(char * accessToken,
	std::string eventType, std::string eventSubtype, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetHelper(accessToken,
	eventType, eventSubtype, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetSync(char * accessToken,
	std::string eventType, std::string eventSubtype, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsEventsEventTypeTypesEventSubtypeGetHelper(accessToken,
	eventType, eventSubtype, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsEventsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsEventsGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/events");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsEventsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsEventsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsEventsGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsEventsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsEventsGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsEventsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsLockGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsLockGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/lock");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsLockGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsLockGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsLockGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsLockGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsLockGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsLockGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsPropertiesFindCommonPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsPropertiesFindCommonPostHelper(char * accessToken,
	std::string contentType, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/properties/find_common");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsPropertiesFindCommonPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsPropertiesFindCommonPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsPropertiesFindCommonPostAsync(char * accessToken,
	std::string contentType, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsPropertiesFindCommonPostHelper(accessToken,
	contentType, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsPropertiesFindCommonPostSync(char * accessToken,
	std::string contentType, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsPropertiesFindCommonPostHelper(accessToken,
	contentType, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsPropertiesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsPropertiesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/properties");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsPropertiesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsPropertiesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsPropertiesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsPropertiesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsPropertiesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsPropertiesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsTemplatesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsTemplatesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/templates");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsTemplatesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsTemplatesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsTemplatesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTemplatesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsTemplatesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTemplatesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsTypesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsTypesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/types");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsTypesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsTypesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsTypesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsTypesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsTypesTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsTypesTypeGetHelper(char * accessToken,
	std::string type, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/types/{type}");
	int pos;

	string s_type("{");
	s_type.append("type");
	s_type.append("}");
	pos = url.find(s_type);
	url.erase(pos, s_type.length());
	url.insert(pos, stringify(&type, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsTypesTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsTypesTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsTypesTypeGetAsync(char * accessToken,
	std::string type, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesTypeGetHelper(accessToken,
	type, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsTypesTypeGetSync(char * accessToken,
	std::string type, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesTypeGetHelper(accessToken,
	type, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsTypesTypeRelationshipsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsTypesTypeRelationshipsGetHelper(char * accessToken,
	std::string type, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/types/{type}/relationships");
	int pos;

	string s_type("{");
	s_type.append("type");
	s_type.append("}");
	pos = url.find(s_type);
	url.erase(pos, s_type.length());
	url.insert(pos, stringify(&type, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsTypesTypeRelationshipsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsTypesTypeRelationshipsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsTypesTypeRelationshipsGetAsync(char * accessToken,
	std::string type, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesTypeRelationshipsGetHelper(accessToken,
	type, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsTypesTypeRelationshipsGetSync(char * accessToken,
	std::string type, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesTypeRelationshipsGetHelper(accessToken,
	type, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetHelper(char * accessToken,
	std::string type, std::string subtype, std::string classification, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/types/{type}/subtypes/{subtype}/classifications/{classification}");
	int pos;

	string s_type("{");
	s_type.append("type");
	s_type.append("}");
	pos = url.find(s_type);
	url.erase(pos, s_type.length());
	url.insert(pos, stringify(&type, "std::string"));
	string s_subtype("{");
	s_subtype.append("subtype");
	s_subtype.append("}");
	pos = url.find(s_subtype);
	url.erase(pos, s_subtype.length());
	url.insert(pos, stringify(&subtype, "std::string"));
	string s_classification("{");
	s_classification.append("classification");
	s_classification.append("}");
	pos = url.find(s_classification);
	url.erase(pos, s_classification.length());
	url.insert(pos, stringify(&classification, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetAsync(char * accessToken,
	std::string type, std::string subtype, std::string classification, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetHelper(accessToken,
	type, subtype, classification, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetSync(char * accessToken,
	std::string type, std::string subtype, std::string classification, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesTypeSubtypesSubtypeClassificationsClassificationGetHelper(accessToken,
	type, subtype, classification, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetHelper(char * accessToken,
	std::string type, std::string subtype, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/documents/types/{type}/subtypes/{subtype}");
	int pos;

	string s_type("{");
	s_type.append("type");
	s_type.append("}");
	pos = url.find(s_type);
	url.erase(pos, s_type.length());
	url.insert(pos, stringify(&type, "std::string"));
	string s_subtype("{");
	s_subtype.append("subtype");
	s_subtype.append("}");
	pos = url.find(s_subtype);
	url.erase(pos, s_subtype.length());
	url.insert(pos, stringify(&subtype, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetAsync(char * accessToken,
	std::string type, std::string subtype, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetHelper(accessToken,
	type, subtype, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetSync(char * accessToken,
	std::string type, std::string subtype, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsDocumentsTypesTypeSubtypesSubtypeGetHelper(accessToken,
	type, subtype, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsGroupsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsGroupsGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/groups");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsGroupsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsGroupsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsGroupsGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsGroupsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsGroupsGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsGroupsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsSecuritypoliciesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsSecuritypoliciesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/securitypolicies");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsSecuritypoliciesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsSecuritypoliciesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsSecuritypoliciesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsSecuritypoliciesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsSecuritypoliciesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsSecuritypoliciesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataObjectsUsersGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataObjectsUsersGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/objects/users");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataObjectsUsersGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataObjectsUsersGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataObjectsUsersGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsUsersGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataObjectsUsersGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataObjectsUsersGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/query/archived_documents/relationships/document_signature__sysr");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataQueryArchivedDocumentsRelationshipsDocumentSignatureSysrGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/query/documents/relationships/document_signature__sysr");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataQueryDocumentsRelationshipsDocumentSignatureSysrGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataVobjectsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataVobjectsGetHelper(char * accessToken,
	bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "bool");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/vobjects");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataVobjectsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataVobjectsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataVobjectsGetAsync(char * accessToken,
	bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsGetHelper(accessToken,
	loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataVobjectsGetSync(char * accessToken,
	bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsGetHelper(accessToken,
	loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataVobjectsObjectNameActionsCanceldeploymentPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataVobjectsObjectNameActionsCanceldeploymentPostHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/vobjects/{object_name}/actions/canceldeployment");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataVobjectsObjectNameActionsCanceldeploymentPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataVobjectsObjectNameActionsCanceldeploymentPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataVobjectsObjectNameActionsCanceldeploymentPostAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNameActionsCanceldeploymentPostHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataVobjectsObjectNameActionsCanceldeploymentPostSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNameActionsCanceldeploymentPostHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataVobjectsObjectNameFieldsObjectFieldNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataVobjectsObjectNameFieldsObjectFieldNameGetHelper(char * accessToken,
	std::string objectName, std::string objectFieldName, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "bool");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/vobjects/{object_name}/fields/{object_field_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectFieldName("{");
	s_objectFieldName.append("object_field_name");
	s_objectFieldName.append("}");
	pos = url.find(s_objectFieldName);
	url.erase(pos, s_objectFieldName.length());
	url.insert(pos, stringify(&objectFieldName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataVobjectsObjectNameFieldsObjectFieldNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataVobjectsObjectNameFieldsObjectFieldNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataVobjectsObjectNameFieldsObjectFieldNameGetAsync(char * accessToken,
	std::string objectName, std::string objectFieldName, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNameFieldsObjectFieldNameGetHelper(accessToken,
	objectName, objectFieldName, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataVobjectsObjectNameFieldsObjectFieldNameGetSync(char * accessToken,
	std::string objectName, std::string objectFieldName, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNameFieldsObjectFieldNameGetHelper(accessToken,
	objectName, objectFieldName, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataVobjectsObjectNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataVobjectsObjectNameGetHelper(char * accessToken,
	std::string objectName, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "bool");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/vobjects/{object_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataVobjectsObjectNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataVobjectsObjectNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataVobjectsObjectNameGetAsync(char * accessToken,
	std::string objectName, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNameGetHelper(accessToken,
	objectName, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataVobjectsObjectNameGetSync(char * accessToken,
	std::string objectName, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNameGetHelper(accessToken,
	objectName, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataVobjectsObjectNamePageLayoutsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataVobjectsObjectNamePageLayoutsGetHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/vobjects/{object_name}/page_layouts");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataVobjectsObjectNamePageLayoutsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataVobjectsObjectNamePageLayoutsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataVobjectsObjectNamePageLayoutsGetAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNamePageLayoutsGetHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataVobjectsObjectNamePageLayoutsGetSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNamePageLayoutsGetHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool metadataVobjectsObjectNamePageLayoutsLayoutNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool metadataVobjectsObjectNamePageLayoutsLayoutNameGetHelper(char * accessToken,
	std::string objectName, std::string layoutName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/metadata/vobjects/{object_name}/page_layouts/{layout_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_layoutName("{");
	s_layoutName.append("layout_name");
	s_layoutName.append("}");
	pos = url.find(s_layoutName);
	url.erase(pos, s_layoutName.length());
	url.insert(pos, stringify(&layoutName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = metadataVobjectsObjectNamePageLayoutsLayoutNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), metadataVobjectsObjectNamePageLayoutsLayoutNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::metadataVobjectsObjectNamePageLayoutsLayoutNameGetAsync(char * accessToken,
	std::string objectName, std::string layoutName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNamePageLayoutsLayoutNameGetHelper(accessToken,
	objectName, layoutName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::metadataVobjectsObjectNamePageLayoutsLayoutNameGetSync(char * accessToken,
	std::string objectName, std::string layoutName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return metadataVobjectsObjectNamePageLayoutsLayoutNameGetHelper(accessToken,
	objectName, layoutName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool notificationsHistoriesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool notificationsHistoriesGetHelper(char * accessToken,
	std::string startDate, std::string endDate, bool allDates, std::string formatResult, std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&startDate, "std::string");
	queryParams.insert(pair<string, string>("start_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("start_date");
	}


	itemAtq = stringify(&endDate, "std::string");
	queryParams.insert(pair<string, string>("end_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("end_date");
	}


	itemAtq = stringify(&allDates, "bool");
	queryParams.insert(pair<string, string>("all_dates", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("all_dates");
	}


	itemAtq = stringify(&formatResult, "std::string");
	queryParams.insert(pair<string, string>("format_result", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("format_result");
	}


	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/notifications/histories");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = notificationsHistoriesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), notificationsHistoriesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::notificationsHistoriesGetAsync(char * accessToken,
	std::string startDate, std::string endDate, bool allDates, std::string formatResult, std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return notificationsHistoriesGetHelper(accessToken,
	startDate, endDate, allDates, formatResult, limit, offset, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::notificationsHistoriesGetSync(char * accessToken,
	std::string startDate, std::string endDate, bool allDates, std::string formatResult, std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return notificationsHistoriesGetHelper(accessToken,
	startDate, endDate, allDates, formatResult, limit, offset, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectWorkflowActionsActionGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectWorkflowActionsActionGetHelper(char * accessToken,
	std::string action, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/object/workflow/actions/{action}");
	int pos;

	string s_action("{");
	s_action.append("action");
	s_action.append("}");
	pos = url.find(s_action);
	url.erase(pos, s_action.length());
	url.insert(pos, stringify(&action, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectWorkflowActionsActionGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectWorkflowActionsActionGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectWorkflowActionsActionGetAsync(char * accessToken,
	std::string action, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsActionGetHelper(accessToken,
	action, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectWorkflowActionsActionGetSync(char * accessToken,
	std::string action, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsActionGetHelper(accessToken,
	action, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectWorkflowActionsActionPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectWorkflowActionsActionPostHelper(char * accessToken,
	std::string action, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/object/workflow/actions/{action}");
	int pos;

	string s_action("{");
	s_action.append("action");
	s_action.append("}");
	pos = url.find(s_action);
	url.erase(pos, s_action.length());
	url.insert(pos, stringify(&action, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectWorkflowActionsActionPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectWorkflowActionsActionPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectWorkflowActionsActionPostAsync(char * accessToken,
	std::string action, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsActionPostHelper(accessToken,
	action, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectWorkflowActionsActionPostSync(char * accessToken,
	std::string action, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsActionPostHelper(accessToken,
	action, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectWorkflowActionsCanceltasksPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectWorkflowActionsCanceltasksPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/object/workflow/actions/canceltasks");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectWorkflowActionsCanceltasksPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectWorkflowActionsCanceltasksPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectWorkflowActionsCanceltasksPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsCanceltasksPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectWorkflowActionsCanceltasksPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsCanceltasksPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectWorkflowActionsCancelworkflowsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectWorkflowActionsCancelworkflowsPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/object/workflow/actions/cancelworkflows");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectWorkflowActionsCancelworkflowsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectWorkflowActionsCancelworkflowsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectWorkflowActionsCancelworkflowsPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsCancelworkflowsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectWorkflowActionsCancelworkflowsPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsCancelworkflowsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectWorkflowActionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectWorkflowActionsGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/object/workflow/actions");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectWorkflowActionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectWorkflowActionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectWorkflowActionsGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectWorkflowActionsGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectWorkflowActionsReassigntasksPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectWorkflowActionsReassigntasksPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/object/workflow/actions/reassigntasks");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectWorkflowActionsReassigntasksPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectWorkflowActionsReassigntasksPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectWorkflowActionsReassigntasksPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsReassigntasksPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectWorkflowActionsReassigntasksPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsReassigntasksPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectWorkflowActionsReplaceworkflowownerPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectWorkflowActionsReplaceworkflowownerPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/object/workflow/actions/replaceworkflowowner");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectWorkflowActionsReplaceworkflowownerPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectWorkflowActionsReplaceworkflowownerPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectWorkflowActionsReplaceworkflowownerPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsReplaceworkflowownerPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectWorkflowActionsReplaceworkflowownerPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectWorkflowActionsReplaceworkflowownerPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersActionsExportJobIdResultsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersActionsExportJobIdResultsGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/actions/export/{job_id}/results");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersActionsExportJobIdResultsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersActionsExportJobIdResultsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersActionsExportJobIdResultsGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersActionsExportJobIdResultsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersActionsExportJobIdResultsGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersActionsExportJobIdResultsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdActionsExportPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdActionsExportPostHelper(char * accessToken,
	std::string binderId, bool source, std::string renditiontype, std::string docversion, std::string attachments, std::string r_export, bool docfield, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&source, "bool");
	queryParams.insert(pair<string, string>("source", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("source");
	}


	itemAtq = stringify(&renditiontype, "std::string");
	queryParams.insert(pair<string, string>("renditiontype", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("renditiontype");
	}


	itemAtq = stringify(&docversion, "std::string");
	queryParams.insert(pair<string, string>("docversion", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("docversion");
	}


	itemAtq = stringify(&attachments, "std::string");
	queryParams.insert(pair<string, string>("attachments", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("attachments");
	}


	itemAtq = stringify(&r_export, "std::string");
	queryParams.insert(pair<string, string>("export", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("export");
	}


	itemAtq = stringify(&docfield, "bool");
	queryParams.insert(pair<string, string>("docfield", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("docfield");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/actions/export");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdActionsExportPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdActionsExportPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdActionsExportPostAsync(char * accessToken,
	std::string binderId, bool source, std::string renditiontype, std::string docversion, std::string attachments, std::string r_export, bool docfield, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdActionsExportPostHelper(accessToken,
	binderId, source, renditiontype, docversion, attachments, r_export, docfield, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdActionsExportPostSync(char * accessToken,
	std::string binderId, bool source, std::string renditiontype, std::string docversion, std::string attachments, std::string r_export, bool docfield, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdActionsExportPostHelper(accessToken,
	binderId, source, renditiontype, docversion, attachments, r_export, docfield, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdActionsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdActionsPostHelper(char * accessToken,
	std::string binderId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/actions");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdActionsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdActionsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdActionsPostAsync(char * accessToken,
	std::string binderId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdActionsPostHelper(accessToken,
	binderId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdActionsPostSync(char * accessToken,
	std::string binderId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdActionsPostHelper(accessToken,
	binderId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdBindingRulePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdBindingRulePutHelper(char * accessToken,
	std::string binderId, std::string contentType, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/binding_rule");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdBindingRulePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdBindingRulePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdBindingRulePutAsync(char * accessToken,
	std::string binderId, std::string contentType, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdBindingRulePutHelper(accessToken,
	binderId, contentType, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdBindingRulePutSync(char * accessToken,
	std::string binderId, std::string contentType, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdBindingRulePutHelper(accessToken,
	binderId, contentType, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdDeleteHelper(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdDeleteAsync(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDeleteHelper(accessToken,
	binderId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdDeleteSync(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDeleteHelper(accessToken,
	binderId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdDocumentsNodeIdBindingRulePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdDocumentsNodeIdBindingRulePutHelper(char * accessToken,
	std::string binderId, std::string nodeId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/documents/{node_id}/binding_rule");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_nodeId("{");
	s_nodeId.append("node_id");
	s_nodeId.append("}");
	pos = url.find(s_nodeId);
	url.erase(pos, s_nodeId.length());
	url.insert(pos, stringify(&nodeId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdDocumentsNodeIdBindingRulePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdDocumentsNodeIdBindingRulePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdDocumentsNodeIdBindingRulePutAsync(char * accessToken,
	std::string binderId, std::string nodeId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDocumentsNodeIdBindingRulePutHelper(accessToken,
	binderId, nodeId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdDocumentsNodeIdBindingRulePutSync(char * accessToken,
	std::string binderId, std::string nodeId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDocumentsNodeIdBindingRulePutHelper(accessToken,
	binderId, nodeId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdDocumentsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdDocumentsPostHelper(char * accessToken,
	std::string binderId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/documents");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdDocumentsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdDocumentsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdDocumentsPostAsync(char * accessToken,
	std::string binderId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDocumentsPostHelper(accessToken,
	binderId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdDocumentsPostSync(char * accessToken,
	std::string binderId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDocumentsPostHelper(accessToken,
	binderId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdDocumentsSectionIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdDocumentsSectionIdDeleteHelper(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/documents/{section_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_sectionId("{");
	s_sectionId.append("section_id");
	s_sectionId.append("}");
	pos = url.find(s_sectionId);
	url.erase(pos, s_sectionId.length());
	url.insert(pos, stringify(&sectionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdDocumentsSectionIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdDocumentsSectionIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdDocumentsSectionIdDeleteAsync(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDocumentsSectionIdDeleteHelper(accessToken,
	binderId, sectionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdDocumentsSectionIdDeleteSync(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDocumentsSectionIdDeleteHelper(accessToken,
	binderId, sectionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdDocumentsSectionIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdDocumentsSectionIdPutHelper(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/documents/{section_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_sectionId("{");
	s_sectionId.append("section_id");
	s_sectionId.append("}");
	pos = url.find(s_sectionId);
	url.erase(pos, s_sectionId.length());
	url.insert(pos, stringify(&sectionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdDocumentsSectionIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdDocumentsSectionIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdDocumentsSectionIdPutAsync(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDocumentsSectionIdPutHelper(accessToken,
	binderId, sectionId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdDocumentsSectionIdPutSync(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdDocumentsSectionIdPutHelper(accessToken,
	binderId, sectionId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdGetHelper(char * accessToken,
	std::string binderId, std::string depth, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&depth, "std::string");
	queryParams.insert(pair<string, string>("depth", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("depth");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdGetAsync(char * accessToken,
	std::string binderId, std::string depth, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdGetHelper(accessToken,
	binderId, depth, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdGetSync(char * accessToken,
	std::string binderId, std::string depth, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdGetHelper(accessToken,
	binderId, depth, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdPostHelper(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdPostAsync(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdPostHelper(accessToken,
	binderId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdPostSync(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdPostHelper(accessToken,
	binderId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdPutHelper(char * accessToken,
	std::string binderId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdPutAsync(char * accessToken,
	std::string binderId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdPutHelper(accessToken,
	binderId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdPutSync(char * accessToken,
	std::string binderId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdPutHelper(accessToken,
	binderId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteHelper(char * accessToken,
	std::string binderId, std::string roleNameAndUserOrGroup, std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/roles/{role_name_and_user_or_group}/{id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_roleNameAndUserOrGroup("{");
	s_roleNameAndUserOrGroup.append("role_name_and_user_or_group");
	s_roleNameAndUserOrGroup.append("}");
	pos = url.find(s_roleNameAndUserOrGroup);
	url.erase(pos, s_roleNameAndUserOrGroup.length());
	url.insert(pos, stringify(&roleNameAndUserOrGroup, "std::string"));
	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteAsync(char * accessToken,
	std::string binderId, std::string roleNameAndUserOrGroup, std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteHelper(accessToken,
	binderId, roleNameAndUserOrGroup, id, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteSync(char * accessToken,
	std::string binderId, std::string roleNameAndUserOrGroup, std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdRolesRoleNameAndUserOrGroupIdDeleteHelper(accessToken,
	binderId, roleNameAndUserOrGroup, id, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdSectionsNodeIdBindingRulePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdSectionsNodeIdBindingRulePutHelper(char * accessToken,
	std::string binderId, std::string nodeId, std::string contentType, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/sections/{node_id}/binding_rule");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_nodeId("{");
	s_nodeId.append("node_id");
	s_nodeId.append("}");
	pos = url.find(s_nodeId);
	url.erase(pos, s_nodeId.length());
	url.insert(pos, stringify(&nodeId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdSectionsNodeIdBindingRulePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdSectionsNodeIdBindingRulePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdSectionsNodeIdBindingRulePutAsync(char * accessToken,
	std::string binderId, std::string nodeId, std::string contentType, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsNodeIdBindingRulePutHelper(accessToken,
	binderId, nodeId, contentType, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdSectionsNodeIdBindingRulePutSync(char * accessToken,
	std::string binderId, std::string nodeId, std::string contentType, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsNodeIdBindingRulePutHelper(accessToken,
	binderId, nodeId, contentType, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdSectionsNodeIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdSectionsNodeIdPutHelper(char * accessToken,
	std::string binderId, std::string nodeId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/sections/{node_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_nodeId("{");
	s_nodeId.append("node_id");
	s_nodeId.append("}");
	pos = url.find(s_nodeId);
	url.erase(pos, s_nodeId.length());
	url.insert(pos, stringify(&nodeId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdSectionsNodeIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdSectionsNodeIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdSectionsNodeIdPutAsync(char * accessToken,
	std::string binderId, std::string nodeId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsNodeIdPutHelper(accessToken,
	binderId, nodeId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdSectionsNodeIdPutSync(char * accessToken,
	std::string binderId, std::string nodeId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsNodeIdPutHelper(accessToken,
	binderId, nodeId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdSectionsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdSectionsPostHelper(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/sections");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdSectionsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdSectionsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdSectionsPostAsync(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsPostHelper(accessToken,
	binderId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdSectionsPostSync(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsPostHelper(accessToken,
	binderId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdSectionsSectionIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdSectionsSectionIdDeleteHelper(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/sections/{section_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_sectionId("{");
	s_sectionId.append("section_id");
	s_sectionId.append("}");
	pos = url.find(s_sectionId);
	url.erase(pos, s_sectionId.length());
	url.insert(pos, stringify(&sectionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdSectionsSectionIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdSectionsSectionIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdSectionsSectionIdDeleteAsync(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsSectionIdDeleteHelper(accessToken,
	binderId, sectionId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdSectionsSectionIdDeleteSync(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsSectionIdDeleteHelper(accessToken,
	binderId, sectionId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdSectionsSectionIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdSectionsSectionIdGetHelper(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/sections/{section_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_sectionId("{");
	s_sectionId.append("section_id");
	s_sectionId.append("}");
	pos = url.find(s_sectionId);
	url.erase(pos, s_sectionId.length());
	url.insert(pos, stringify(&sectionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdSectionsSectionIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdSectionsSectionIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdSectionsSectionIdGetAsync(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsSectionIdGetHelper(accessToken,
	binderId, sectionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdSectionsSectionIdGetSync(char * accessToken,
	std::string binderId, std::string sectionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdSectionsSectionIdGetHelper(accessToken,
	binderId, sectionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdVersionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdVersionsGetHelper(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/versions");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdVersionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdVersionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdVersionsGetAsync(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsGetHelper(accessToken,
	binderId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdVersionsGetSync(char * accessToken,
	std::string binderId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsGetHelper(accessToken,
	binderId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostHelper(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, bool source, std::string renditiontype, std::string docversion, std::string attachments, std::string r_export, bool docfield, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&source, "bool");
	queryParams.insert(pair<string, string>("source", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("source");
	}


	itemAtq = stringify(&renditiontype, "std::string");
	queryParams.insert(pair<string, string>("renditiontype", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("renditiontype");
	}


	itemAtq = stringify(&docversion, "std::string");
	queryParams.insert(pair<string, string>("docversion", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("docversion");
	}


	itemAtq = stringify(&attachments, "std::string");
	queryParams.insert(pair<string, string>("attachments", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("attachments");
	}


	itemAtq = stringify(&r_export, "std::string");
	queryParams.insert(pair<string, string>("export", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("export");
	}


	itemAtq = stringify(&docfield, "bool");
	queryParams.insert(pair<string, string>("docfield", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("docfield");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/actions/export");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostAsync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, bool source, std::string renditiontype, std::string docversion, std::string attachments, std::string r_export, bool docfield, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostHelper(accessToken,
	binderId, majorVersion, minorVersion, source, renditiontype, docversion, attachments, r_export, docfield, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostSync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, bool source, std::string renditiontype, std::string docversion, std::string attachments, std::string r_export, bool docfield, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionActionsExportPostHelper(accessToken,
	binderId, majorVersion, minorVersion, source, renditiontype, docversion, attachments, r_export, docfield, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteHelper(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteAsync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteHelper(accessToken,
	binderId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteSync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionDeleteHelper(accessToken,
	binderId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionGetHelper(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdVersionsMajorVersionMinorVersionGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdVersionsMajorVersionMinorVersionGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionGetAsync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionGetHelper(accessToken,
	binderId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionGetSync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionGetHelper(accessToken,
	binderId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionPutHelper(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdVersionsMajorVersionMinorVersionPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdVersionsMajorVersionMinorVersionPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionPutAsync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionPutHelper(accessToken,
	binderId, majorVersion, minorVersion, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionPutSync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionPutHelper(accessToken,
	binderId, majorVersion, minorVersion, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostHelper(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostAsync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostHelper(accessToken,
	binderId, majorVersion, minorVersion, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostSync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsPostHelper(accessToken,
	binderId, majorVersion, minorVersion, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteHelper(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_relationshipId("{");
	s_relationshipId.append("relationship_id");
	s_relationshipId.append("}");
	pos = url.find(s_relationshipId);
	url.erase(pos, s_relationshipId.length());
	url.insert(pos, stringify(&relationshipId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteAsync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteHelper(accessToken,
	binderId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteSync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteHelper(accessToken,
	binderId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetHelper(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_relationshipId("{");
	s_relationshipId.append("relationship_id");
	s_relationshipId.append("}");
	pos = url.find(s_relationshipId);
	url.erase(pos, s_relationshipId.length());
	url.insert(pos, stringify(&relationshipId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetAsync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetHelper(accessToken,
	binderId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetSync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetHelper(accessToken,
	binderId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetHelper(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string sectionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{binder_id}/versions/{major_version}/{minor_version}/sections/{section_id}");
	int pos;

	string s_binderId("{");
	s_binderId.append("binder_id");
	s_binderId.append("}");
	pos = url.find(s_binderId);
	url.erase(pos, s_binderId.length());
	url.insert(pos, stringify(&binderId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_sectionId("{");
	s_sectionId.append("section_id");
	s_sectionId.append("}");
	pos = url.find(s_sectionId);
	url.erase(pos, s_sectionId.length());
	url.insert(pos, stringify(&sectionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetAsync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string sectionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetHelper(accessToken,
	binderId, majorVersion, minorVersion, sectionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetSync(char * accessToken,
	std::string binderId, std::string majorVersion, std::string minorVersion, std::string sectionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersBinderIdVersionsMajorVersionMinorVersionSectionsSectionIdGetHelper(accessToken,
	binderId, majorVersion, minorVersion, sectionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersIdRolesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersIdRolesGetHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{id}/roles");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersIdRolesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersIdRolesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersIdRolesGetAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdRolesGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersIdRolesGetSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdRolesGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersIdRolesPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersIdRolesPostHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{id}/roles");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersIdRolesPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersIdRolesPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersIdRolesPostAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdRolesPostHelper(accessToken,
	id, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersIdRolesPostSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdRolesPostHelper(accessToken,
	id, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersIdRolesRoleNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersIdRolesRoleNameGetHelper(char * accessToken,
	std::string id, std::string roleName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{id}/roles/{role_name}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));
	string s_roleName("{");
	s_roleName.append("role_name");
	s_roleName.append("}");
	pos = url.find(s_roleName);
	url.erase(pos, s_roleName.length());
	url.insert(pos, stringify(&roleName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersIdRolesRoleNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersIdRolesRoleNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersIdRolesRoleNameGetAsync(char * accessToken,
	std::string id, std::string roleName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdRolesRoleNameGetHelper(accessToken,
	id, roleName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersIdRolesRoleNameGetSync(char * accessToken,
	std::string id, std::string roleName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdRolesRoleNameGetHelper(accessToken,
	id, roleName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetHelper(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetAsync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetHelper(accessToken,
	id, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetSync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsGetHelper(accessToken,
	id, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetHelper(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_nameV("{");
	s_nameV.append("name__v");
	s_nameV.append("}");
	pos = url.find(s_nameV);
	url.erase(pos, s_nameV.length());
	url.insert(pos, stringify(&nameV, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetAsync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetHelper(accessToken,
	id, majorVersion, minorVersion, nameV, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetSync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetHelper(accessToken,
	id, majorVersion, minorVersion, nameV, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutHelper(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_nameV("{");
	s_nameV.append("name__v");
	s_nameV.append("}");
	pos = url.find(s_nameV);
	url.erase(pos, s_nameV.length());
	url.insert(pos, stringify(&nameV, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutAsync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutHelper(accessToken,
	id, majorVersion, minorVersion, nameV, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutSync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutHelper(accessToken,
	id, majorVersion, minorVersion, nameV, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersLifecycleActionsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersLifecycleActionsPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/lifecycle_actions");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersLifecycleActionsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersLifecycleActionsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersLifecycleActionsPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersLifecycleActionsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersLifecycleActionsPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersLifecycleActionsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersLifecycleActionsUserActionNamePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersLifecycleActionsUserActionNamePutHelper(char * accessToken,
	std::string userActionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/lifecycle_actions/{user_action_name}");
	int pos;

	string s_userActionName("{");
	s_userActionName.append("user_action_name");
	s_userActionName.append("}");
	pos = url.find(s_userActionName);
	url.erase(pos, s_userActionName.length());
	url.insert(pos, stringify(&userActionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersLifecycleActionsUserActionNamePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersLifecycleActionsUserActionNamePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersLifecycleActionsUserActionNamePutAsync(char * accessToken,
	std::string userActionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersLifecycleActionsUserActionNamePutHelper(accessToken,
	userActionName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersLifecycleActionsUserActionNamePutSync(char * accessToken,
	std::string userActionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersLifecycleActionsUserActionNamePutHelper(accessToken,
	userActionName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersPostHelper(char * accessToken,
	bool async, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&async, "bool");
	queryParams.insert(pair<string, string>("async", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("async");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersPostAsync(char * accessToken,
	bool async, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersPostHelper(accessToken,
	async, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersPostSync(char * accessToken,
	bool async, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersPostHelper(accessToken,
	async, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersTemplatesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersTemplatesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/templates");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersTemplatesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersTemplatesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersTemplatesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersTemplatesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersTemplatesPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersTemplatesPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/templates");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersTemplatesPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersTemplatesPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersTemplatesPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersTemplatesPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersTemplatesPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersTemplatesPutHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/templates");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersTemplatesPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersTemplatesPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersTemplatesPutAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesPutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersTemplatesPutSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesPutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersTemplatesTemplateNameBindernodesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersTemplatesTemplateNameBindernodesGetHelper(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/templates/{template_name}/bindernodes");
	int pos;

	string s_templateName("{");
	s_templateName.append("template_name");
	s_templateName.append("}");
	pos = url.find(s_templateName);
	url.erase(pos, s_templateName.length());
	url.insert(pos, stringify(&templateName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersTemplatesTemplateNameBindernodesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersTemplatesTemplateNameBindernodesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersTemplatesTemplateNameBindernodesGetAsync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameBindernodesGetHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersTemplatesTemplateNameBindernodesGetSync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameBindernodesGetHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersTemplatesTemplateNameBindernodesPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersTemplatesTemplateNameBindernodesPostHelper(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/templates/{template_name}/bindernodes");
	int pos;

	string s_templateName("{");
	s_templateName.append("template_name");
	s_templateName.append("}");
	pos = url.find(s_templateName);
	url.erase(pos, s_templateName.length());
	url.insert(pos, stringify(&templateName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersTemplatesTemplateNameBindernodesPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersTemplatesTemplateNameBindernodesPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersTemplatesTemplateNameBindernodesPostAsync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameBindernodesPostHelper(accessToken,
	templateName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersTemplatesTemplateNameBindernodesPostSync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameBindernodesPostHelper(accessToken,
	templateName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersTemplatesTemplateNameBindernodesPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersTemplatesTemplateNameBindernodesPutHelper(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/templates/{template_name}/bindernodes");
	int pos;

	string s_templateName("{");
	s_templateName.append("template_name");
	s_templateName.append("}");
	pos = url.find(s_templateName);
	url.erase(pos, s_templateName.length());
	url.insert(pos, stringify(&templateName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersTemplatesTemplateNameBindernodesPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersTemplatesTemplateNameBindernodesPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersTemplatesTemplateNameBindernodesPutAsync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameBindernodesPutHelper(accessToken,
	templateName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersTemplatesTemplateNameBindernodesPutSync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameBindernodesPutHelper(accessToken,
	templateName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersTemplatesTemplateNameDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersTemplatesTemplateNameDeleteHelper(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/templates/{template_name}");
	int pos;

	string s_templateName("{");
	s_templateName.append("template_name");
	s_templateName.append("}");
	pos = url.find(s_templateName);
	url.erase(pos, s_templateName.length());
	url.insert(pos, stringify(&templateName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersTemplatesTemplateNameDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersTemplatesTemplateNameDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersTemplatesTemplateNameDeleteAsync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameDeleteHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersTemplatesTemplateNameDeleteSync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameDeleteHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsBindersTemplatesTemplateNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsBindersTemplatesTemplateNameGetHelper(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/binders/templates/{template_name}");
	int pos;

	string s_templateName("{");
	s_templateName.append("template_name");
	s_templateName.append("}");
	pos = url.find(s_templateName);
	url.erase(pos, s_templateName.length());
	url.insert(pos, stringify(&templateName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsBindersTemplatesTemplateNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsBindersTemplatesTemplateNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsBindersTemplatesTemplateNameGetAsync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameGetHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsBindersTemplatesTemplateNameGetSync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsBindersTemplatesTemplateNameGetHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDeletionsDocumentsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDeletionsDocumentsGetHelper(char * accessToken,
	std::string startDate, std::string endDate, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&startDate, "std::string");
	queryParams.insert(pair<string, string>("start_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("start_date");
	}


	itemAtq = stringify(&endDate, "std::string");
	queryParams.insert(pair<string, string>("end_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("end_date");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/deletions/documents");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDeletionsDocumentsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDeletionsDocumentsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDeletionsDocumentsGetAsync(char * accessToken,
	std::string startDate, std::string endDate, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDeletionsDocumentsGetHelper(accessToken,
	startDate, endDate, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDeletionsDocumentsGetSync(char * accessToken,
	std::string startDate, std::string endDate, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDeletionsDocumentsGetHelper(accessToken,
	startDate, endDate, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDeletionsVobjectsObjectNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDeletionsVobjectsObjectNameGetHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/deletions/vobjects/{object_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDeletionsVobjectsObjectNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDeletionsVobjectsObjectNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDeletionsVobjectsObjectNameGetAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDeletionsVobjectsObjectNameGetHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDeletionsVobjectsObjectNameGetSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDeletionsVobjectsObjectNameGetHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsActionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsActionsGetHelper(char * accessToken,
	bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "bool");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/actions");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsActionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsActionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsActionsGetAsync(char * accessToken,
	bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsActionsGetHelper(accessToken,
	loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsActionsGetSync(char * accessToken,
	bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsActionsGetHelper(accessToken,
	loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetHelper(char * accessToken,
	std::string lifecycleAndStateAndAction, std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/actions/{lifecycle_and_state_and_action}/{job_id}/results");
	int pos;

	string s_lifecycleAndStateAndAction("{");
	s_lifecycleAndStateAndAction.append("lifecycle_and_state_and_action");
	s_lifecycleAndStateAndAction.append("}");
	pos = url.find(s_lifecycleAndStateAndAction);
	url.erase(pos, s_lifecycleAndStateAndAction.length());
	url.insert(pos, stringify(&lifecycleAndStateAndAction, "std::string"));
	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetAsync(char * accessToken,
	std::string lifecycleAndStateAndAction, std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetHelper(accessToken,
	lifecycleAndStateAndAction, jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetSync(char * accessToken,
	std::string lifecycleAndStateAndAction, std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsActionsLifecycleAndStateAndActionJobIdResultsGetHelper(accessToken,
	lifecycleAndStateAndAction, jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsActionsWorkflowNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsActionsWorkflowNameGetHelper(char * accessToken,
	std::string workflowName, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "bool");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/actions/{workflow_name}");
	int pos;

	string s_workflowName("{");
	s_workflowName.append("workflow_name");
	s_workflowName.append("}");
	pos = url.find(s_workflowName);
	url.erase(pos, s_workflowName.length());
	url.insert(pos, stringify(&workflowName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsActionsWorkflowNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsActionsWorkflowNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsActionsWorkflowNameGetAsync(char * accessToken,
	std::string workflowName, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsActionsWorkflowNameGetHelper(accessToken,
	workflowName, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsActionsWorkflowNameGetSync(char * accessToken,
	std::string workflowName, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsActionsWorkflowNameGetHelper(accessToken,
	workflowName, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsActionsWorkflowNamePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsActionsWorkflowNamePostHelper(char * accessToken,
	std::string workflowName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/actions/{workflow_name}");
	int pos;

	string s_workflowName("{");
	s_workflowName.append("workflow_name");
	s_workflowName.append("}");
	pos = url.find(s_workflowName);
	url.erase(pos, s_workflowName.length());
	url.insert(pos, stringify(&workflowName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsActionsWorkflowNamePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsActionsWorkflowNamePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsActionsWorkflowNamePostAsync(char * accessToken,
	std::string workflowName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsActionsWorkflowNamePostHelper(accessToken,
	workflowName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsActionsWorkflowNamePostSync(char * accessToken,
	std::string workflowName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsActionsWorkflowNamePostHelper(accessToken,
	workflowName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsAnnotationsBatchDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsAnnotationsBatchDeleteHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/annotations/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsAnnotationsBatchDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsAnnotationsBatchDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsAnnotationsBatchDeleteAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAnnotationsBatchDeleteHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsAnnotationsBatchDeleteSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAnnotationsBatchDeleteHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsAnnotationsBatchPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsAnnotationsBatchPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/annotations/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsAnnotationsBatchPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsAnnotationsBatchPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsAnnotationsBatchPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAnnotationsBatchPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsAnnotationsBatchPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAnnotationsBatchPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsAnnotationsBatchPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsAnnotationsBatchPutHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/annotations/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsAnnotationsBatchPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsAnnotationsBatchPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsAnnotationsBatchPutAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAnnotationsBatchPutHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsAnnotationsBatchPutSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAnnotationsBatchPutHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsAnnotationsRepliesBatchPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsAnnotationsRepliesBatchPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/annotations/replies/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsAnnotationsRepliesBatchPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsAnnotationsRepliesBatchPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsAnnotationsRepliesBatchPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAnnotationsRepliesBatchPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsAnnotationsRepliesBatchPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAnnotationsRepliesBatchPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsAttachmentsBatchDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsAttachmentsBatchDeleteHelper(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/attachments/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsAttachmentsBatchDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsAttachmentsBatchDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsAttachmentsBatchDeleteAsync(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAttachmentsBatchDeleteHelper(accessToken,
	accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsAttachmentsBatchDeleteSync(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAttachmentsBatchDeleteHelper(accessToken,
	accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsAttachmentsBatchPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsAttachmentsBatchPostHelper(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/attachments/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsAttachmentsBatchPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsAttachmentsBatchPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsAttachmentsBatchPostAsync(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAttachmentsBatchPostHelper(accessToken,
	accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsAttachmentsBatchPostSync(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAttachmentsBatchPostHelper(accessToken,
	accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsAttachmentsBatchPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsAttachmentsBatchPutHelper(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/attachments/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsAttachmentsBatchPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsAttachmentsBatchPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsAttachmentsBatchPutAsync(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAttachmentsBatchPutHelper(accessToken,
	accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsAttachmentsBatchPutSync(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsAttachmentsBatchPutHelper(accessToken,
	accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsBatchActionsFileextractJobIdResultsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsBatchActionsFileextractJobIdResultsGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/batch/actions/fileextract/{job_id}/results");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsBatchActionsFileextractJobIdResultsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsBatchActionsFileextractJobIdResultsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsBatchActionsFileextractJobIdResultsGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchActionsFileextractJobIdResultsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsBatchActionsFileextractJobIdResultsGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchActionsFileextractJobIdResultsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsBatchActionsFileextractPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsBatchActionsFileextractPostHelper(char * accessToken,
	bool source, bool renditions, bool allversions, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&source, "bool");
	queryParams.insert(pair<string, string>("source", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("source");
	}


	itemAtq = stringify(&renditions, "bool");
	queryParams.insert(pair<string, string>("renditions", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("renditions");
	}


	itemAtq = stringify(&allversions, "bool");
	queryParams.insert(pair<string, string>("allversions", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("allversions");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/batch/actions/fileextract");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsBatchActionsFileextractPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsBatchActionsFileextractPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsBatchActionsFileextractPostAsync(char * accessToken,
	bool source, bool renditions, bool allversions, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchActionsFileextractPostHelper(accessToken,
	source, renditions, allversions, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsBatchActionsFileextractPostSync(char * accessToken,
	bool source, bool renditions, bool allversions, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchActionsFileextractPostHelper(accessToken,
	source, renditions, allversions, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsBatchActionsReclassifyPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsBatchActionsReclassifyPutHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/batch/actions/reclassify");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsBatchActionsReclassifyPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsBatchActionsReclassifyPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsBatchActionsReclassifyPutAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchActionsReclassifyPutHelper(accessToken,
	authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsBatchActionsReclassifyPutSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchActionsReclassifyPutHelper(accessToken,
	authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsBatchActionsRerenderPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsBatchActionsRerenderPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/batch/actions/rerender");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsBatchActionsRerenderPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsBatchActionsRerenderPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsBatchActionsRerenderPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchActionsRerenderPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsBatchActionsRerenderPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchActionsRerenderPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsBatchDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsBatchDeleteHelper(char * accessToken,
	std::string idParam, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&idParam, "std::string");
	queryParams.insert(pair<string, string>("idParam", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("idParam");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsBatchDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsBatchDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsBatchDeleteAsync(char * accessToken,
	std::string idParam, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchDeleteHelper(accessToken,
	idParam, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsBatchDeleteSync(char * accessToken,
	std::string idParam, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchDeleteHelper(accessToken,
	idParam, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsBatchLockDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsBatchLockDeleteHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/batch/lock");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsBatchLockDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsBatchLockDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsBatchLockDeleteAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchLockDeleteHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsBatchLockDeleteSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchLockDeleteHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsBatchPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsBatchPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsBatchPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsBatchPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsBatchPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsBatchPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsBatchPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsBatchPutHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsBatchPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsBatchPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsBatchPutAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchPutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsBatchPutSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsBatchPutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAnchorsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAnchorsGetHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/anchors");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAnchorsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAnchorsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAnchorsGetAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAnchorsGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAnchorsGetSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAnchorsGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAnnotationsFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAnnotationsFileGetHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/annotations/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAnnotationsFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAnnotationsFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAnnotationsFileGetAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAnnotationsFileGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAnnotationsFileGetSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAnnotationsFileGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAnnotationsFilePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAnnotationsFilePostHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/annotations/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAnnotationsFilePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAnnotationsFilePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAnnotationsFilePostAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAnnotationsFilePostHelper(accessToken,
	docId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAnnotationsFilePostSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAnnotationsFilePostHelper(accessToken,
	docId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdDeleteHelper(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/{attachment_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsAttachmentIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsAttachmentIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdDeleteAsync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdDeleteHelper(accessToken,
	docId, attachmentId, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdDeleteSync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdDeleteHelper(accessToken,
	docId, attachmentId, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdFileGetHelper(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/{attachment_id}/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsAttachmentIdFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsAttachmentIdFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdFileGetAsync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdFileGetHelper(accessToken,
	docId, attachmentId, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdFileGetSync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdFileGetHelper(accessToken,
	docId, attachmentId, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdGetHelper(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/{attachment_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsAttachmentIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsAttachmentIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdGetAsync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdGetHelper(accessToken,
	docId, attachmentId, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdGetSync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdGetHelper(accessToken,
	docId, attachmentId, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdPutHelper(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/{attachment_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsAttachmentIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsAttachmentIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdPutAsync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdPutHelper(accessToken,
	docId, attachmentId, accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdPutSync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdPutHelper(accessToken,
	docId, attachmentId, accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteHelper(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteAsync(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteHelper(accessToken,
	docId, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteSync(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteHelper(accessToken,
	docId, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetHelper(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetAsync(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetHelper(accessToken,
	docId, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetSync(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetHelper(accessToken,
	docId, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetHelper(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetAsync(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetHelper(accessToken,
	docId, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetSync(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionGetHelper(accessToken,
	docId, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostHelper(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, bool restore, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&restore, "bool");
	queryParams.insert(pair<string, string>("restore", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("restore");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/{attachment_id}/versions/{attachment_version}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostAsync(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, bool restore, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostHelper(accessToken,
	docId, attachmentId, attachmentVersion, restore, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostSync(char * accessToken,
	std::string docId, std::string attachmentId, std::string attachmentVersion, bool restore, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsAttachmentVersionPostHelper(accessToken,
	docId, attachmentId, attachmentVersion, restore, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetHelper(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/{attachment_id}/versions");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetAsync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetHelper(accessToken,
	docId, attachmentId, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetSync(char * accessToken,
	std::string docId, std::string attachmentId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsAttachmentIdVersionsGetHelper(accessToken,
	docId, attachmentId, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsFileGetHelper(char * accessToken,
	std::string docId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsFileGetAsync(char * accessToken,
	std::string docId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsFileGetHelper(accessToken,
	docId, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsFileGetSync(char * accessToken,
	std::string docId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsFileGetHelper(accessToken,
	docId, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsGetHelper(char * accessToken,
	std::string docId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsGetAsync(char * accessToken,
	std::string docId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsGetHelper(accessToken,
	docId, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsGetSync(char * accessToken,
	std::string docId, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsGetHelper(accessToken,
	docId, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAttachmentsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAttachmentsPostHelper(char * accessToken,
	std::string docId, std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/attachments");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAttachmentsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAttachmentsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAttachmentsPostAsync(char * accessToken,
	std::string docId, std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsPostHelper(accessToken,
	docId, accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAttachmentsPostSync(char * accessToken,
	std::string docId, std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAttachmentsPostHelper(accessToken,
	docId, accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdAudittrailGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdAudittrailGetHelper(char * accessToken,
	std::string docId, std::string startDate, std::string endDate, std::string formatResult, std::string limit, std::string offset, std::string events, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&startDate, "std::string");
	queryParams.insert(pair<string, string>("start_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("start_date");
	}


	itemAtq = stringify(&endDate, "std::string");
	queryParams.insert(pair<string, string>("end_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("end_date");
	}


	itemAtq = stringify(&formatResult, "std::string");
	queryParams.insert(pair<string, string>("format_result", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("format_result");
	}


	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}


	itemAtq = stringify(&events, "std::string");
	queryParams.insert(pair<string, string>("events", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("events");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/audittrail");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdAudittrailGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdAudittrailGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdAudittrailGetAsync(char * accessToken,
	std::string docId, std::string startDate, std::string endDate, std::string formatResult, std::string limit, std::string offset, std::string events, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAudittrailGetHelper(accessToken,
	docId, startDate, endDate, formatResult, limit, offset, events, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdAudittrailGetSync(char * accessToken,
	std::string docId, std::string startDate, std::string endDate, std::string formatResult, std::string limit, std::string offset, std::string events, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdAudittrailGetHelper(accessToken,
	docId, startDate, endDate, formatResult, limit, offset, events, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdDeleteHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdDeleteAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdDeleteHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdDeleteSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdDeleteHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdEventsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdEventsGetHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/events");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdEventsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdEventsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdEventsGetAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdEventsGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdEventsGetSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdEventsGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdFileGetHelper(char * accessToken,
	std::string docId, bool lockDocument, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&lockDocument, "bool");
	queryParams.insert(pair<string, string>("lockDocument", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("lockDocument");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdFileGetAsync(char * accessToken,
	std::string docId, bool lockDocument, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdFileGetHelper(accessToken,
	docId, lockDocument, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdFileGetSync(char * accessToken,
	std::string docId, bool lockDocument, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdFileGetHelper(accessToken,
	docId, lockDocument, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdGetHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdGetAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdGetSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdLockDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdLockDeleteHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/lock");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdLockDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdLockDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdLockDeleteAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdLockDeleteHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdLockDeleteSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdLockDeleteHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdLockGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdLockGetHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/lock");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdLockGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdLockGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdLockGetAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdLockGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdLockGetSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdLockGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdLockPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdLockPostHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/lock");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdLockPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdLockPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdLockPostAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdLockPostHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdLockPostSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdLockPostHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/{major_version}/{minor_version}/attachments/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetHelper(accessToken,
	docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdMajorVersionMinorVersionAttachmentsFileGetHelper(accessToken,
	docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdPostHelper(char * accessToken,
	std::string docId, std::string suppressRendition, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&suppressRendition, "std::string");
	queryParams.insert(pair<string, string>("suppressRendition", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("suppressRendition");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdPostAsync(char * accessToken,
	std::string docId, std::string suppressRendition, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdPostHelper(accessToken,
	docId, suppressRendition, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdPostSync(char * accessToken,
	std::string docId, std::string suppressRendition, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdPostHelper(accessToken,
	docId, suppressRendition, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdPutHelper(char * accessToken,
	std::string docId, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdPutAsync(char * accessToken,
	std::string docId, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdPutHelper(accessToken,
	docId, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdPutSync(char * accessToken,
	std::string docId, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdPutHelper(accessToken,
	docId, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdRenditionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdRenditionsGetHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/renditions");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdRenditionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdRenditionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdRenditionsGetAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdRenditionsGetSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdRenditionsRenditionTypeDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdRenditionsRenditionTypeDeleteHelper(char * accessToken,
	std::string docId, std::string renditionType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/renditions/{rendition_type}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_renditionType("{");
	s_renditionType.append("rendition_type");
	s_renditionType.append("}");
	pos = url.find(s_renditionType);
	url.erase(pos, s_renditionType.length());
	url.insert(pos, stringify(&renditionType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdRenditionsRenditionTypeDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdRenditionsRenditionTypeDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdRenditionsRenditionTypeDeleteAsync(char * accessToken,
	std::string docId, std::string renditionType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsRenditionTypeDeleteHelper(accessToken,
	docId, renditionType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdRenditionsRenditionTypeDeleteSync(char * accessToken,
	std::string docId, std::string renditionType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsRenditionTypeDeleteHelper(accessToken,
	docId, renditionType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdRenditionsRenditionTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdRenditionsRenditionTypeGetHelper(char * accessToken,
	std::string docId, std::string renditionType, std::string steadyState, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&steadyState, "std::string");
	queryParams.insert(pair<string, string>("steadyState", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("steadyState");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/renditions/{rendition_type}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_renditionType("{");
	s_renditionType.append("rendition_type");
	s_renditionType.append("}");
	pos = url.find(s_renditionType);
	url.erase(pos, s_renditionType.length());
	url.insert(pos, stringify(&renditionType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdRenditionsRenditionTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdRenditionsRenditionTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdRenditionsRenditionTypeGetAsync(char * accessToken,
	std::string docId, std::string renditionType, std::string steadyState, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsRenditionTypeGetHelper(accessToken,
	docId, renditionType, steadyState, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdRenditionsRenditionTypeGetSync(char * accessToken,
	std::string docId, std::string renditionType, std::string steadyState, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsRenditionTypeGetHelper(accessToken,
	docId, renditionType, steadyState, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdRenditionsRenditionTypePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdRenditionsRenditionTypePostHelper(char * accessToken,
	std::string docId, std::string renditionType, std::string authorization, std::string accept, std::string content_Type, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content Type: ");
		headerString.append(stringify(&content_Type, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/renditions/{rendition_type}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_renditionType("{");
	s_renditionType.append("rendition_type");
	s_renditionType.append("}");
	pos = url.find(s_renditionType);
	url.erase(pos, s_renditionType.length());
	url.insert(pos, stringify(&renditionType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdRenditionsRenditionTypePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdRenditionsRenditionTypePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdRenditionsRenditionTypePostAsync(char * accessToken,
	std::string docId, std::string renditionType, std::string authorization, std::string accept, std::string content_Type, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsRenditionTypePostHelper(accessToken,
	docId, renditionType, authorization, accept, content_Type, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdRenditionsRenditionTypePostSync(char * accessToken,
	std::string docId, std::string renditionType, std::string authorization, std::string accept, std::string content_Type, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsRenditionTypePostHelper(accessToken,
	docId, renditionType, authorization, accept, content_Type, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdRenditionsRenditionTypePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdRenditionsRenditionTypePutHelper(char * accessToken,
	std::string docId, std::string renditionType, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/renditions/{rendition_type}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_renditionType("{");
	s_renditionType.append("rendition_type");
	s_renditionType.append("}");
	pos = url.find(s_renditionType);
	url.erase(pos, s_renditionType.length());
	url.insert(pos, stringify(&renditionType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdRenditionsRenditionTypePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdRenditionsRenditionTypePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdRenditionsRenditionTypePutAsync(char * accessToken,
	std::string docId, std::string renditionType, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsRenditionTypePutHelper(accessToken,
	docId, renditionType, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdRenditionsRenditionTypePutSync(char * accessToken,
	std::string docId, std::string renditionType, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRenditionsRenditionTypePutHelper(accessToken,
	docId, renditionType, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteHelper(char * accessToken,
	std::string docId, std::string roleNameAndUserOrGroup, std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/roles/{role_name_and_user_or_group}/{id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_roleNameAndUserOrGroup("{");
	s_roleNameAndUserOrGroup.append("role_name_and_user_or_group");
	s_roleNameAndUserOrGroup.append("}");
	pos = url.find(s_roleNameAndUserOrGroup);
	url.erase(pos, s_roleNameAndUserOrGroup.length());
	url.insert(pos, stringify(&roleNameAndUserOrGroup, "std::string"));
	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteAsync(char * accessToken,
	std::string docId, std::string roleNameAndUserOrGroup, std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteHelper(accessToken,
	docId, roleNameAndUserOrGroup, id, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteSync(char * accessToken,
	std::string docId, std::string roleNameAndUserOrGroup, std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdRolesRoleNameAndUserOrGroupIdDeleteHelper(accessToken,
	docId, roleNameAndUserOrGroup, id, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/version/{major_version}/{minor_version}/attachments");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetHelper(accessToken,
	docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionMajorVersionMinorVersionAttachmentsGetHelper(accessToken,
	docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsGetHelper(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsGetAsync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsGetSync(char * accessToken,
	std::string docId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsGetHelper(accessToken,
	docId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string annotationId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_annotationId("{");
	s_annotationId.append("annotation_id");
	s_annotationId.append("}");
	pos = url.find(s_annotationId);
	url.erase(pos, s_annotationId.length());
	url.insert(pos, stringify(&annotationId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string annotationId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetHelper(accessToken,
	docId, majorVersion, minorVersion, annotationId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string annotationId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdGetHelper(accessToken,
	docId, majorVersion, minorVersion, annotationId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string annotationId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/{annotation_id}/replies");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_annotationId("{");
	s_annotationId.append("annotation_id");
	s_annotationId.append("}");
	pos = url.find(s_annotationId);
	url.erase(pos, s_annotationId.length());
	url.insert(pos, stringify(&annotationId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string annotationId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetHelper(accessToken,
	docId, majorVersion, minorVersion, annotationId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string annotationId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsAnnotationIdRepliesGetHelper(accessToken,
	docId, majorVersion, minorVersion, annotationId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFileGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsFilePostHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string limit, std::string offset, std::string annotationTypes, std::string paginationId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}


	itemAtq = stringify(&annotationTypes, "std::string");
	queryParams.insert(pair<string, string>("annotation_types", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("annotation_types");
	}


	itemAtq = stringify(&paginationId, "std::string");
	queryParams.insert(pair<string, string>("pagination_id", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("pagination_id");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/annotations");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string limit, std::string offset, std::string annotationTypes, std::string paginationId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetHelper(accessToken,
	docId, majorVersion, minorVersion, limit, offset, annotationTypes, paginationId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string limit, std::string offset, std::string annotationTypes, std::string paginationId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAnnotationsGetHelper(accessToken,
	docId, majorVersion, minorVersion, limit, offset, annotationTypes, paginationId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetHelper(accessToken,
	docId, majorVersion, minorVersion, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionFileGetHelper(accessToken,
	docId, majorVersion, minorVersion, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/attachments/{attachment_id}/versions/{attachment_version}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetHelper(accessToken,
	docId, majorVersion, minorVersion, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string attachmentId, std::string attachmentVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionAttachmentsAttachmentIdVersionsAttachmentVersionGetHelper(accessToken,
	docId, majorVersion, minorVersion, attachmentId, attachmentVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionDeleteHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/doc-export-annotations-to-csv");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionDocExportAnnotationsToCsvGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/events");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionEventsPostHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/export-video-annotations");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionExportVideoAnnotationsGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/file");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetHelper(accessToken,
	docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionFileGetHelper(accessToken,
	docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionPutHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsPostHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_relationshipId("{");
	s_relationshipId.append("relationship_id");
	s_relationshipId.append("}");
	pos = url.find(s_relationshipId);
	url.erase(pos, s_relationshipId.length());
	url.insert(pos, stringify(&relationshipId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteHelper(accessToken,
	docId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdDeleteHelper(accessToken,
	docId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/relationships/{relationship_id}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_relationshipId("{");
	s_relationshipId.append("relationship_id");
	s_relationshipId.append("}");
	pos = url.find(s_relationshipId);
	url.erase(pos, s_relationshipId.length());
	url.insert(pos, stringify(&relationshipId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetHelper(accessToken,
	docId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string relationshipId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRelationshipsRelationshipIdGetHelper(accessToken,
	docId, majorVersion, minorVersion, relationshipId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsGetHelper(accessToken,
	docId, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_renditionType("{");
	s_renditionType.append("rendition_type");
	s_renditionType.append("}");
	pos = url.find(s_renditionType);
	url.erase(pos, s_renditionType.length());
	url.insert(pos, stringify(&renditionType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteHelper(accessToken,
	docId, majorVersion, minorVersion, renditionType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeDeleteHelper(accessToken,
	docId, majorVersion, minorVersion, renditionType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_renditionType("{");
	s_renditionType.append("rendition_type");
	s_renditionType.append("}");
	pos = url.find(s_renditionType);
	url.erase(pos, s_renditionType.length());
	url.insert(pos, stringify(&renditionType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetHelper(accessToken,
	docId, majorVersion, minorVersion, renditionType, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypeGetHelper(accessToken,
	docId, majorVersion, minorVersion, renditionType, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_renditionType("{");
	s_renditionType.append("rendition_type");
	s_renditionType.append("}");
	pos = url.find(s_renditionType);
	url.erase(pos, s_renditionType.length());
	url.insert(pos, stringify(&renditionType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostHelper(accessToken,
	docId, majorVersion, minorVersion, renditionType, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePostHelper(accessToken,
	docId, majorVersion, minorVersion, renditionType, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/renditions/{rendition_type}");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_renditionType("{");
	s_renditionType.append("rendition_type");
	s_renditionType.append("}");
	pos = url.find(s_renditionType);
	url.erase(pos, s_renditionType.length());
	url.insert(pos, stringify(&renditionType, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutHelper(accessToken,
	docId, majorVersion, minorVersion, renditionType, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string renditionType, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionRenditionsRenditionTypePutHelper(accessToken,
	docId, majorVersion, minorVersion, renditionType, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetHelper(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{doc_id}/versions/{major_version}/{minor_version}/thumbnail");
	int pos;

	string s_docId("{");
	s_docId.append("doc_id");
	s_docId.append("}");
	pos = url.find(s_docId);
	url.erase(pos, s_docId.length());
	url.insert(pos, stringify(&docId, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetAsync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetHelper(accessToken,
	docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetSync(char * accessToken,
	std::string docId, std::string majorVersion, std::string minorVersion, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsDocIdVersionsMajorVersionMinorVersionThumbnailGetHelper(accessToken,
	docId, majorVersion, minorVersion, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsGetHelper(char * accessToken,
	std::string namedFilter, std::string scope, std::string versionscope, std::string search, std::string limit, std::string sort, std::string start, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&namedFilter, "std::string");
	queryParams.insert(pair<string, string>("named_filter", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("named_filter");
	}


	itemAtq = stringify(&scope, "std::string");
	queryParams.insert(pair<string, string>("scope", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("scope");
	}


	itemAtq = stringify(&versionscope, "std::string");
	queryParams.insert(pair<string, string>("versionscope", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("versionscope");
	}


	itemAtq = stringify(&search, "std::string");
	queryParams.insert(pair<string, string>("search", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("search");
	}


	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&sort, "std::string");
	queryParams.insert(pair<string, string>("sort", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("sort");
	}


	itemAtq = stringify(&start, "std::string");
	queryParams.insert(pair<string, string>("start", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("start");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsGetAsync(char * accessToken,
	std::string namedFilter, std::string scope, std::string versionscope, std::string search, std::string limit, std::string sort, std::string start, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsGetHelper(accessToken,
	namedFilter, scope, versionscope, search, limit, sort, start, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsGetSync(char * accessToken,
	std::string namedFilter, std::string scope, std::string versionscope, std::string search, std::string limit, std::string sort, std::string start, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsGetHelper(accessToken,
	namedFilter, scope, versionscope, search, limit, sort, start, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsIdRolesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsIdRolesGetHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{id}/roles");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsIdRolesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsIdRolesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsIdRolesGetAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdRolesGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsIdRolesGetSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdRolesGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsIdRolesPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsIdRolesPostHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{id}/roles");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsIdRolesPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsIdRolesPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsIdRolesPostAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdRolesPostHelper(accessToken,
	id, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsIdRolesPostSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdRolesPostHelper(accessToken,
	id, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsIdRolesRoleNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsIdRolesRoleNameGetHelper(char * accessToken,
	std::string id, std::string roleName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{id}/roles/{role_name}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));
	string s_roleName("{");
	s_roleName.append("role_name");
	s_roleName.append("}");
	pos = url.find(s_roleName);
	url.erase(pos, s_roleName.length());
	url.insert(pos, stringify(&roleName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsIdRolesRoleNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsIdRolesRoleNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsIdRolesRoleNameGetAsync(char * accessToken,
	std::string id, std::string roleName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdRolesRoleNameGetHelper(accessToken,
	id, roleName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsIdRolesRoleNameGetSync(char * accessToken,
	std::string id, std::string roleName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdRolesRoleNameGetHelper(accessToken,
	id, roleName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetHelper(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetAsync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetHelper(accessToken,
	id, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetSync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsGetHelper(accessToken,
	id, majorVersion, minorVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetHelper(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}/entry_requirements");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_nameV("{");
	s_nameV.append("name__v");
	s_nameV.append("}");
	pos = url.find(s_nameV);
	url.erase(pos, s_nameV.length());
	url.insert(pos, stringify(&nameV, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetAsync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetHelper(accessToken,
	id, majorVersion, minorVersion, nameV, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetSync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVEntryRequirementsGetHelper(accessToken,
	id, majorVersion, minorVersion, nameV, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutHelper(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/{id}/versions/{major_version}/{minor_version}/lifecycle_actions/{name__v}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));
	string s_majorVersion("{");
	s_majorVersion.append("major_version");
	s_majorVersion.append("}");
	pos = url.find(s_majorVersion);
	url.erase(pos, s_majorVersion.length());
	url.insert(pos, stringify(&majorVersion, "std::string"));
	string s_minorVersion("{");
	s_minorVersion.append("minor_version");
	s_minorVersion.append("}");
	pos = url.find(s_minorVersion);
	url.erase(pos, s_minorVersion.length());
	url.insert(pos, stringify(&minorVersion, "std::string"));
	string s_nameV("{");
	s_nameV.append("name__v");
	s_nameV.append("}");
	pos = url.find(s_nameV);
	url.erase(pos, s_nameV.length());
	url.insert(pos, stringify(&nameV, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutAsync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutHelper(accessToken,
	id, majorVersion, minorVersion, nameV, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutSync(char * accessToken,
	std::string id, std::string majorVersion, std::string minorVersion, std::string nameV, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsIdVersionsMajorVersionMinorVersionLifecycleActionsNameVPutHelper(accessToken,
	id, majorVersion, minorVersion, nameV, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsLifecycleActionsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsLifecycleActionsPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/lifecycle_actions");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsLifecycleActionsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsLifecycleActionsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsLifecycleActionsPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsLifecycleActionsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsLifecycleActionsPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsLifecycleActionsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsLifecycleActionsUserActionNamePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsLifecycleActionsUserActionNamePutHelper(char * accessToken,
	std::string userActionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/lifecycle_actions/{user_action_name}");
	int pos;

	string s_userActionName("{");
	s_userActionName.append("user_action_name");
	s_userActionName.append("}");
	pos = url.find(s_userActionName);
	url.erase(pos, s_userActionName.length());
	url.insert(pos, stringify(&userActionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsLifecycleActionsUserActionNamePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsLifecycleActionsUserActionNamePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsLifecycleActionsUserActionNamePutAsync(char * accessToken,
	std::string userActionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsLifecycleActionsUserActionNamePutHelper(accessToken,
	userActionName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsLifecycleActionsUserActionNamePutSync(char * accessToken,
	std::string userActionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsLifecycleActionsUserActionNamePutHelper(accessToken,
	userActionName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsPostHelper(char * accessToken,
	std::string authorization, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsPostAsync(char * accessToken,
	std::string authorization, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsPostHelper(accessToken,
	authorization, accept, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsPostSync(char * accessToken,
	std::string authorization, std::string accept, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsPostHelper(accessToken,
	authorization, accept, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsRelationshipsBatchDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsRelationshipsBatchDeleteHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/relationships/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsRelationshipsBatchDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsRelationshipsBatchDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsRelationshipsBatchDeleteAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRelationshipsBatchDeleteHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsRelationshipsBatchDeleteSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRelationshipsBatchDeleteHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsRelationshipsBatchPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsRelationshipsBatchPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/relationships/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsRelationshipsBatchPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsRelationshipsBatchPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsRelationshipsBatchPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRelationshipsBatchPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsRelationshipsBatchPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRelationshipsBatchPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsRenditionsBatchDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsRenditionsBatchDeleteHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/renditions/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsRenditionsBatchDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsRenditionsBatchDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsRenditionsBatchDeleteAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRenditionsBatchDeleteHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsRenditionsBatchDeleteSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRenditionsBatchDeleteHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsRenditionsBatchPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsRenditionsBatchPostHelper(char * accessToken,
	std::string idParam, std::string largeSizeAsset, std::string authorization, std::string accept, std::string contentType, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&idParam, "std::string");
	queryParams.insert(pair<string, string>("idParam", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("idParam");
	}


	itemAtq = stringify(&largeSizeAsset, "std::string");
	queryParams.insert(pair<string, string>("largeSizeAsset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("largeSizeAsset");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/renditions/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsRenditionsBatchPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsRenditionsBatchPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsRenditionsBatchPostAsync(char * accessToken,
	std::string idParam, std::string largeSizeAsset, std::string authorization, std::string accept, std::string contentType, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRenditionsBatchPostHelper(accessToken,
	idParam, largeSizeAsset, authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsRenditionsBatchPostSync(char * accessToken,
	std::string idParam, std::string largeSizeAsset, std::string authorization, std::string accept, std::string contentType, bool xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRenditionsBatchPostHelper(accessToken,
	idParam, largeSizeAsset, authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsRolesBatchDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsRolesBatchDeleteHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/roles/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsRolesBatchDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsRolesBatchDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsRolesBatchDeleteAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRolesBatchDeleteHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsRolesBatchDeleteSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRolesBatchDeleteHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsRolesBatchPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsRolesBatchPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/roles/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsRolesBatchPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsRolesBatchPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsRolesBatchPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRolesBatchPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsRolesBatchPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsRolesBatchPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsTemplatesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsTemplatesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/templates");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsTemplatesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsTemplatesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsTemplatesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsTemplatesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsTemplatesPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsTemplatesPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/templates");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsTemplatesPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsTemplatesPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsTemplatesPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsTemplatesPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsTemplatesPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsTemplatesPutHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/templates");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsTemplatesPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsTemplatesPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsTemplatesPutAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesPutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsTemplatesPutSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesPutHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsTemplatesTemplateNameDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsTemplatesTemplateNameDeleteHelper(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/templates/{template_name}");
	int pos;

	string s_templateName("{");
	s_templateName.append("template_name");
	s_templateName.append("}");
	pos = url.find(s_templateName);
	url.erase(pos, s_templateName.length());
	url.insert(pos, stringify(&templateName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsTemplatesTemplateNameDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsTemplatesTemplateNameDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsTemplatesTemplateNameDeleteAsync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesTemplateNameDeleteHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsTemplatesTemplateNameDeleteSync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesTemplateNameDeleteHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsTemplatesTemplateNameFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsTemplatesTemplateNameFileGetHelper(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/templates/{template_name}/file");
	int pos;

	string s_templateName("{");
	s_templateName.append("template_name");
	s_templateName.append("}");
	pos = url.find(s_templateName);
	url.erase(pos, s_templateName.length());
	url.insert(pos, stringify(&templateName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsTemplatesTemplateNameFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsTemplatesTemplateNameFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsTemplatesTemplateNameFileGetAsync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesTemplateNameFileGetHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsTemplatesTemplateNameFileGetSync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesTemplateNameFileGetHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsTemplatesTemplateNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsTemplatesTemplateNameGetHelper(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/templates/{template_name}");
	int pos;

	string s_templateName("{");
	s_templateName.append("template_name");
	s_templateName.append("}");
	pos = url.find(s_templateName);
	url.erase(pos, s_templateName.length());
	url.insert(pos, stringify(&templateName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsTemplatesTemplateNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsTemplatesTemplateNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsTemplatesTemplateNameGetAsync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesTemplateNameGetHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsTemplatesTemplateNameGetSync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesTemplateNameGetHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsTemplatesTemplateNamePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsTemplatesTemplateNamePutHelper(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/templates/{template_name}");
	int pos;

	string s_templateName("{");
	s_templateName.append("template_name");
	s_templateName.append("}");
	pos = url.find(s_templateName);
	url.erase(pos, s_templateName.length());
	url.insert(pos, stringify(&templateName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsTemplatesTemplateNamePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsTemplatesTemplateNamePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsTemplatesTemplateNamePutAsync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesTemplateNamePutHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsTemplatesTemplateNamePutSync(char * accessToken,
	std::string templateName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTemplatesTemplateNamePutHelper(accessToken,
	templateName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsTokensPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsTokensPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/tokens");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsTokensPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsTokensPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsTokensPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTokensPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsTokensPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsTokensPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsVersionsBatchActionsFileextractPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsVersionsBatchActionsFileextractPostHelper(char * accessToken,
	bool source, bool renditions, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&source, "bool");
	queryParams.insert(pair<string, string>("source", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("source");
	}


	itemAtq = stringify(&renditions, "bool");
	queryParams.insert(pair<string, string>("renditions", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("renditions");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/versions/batch/actions/fileextract");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsVersionsBatchActionsFileextractPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsVersionsBatchActionsFileextractPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsVersionsBatchActionsFileextractPostAsync(char * accessToken,
	bool source, bool renditions, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsVersionsBatchActionsFileextractPostHelper(accessToken,
	source, renditions, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsVersionsBatchActionsFileextractPostSync(char * accessToken,
	bool source, bool renditions, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsVersionsBatchActionsFileextractPostHelper(accessToken,
	source, renditions, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsVersionsBatchDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsVersionsBatchDeleteHelper(char * accessToken,
	std::string idParam, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&idParam, "std::string");
	queryParams.insert(pair<string, string>("idParam", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("idParam");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/versions/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsVersionsBatchDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsVersionsBatchDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsVersionsBatchDeleteAsync(char * accessToken,
	std::string idParam, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsVersionsBatchDeleteHelper(accessToken,
	idParam, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsVersionsBatchDeleteSync(char * accessToken,
	std::string idParam, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsVersionsBatchDeleteHelper(accessToken,
	idParam, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDocumentsVersionsBatchPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDocumentsVersionsBatchPostHelper(char * accessToken,
	std::string idParam, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&idParam, "std::string");
	queryParams.insert(pair<string, string>("idParam", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("idParam");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/documents/versions/batch");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDocumentsVersionsBatchPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDocumentsVersionsBatchPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDocumentsVersionsBatchPostAsync(char * accessToken,
	std::string idParam, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsVersionsBatchPostHelper(accessToken,
	idParam, authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDocumentsVersionsBatchPostSync(char * accessToken,
	std::string idParam, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIMigrationMode, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDocumentsVersionsBatchPostHelper(accessToken,
	idParam, authorization, accept, contentType, xVaultAPIMigrationMode, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDomainGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDomainGetHelper(char * accessToken,
	bool includeApplication, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&includeApplication, "bool");
	queryParams.insert(pair<string, string>("include_application", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("include_application");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/domain");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDomainGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDomainGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDomainGetAsync(char * accessToken,
	bool includeApplication, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDomainGetHelper(accessToken,
	includeApplication, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDomainGetSync(char * accessToken,
	bool includeApplication, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDomainGetHelper(accessToken,
	includeApplication, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsDomainsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsDomainsGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/domains");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsDomainsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsDomainsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsDomainsGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDomainsGetHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsDomainsGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsDomainsGetHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsEdlMatchedDocumentsBatchActionsAddPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsEdlMatchedDocumentsBatchActionsAddPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/edl_matched_documents/batch/actions/add");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsEdlMatchedDocumentsBatchActionsAddPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsEdlMatchedDocumentsBatchActionsAddPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsEdlMatchedDocumentsBatchActionsAddPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsEdlMatchedDocumentsBatchActionsAddPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsEdlMatchedDocumentsBatchActionsAddPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsEdlMatchedDocumentsBatchActionsAddPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsEdlMatchedDocumentsBatchActionsRemovePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsEdlMatchedDocumentsBatchActionsRemovePostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/edl_matched_documents/batch/actions/remove");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsEdlMatchedDocumentsBatchActionsRemovePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsEdlMatchedDocumentsBatchActionsRemovePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsEdlMatchedDocumentsBatchActionsRemovePostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsEdlMatchedDocumentsBatchActionsRemovePostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsEdlMatchedDocumentsBatchActionsRemovePostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsEdlMatchedDocumentsBatchActionsRemovePostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsGroupsAutoGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsGroupsAutoGetHelper(char * accessToken,
	std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/groups/auto");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsGroupsAutoGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsGroupsAutoGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsGroupsAutoGetAsync(char * accessToken,
	std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsAutoGetHelper(accessToken,
	limit, offset, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsGroupsAutoGetSync(char * accessToken,
	std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsAutoGetHelper(accessToken,
	limit, offset, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsGroupsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsGroupsGetHelper(char * accessToken,
	std::string includeImplied, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&includeImplied, "std::string");
	queryParams.insert(pair<string, string>("includeImplied", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("includeImplied");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/groups");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsGroupsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsGroupsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsGroupsGetAsync(char * accessToken,
	std::string includeImplied, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsGetHelper(accessToken,
	includeImplied, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsGroupsGetSync(char * accessToken,
	std::string includeImplied, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsGetHelper(accessToken,
	includeImplied, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsGroupsGroupIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsGroupsGroupIdDeleteHelper(char * accessToken,
	std::string groupId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/groups/{group_id}");
	int pos;

	string s_groupId("{");
	s_groupId.append("group_id");
	s_groupId.append("}");
	pos = url.find(s_groupId);
	url.erase(pos, s_groupId.length());
	url.insert(pos, stringify(&groupId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsGroupsGroupIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsGroupsGroupIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsGroupsGroupIdDeleteAsync(char * accessToken,
	std::string groupId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsGroupIdDeleteHelper(accessToken,
	groupId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsGroupsGroupIdDeleteSync(char * accessToken,
	std::string groupId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsGroupIdDeleteHelper(accessToken,
	groupId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsGroupsGroupIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsGroupsGroupIdGetHelper(char * accessToken,
	std::string groupId, bool includeImplied, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&includeImplied, "bool");
	queryParams.insert(pair<string, string>("includeImplied", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("includeImplied");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/groups/{group_id}");
	int pos;

	string s_groupId("{");
	s_groupId.append("group_id");
	s_groupId.append("}");
	pos = url.find(s_groupId);
	url.erase(pos, s_groupId.length());
	url.insert(pos, stringify(&groupId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsGroupsGroupIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsGroupsGroupIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsGroupsGroupIdGetAsync(char * accessToken,
	std::string groupId, bool includeImplied, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsGroupIdGetHelper(accessToken,
	groupId, includeImplied, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsGroupsGroupIdGetSync(char * accessToken,
	std::string groupId, bool includeImplied, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsGroupIdGetHelper(accessToken,
	groupId, includeImplied, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsGroupsGroupIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsGroupsGroupIdPutHelper(char * accessToken,
	std::string groupId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/groups/{group_id}");
	int pos;

	string s_groupId("{");
	s_groupId.append("group_id");
	s_groupId.append("}");
	pos = url.find(s_groupId);
	url.erase(pos, s_groupId.length());
	url.insert(pos, stringify(&groupId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsGroupsGroupIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsGroupsGroupIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsGroupsGroupIdPutAsync(char * accessToken,
	std::string groupId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsGroupIdPutHelper(accessToken,
	groupId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsGroupsGroupIdPutSync(char * accessToken,
	std::string groupId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsGroupIdPutHelper(accessToken,
	groupId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsGroupsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsGroupsPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/groups");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsGroupsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsGroupsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsGroupsPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsGroupsPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsGroupsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsLicensesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsLicensesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/licenses");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsLicensesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsLicensesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsLicensesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsLicensesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsLicensesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsLicensesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsActionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsActionsGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/actions");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsActionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsActionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsActionsGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsActionsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsActionsGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsActionsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsActionsWorkflowNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsActionsWorkflowNameGetHelper(char * accessToken,
	std::string workflowName, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/actions/{workflow_name}");
	int pos;

	string s_workflowName("{");
	s_workflowName.append("workflow_name");
	s_workflowName.append("}");
	pos = url.find(s_workflowName);
	url.erase(pos, s_workflowName.length());
	url.insert(pos, stringify(&workflowName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsActionsWorkflowNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsActionsWorkflowNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsActionsWorkflowNameGetAsync(char * accessToken,
	std::string workflowName, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsActionsWorkflowNameGetHelper(accessToken,
	workflowName, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsActionsWorkflowNameGetSync(char * accessToken,
	std::string workflowName, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsActionsWorkflowNameGetHelper(accessToken,
	workflowName, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsActionsWorkflowNamePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsActionsWorkflowNamePostHelper(char * accessToken,
	std::string workflowName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/actions/{workflow_name}");
	int pos;

	string s_workflowName("{");
	s_workflowName.append("workflow_name");
	s_workflowName.append("}");
	pos = url.find(s_workflowName);
	url.erase(pos, s_workflowName.length());
	url.insert(pos, stringify(&workflowName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsActionsWorkflowNamePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsActionsWorkflowNamePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsActionsWorkflowNamePostAsync(char * accessToken,
	std::string workflowName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsActionsWorkflowNamePostHelper(accessToken,
	workflowName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsActionsWorkflowNamePostSync(char * accessToken,
	std::string workflowName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsActionsWorkflowNamePostHelper(accessToken,
	workflowName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsGetHelper(char * accessToken,
	std::string objectV, std::string recordIdV, std::string participant, std::string statusV, std::string offset, std::string pageSize, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&objectV, "std::string");
	queryParams.insert(pair<string, string>("object__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("object__v");
	}


	itemAtq = stringify(&recordIdV, "std::string");
	queryParams.insert(pair<string, string>("record_id__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("record_id__v");
	}


	itemAtq = stringify(&participant, "std::string");
	queryParams.insert(pair<string, string>("participant", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("participant");
	}


	itemAtq = stringify(&statusV, "std::string");
	queryParams.insert(pair<string, string>("status__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("status__v");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}


	itemAtq = stringify(&pageSize, "std::string");
	queryParams.insert(pair<string, string>("page_size", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("page_size");
	}


	itemAtq = stringify(&loc, "std::string");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsGetAsync(char * accessToken,
	std::string objectV, std::string recordIdV, std::string participant, std::string statusV, std::string offset, std::string pageSize, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsGetHelper(accessToken,
	objectV, recordIdV, participant, statusV, offset, pageSize, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsGetSync(char * accessToken,
	std::string objectV, std::string recordIdV, std::string participant, std::string statusV, std::string offset, std::string pageSize, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsGetHelper(accessToken,
	objectV, recordIdV, participant, statusV, offset, pageSize, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksGetHelper(char * accessToken,
	std::string objectV, std::string recordIdV, std::string assigneeV, std::string statusV, std::string offset, std::string pageSize, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&objectV, "std::string");
	queryParams.insert(pair<string, string>("object__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("object__v");
	}


	itemAtq = stringify(&recordIdV, "std::string");
	queryParams.insert(pair<string, string>("record_id__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("record_id__v");
	}


	itemAtq = stringify(&assigneeV, "std::string");
	queryParams.insert(pair<string, string>("assignee__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("assignee__v");
	}


	itemAtq = stringify(&statusV, "std::string");
	queryParams.insert(pair<string, string>("status__v", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("status__v");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}


	itemAtq = stringify(&pageSize, "std::string");
	queryParams.insert(pair<string, string>("page_size", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("page_size");
	}


	itemAtq = stringify(&loc, "std::string");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksGetAsync(char * accessToken,
	std::string objectV, std::string recordIdV, std::string assigneeV, std::string statusV, std::string offset, std::string pageSize, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksGetHelper(accessToken,
	objectV, recordIdV, assigneeV, statusV, offset, pageSize, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksGetSync(char * accessToken,
	std::string objectV, std::string recordIdV, std::string assigneeV, std::string statusV, std::string offset, std::string pageSize, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksGetHelper(accessToken,
	objectV, recordIdV, assigneeV, statusV, offset, pageSize, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsAcceptPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsAcceptPostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/accept");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsAcceptPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsAcceptPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsAcceptPostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsAcceptPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsAcceptPostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsAcceptPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsCancelPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsCancelPostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/cancel");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsCancelPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsCancelPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsCancelPostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsCancelPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsCancelPostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsCancelPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsCompletePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsCompletePostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/complete");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsCompletePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsCompletePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsCompletePostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsCompletePostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsCompletePostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsCompletePostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsGetHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsGetAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsGetHelper(accessToken,
	taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsGetSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsGetHelper(accessToken,
	taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/mdwaccept");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsMdwacceptPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/mdwcomplete");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsMdwcompletePostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/mdwmanagecontent");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsMdwmanagecontentPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/mdwreassign");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsMdwreassignPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsReassignPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsReassignPostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/reassign");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsReassignPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsReassignPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsReassignPostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsReassignPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsReassignPostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsReassignPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsTaskActionGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsTaskActionGetHelper(char * accessToken,
	std::string taskId, std::string taskAction, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "std::string");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/{task_action}");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));
	string s_taskAction("{");
	s_taskAction.append("task_action");
	s_taskAction.append("}");
	pos = url.find(s_taskAction);
	url.erase(pos, s_taskAction.length());
	url.insert(pos, stringify(&taskAction, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsTaskActionGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsTaskActionGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsTaskActionGetAsync(char * accessToken,
	std::string taskId, std::string taskAction, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsTaskActionGetHelper(accessToken,
	taskId, taskAction, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsTaskActionGetSync(char * accessToken,
	std::string taskId, std::string taskAction, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsTaskActionGetHelper(accessToken,
	taskId, taskAction, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/undoaccept");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsUndoacceptPostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostHelper(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}/actions/updateduedate");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostAsync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostSync(char * accessToken,
	std::string taskId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdActionsUpdateduedatePostHelper(accessToken,
	taskId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsTasksTaskIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsTasksTaskIdGetHelper(char * accessToken,
	std::string taskId, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "bool");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/tasks/{task_id}");
	int pos;

	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsTasksTaskIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsTasksTaskIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsTasksTaskIdGetAsync(char * accessToken,
	std::string taskId, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdGetHelper(accessToken,
	taskId, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsTasksTaskIdGetSync(char * accessToken,
	std::string taskId, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsTasksTaskIdGetHelper(accessToken,
	taskId, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsWorkflowIdActionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsWorkflowIdActionsGetHelper(char * accessToken,
	std::string workflowId, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "std::string");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/{workflow_id}/actions");
	int pos;

	string s_workflowId("{");
	s_workflowId.append("workflow_id");
	s_workflowId.append("}");
	pos = url.find(s_workflowId);
	url.erase(pos, s_workflowId.length());
	url.insert(pos, stringify(&workflowId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsWorkflowIdActionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsWorkflowIdActionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsWorkflowIdActionsGetAsync(char * accessToken,
	std::string workflowId, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsWorkflowIdActionsGetHelper(accessToken,
	workflowId, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsWorkflowIdActionsGetSync(char * accessToken,
	std::string workflowId, std::string loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsWorkflowIdActionsGetHelper(accessToken,
	workflowId, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetHelper(char * accessToken,
	std::string workflowId, std::string workflowAction, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/{workflow_id}/actions/{workflow_action}");
	int pos;

	string s_workflowId("{");
	s_workflowId.append("workflow_id");
	s_workflowId.append("}");
	pos = url.find(s_workflowId);
	url.erase(pos, s_workflowId.length());
	url.insert(pos, stringify(&workflowId, "std::string"));
	string s_workflowAction("{");
	s_workflowAction.append("workflow_action");
	s_workflowAction.append("}");
	pos = url.find(s_workflowAction);
	url.erase(pos, s_workflowAction.length());
	url.insert(pos, stringify(&workflowAction, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetAsync(char * accessToken,
	std::string workflowId, std::string workflowAction, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetHelper(accessToken,
	workflowId, workflowAction, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetSync(char * accessToken,
	std::string workflowId, std::string workflowAction, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsWorkflowIdActionsWorkflowActionGetHelper(accessToken,
	workflowId, workflowAction, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostHelper(char * accessToken,
	std::string workflowId, std::string workflowAction, std::string documentsSys, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&documentsSys, "std::string");
	queryParams.insert(pair<string, string>("documents__sys", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("documents__sys");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/{workflow_id}/actions/{workflow_action}");
	int pos;

	string s_workflowId("{");
	s_workflowId.append("workflow_id");
	s_workflowId.append("}");
	pos = url.find(s_workflowId);
	url.erase(pos, s_workflowId.length());
	url.insert(pos, stringify(&workflowId, "std::string"));
	string s_workflowAction("{");
	s_workflowAction.append("workflow_action");
	s_workflowAction.append("}");
	pos = url.find(s_workflowAction);
	url.erase(pos, s_workflowAction.length());
	url.insert(pos, stringify(&workflowAction, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostAsync(char * accessToken,
	std::string workflowId, std::string workflowAction, std::string documentsSys, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostHelper(accessToken,
	workflowId, workflowAction, documentsSys, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostSync(char * accessToken,
	std::string workflowId, std::string workflowAction, std::string documentsSys, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsWorkflowIdActionsWorkflowActionPostHelper(accessToken,
	workflowId, workflowAction, documentsSys, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsObjectworkflowsWorkflowIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsObjectworkflowsWorkflowIdGetHelper(char * accessToken,
	std::string workflowId, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "bool");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/objectworkflows/{workflow_id}");
	int pos;

	string s_workflowId("{");
	s_workflowId.append("workflow_id");
	s_workflowId.append("}");
	pos = url.find(s_workflowId);
	url.erase(pos, s_workflowId.length());
	url.insert(pos, stringify(&workflowId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsObjectworkflowsWorkflowIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsObjectworkflowsWorkflowIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsObjectworkflowsWorkflowIdGetAsync(char * accessToken,
	std::string workflowId, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsWorkflowIdGetHelper(accessToken,
	workflowId, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsObjectworkflowsWorkflowIdGetSync(char * accessToken,
	std::string workflowId, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsObjectworkflowsWorkflowIdGetHelper(accessToken,
	workflowId, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsPicklistsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsPicklistsGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/picklists");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsPicklistsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsPicklistsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsPicklistsGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsPicklistsGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsPicklistsPicklistNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsPicklistsPicklistNameGetHelper(char * accessToken,
	std::string picklistName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/picklists/{picklist_name}");
	int pos;

	string s_picklistName("{");
	s_picklistName.append("picklist_name");
	s_picklistName.append("}");
	pos = url.find(s_picklistName);
	url.erase(pos, s_picklistName.length());
	url.insert(pos, stringify(&picklistName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsPicklistsPicklistNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsPicklistsPicklistNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsPicklistsPicklistNameGetAsync(char * accessToken,
	std::string picklistName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNameGetHelper(accessToken,
	picklistName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsPicklistsPicklistNameGetSync(char * accessToken,
	std::string picklistName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNameGetHelper(accessToken,
	picklistName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsPicklistsPicklistNamePicklistValueNameDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsPicklistsPicklistNamePicklistValueNameDeleteHelper(char * accessToken,
	std::string picklistName, std::string picklistValueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/picklists/{picklist_name}/{picklist_value_name}");
	int pos;

	string s_picklistName("{");
	s_picklistName.append("picklist_name");
	s_picklistName.append("}");
	pos = url.find(s_picklistName);
	url.erase(pos, s_picklistName.length());
	url.insert(pos, stringify(&picklistName, "std::string"));
	string s_picklistValueName("{");
	s_picklistValueName.append("picklist_value_name");
	s_picklistValueName.append("}");
	pos = url.find(s_picklistValueName);
	url.erase(pos, s_picklistValueName.length());
	url.insert(pos, stringify(&picklistValueName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsPicklistsPicklistNamePicklistValueNameDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsPicklistsPicklistNamePicklistValueNameDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsPicklistsPicklistNamePicklistValueNameDeleteAsync(char * accessToken,
	std::string picklistName, std::string picklistValueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNamePicklistValueNameDeleteHelper(accessToken,
	picklistName, picklistValueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsPicklistsPicklistNamePicklistValueNameDeleteSync(char * accessToken,
	std::string picklistName, std::string picklistValueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNamePicklistValueNameDeleteHelper(accessToken,
	picklistName, picklistValueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsPicklistsPicklistNamePicklistValueNamePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsPicklistsPicklistNamePicklistValueNamePutHelper(char * accessToken,
	std::string picklistName, std::string picklistValueName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/picklists/{picklist_name}/{picklist_value_name}");
	int pos;

	string s_picklistName("{");
	s_picklistName.append("picklist_name");
	s_picklistName.append("}");
	pos = url.find(s_picklistName);
	url.erase(pos, s_picklistName.length());
	url.insert(pos, stringify(&picklistName, "std::string"));
	string s_picklistValueName("{");
	s_picklistValueName.append("picklist_value_name");
	s_picklistValueName.append("}");
	pos = url.find(s_picklistValueName);
	url.erase(pos, s_picklistValueName.length());
	url.insert(pos, stringify(&picklistValueName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsPicklistsPicklistNamePicklistValueNamePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsPicklistsPicklistNamePicklistValueNamePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsPicklistsPicklistNamePicklistValueNamePutAsync(char * accessToken,
	std::string picklistName, std::string picklistValueName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNamePicklistValueNamePutHelper(accessToken,
	picklistName, picklistValueName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsPicklistsPicklistNamePicklistValueNamePutSync(char * accessToken,
	std::string picklistName, std::string picklistValueName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNamePicklistValueNamePutHelper(accessToken,
	picklistName, picklistValueName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsPicklistsPicklistNamePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsPicklistsPicklistNamePostHelper(char * accessToken,
	std::string picklistName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/picklists/{picklist_name}");
	int pos;

	string s_picklistName("{");
	s_picklistName.append("picklist_name");
	s_picklistName.append("}");
	pos = url.find(s_picklistName);
	url.erase(pos, s_picklistName.length());
	url.insert(pos, stringify(&picklistName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsPicklistsPicklistNamePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsPicklistsPicklistNamePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsPicklistsPicklistNamePostAsync(char * accessToken,
	std::string picklistName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNamePostHelper(accessToken,
	picklistName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsPicklistsPicklistNamePostSync(char * accessToken,
	std::string picklistName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNamePostHelper(accessToken,
	picklistName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsPicklistsPicklistNamePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsPicklistsPicklistNamePutHelper(char * accessToken,
	std::string picklistName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/picklists/{picklist_name}");
	int pos;

	string s_picklistName("{");
	s_picklistName.append("picklist_name");
	s_picklistName.append("}");
	pos = url.find(s_picklistName);
	url.erase(pos, s_picklistName.length());
	url.insert(pos, stringify(&picklistName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsPicklistsPicklistNamePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsPicklistsPicklistNamePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsPicklistsPicklistNamePutAsync(char * accessToken,
	std::string picklistName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNamePutHelper(accessToken,
	picklistName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsPicklistsPicklistNamePutSync(char * accessToken,
	std::string picklistName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsPicklistsPicklistNamePutHelper(accessToken,
	picklistName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxActionsBuildproductionPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxActionsBuildproductionPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/actions/buildproduction");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxActionsBuildproductionPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxActionsBuildproductionPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxActionsBuildproductionPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxActionsBuildproductionPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxActionsBuildproductionPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxActionsBuildproductionPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxActionsPromoteproductionPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxActionsPromoteproductionPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/actions/promoteproduction");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxActionsPromoteproductionPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxActionsPromoteproductionPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxActionsPromoteproductionPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxActionsPromoteproductionPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxActionsPromoteproductionPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxActionsPromoteproductionPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxActionsRecheckusagePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxActionsRecheckusagePostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/actions/recheckusage");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxActionsRecheckusagePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxActionsRecheckusagePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxActionsRecheckusagePostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxActionsRecheckusagePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxActionsRecheckusagePostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxActionsRecheckusagePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxBatchChangesizePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxBatchChangesizePostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/batch/changesize");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxBatchChangesizePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxBatchChangesizePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxBatchChangesizePostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxBatchChangesizePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxBatchChangesizePostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxBatchChangesizePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxEntitlementsSetPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxEntitlementsSetPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/entitlements/set");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxEntitlementsSetPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxEntitlementsSetPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxEntitlementsSetPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxEntitlementsSetPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxEntitlementsSetPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxEntitlementsSetPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxNameDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxNameDeleteHelper(char * accessToken,
	std::string name, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/{name}");
	int pos;

	string s_name("{");
	s_name.append("name");
	s_name.append("}");
	pos = url.find(s_name);
	url.erase(pos, s_name.length());
	url.insert(pos, stringify(&name, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxNameDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxNameDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxNameDeleteAsync(char * accessToken,
	std::string name, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxNameDeleteHelper(accessToken,
	name, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxNameDeleteSync(char * accessToken,
	std::string name, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxNameDeleteHelper(accessToken,
	name, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxSnapshotApiNameActionsUpdatePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxSnapshotApiNameActionsUpdatePostHelper(char * accessToken,
	std::string apiName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/snapshot/{api_name}/actions/update");
	int pos;

	string s_apiName("{");
	s_apiName.append("api_name");
	s_apiName.append("}");
	pos = url.find(s_apiName);
	url.erase(pos, s_apiName.length());
	url.insert(pos, stringify(&apiName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxSnapshotApiNameActionsUpdatePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxSnapshotApiNameActionsUpdatePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxSnapshotApiNameActionsUpdatePostAsync(char * accessToken,
	std::string apiName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotApiNameActionsUpdatePostHelper(accessToken,
	apiName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxSnapshotApiNameActionsUpdatePostSync(char * accessToken,
	std::string apiName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotApiNameActionsUpdatePostHelper(accessToken,
	apiName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxSnapshotApiNameActionsUpgradePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxSnapshotApiNameActionsUpgradePostHelper(char * accessToken,
	std::string apiName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/snapshot/{api_name}/actions/upgrade");
	int pos;

	string s_apiName("{");
	s_apiName.append("api_name");
	s_apiName.append("}");
	pos = url.find(s_apiName);
	url.erase(pos, s_apiName.length());
	url.insert(pos, stringify(&apiName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxSnapshotApiNameActionsUpgradePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxSnapshotApiNameActionsUpgradePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxSnapshotApiNameActionsUpgradePostAsync(char * accessToken,
	std::string apiName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotApiNameActionsUpgradePostHelper(accessToken,
	apiName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxSnapshotApiNameActionsUpgradePostSync(char * accessToken,
	std::string apiName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotApiNameActionsUpgradePostHelper(accessToken,
	apiName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxSnapshotApiNameDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxSnapshotApiNameDeleteHelper(char * accessToken,
	std::string apiName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/snapshot/{api_name}");
	int pos;

	string s_apiName("{");
	s_apiName.append("api_name");
	s_apiName.append("}");
	pos = url.find(s_apiName);
	url.erase(pos, s_apiName.length());
	url.insert(pos, stringify(&apiName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxSnapshotApiNameDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxSnapshotApiNameDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxSnapshotApiNameDeleteAsync(char * accessToken,
	std::string apiName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotApiNameDeleteHelper(accessToken,
	apiName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxSnapshotApiNameDeleteSync(char * accessToken,
	std::string apiName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotApiNameDeleteHelper(accessToken,
	apiName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxSnapshotGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxSnapshotGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/snapshot");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxSnapshotGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxSnapshotGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxSnapshotGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxSnapshotGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxSnapshotPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxSnapshotPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/snapshot");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxSnapshotPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxSnapshotPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxSnapshotPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxSnapshotPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxSnapshotPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxVaultIdActionsRefreshPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxVaultIdActionsRefreshPostHelper(char * accessToken,
	std::string vaultId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/{vault_id}/actions/refresh");
	int pos;

	string s_vaultId("{");
	s_vaultId.append("vault_id");
	s_vaultId.append("}");
	pos = url.find(s_vaultId);
	url.erase(pos, s_vaultId.length());
	url.insert(pos, stringify(&vaultId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxVaultIdActionsRefreshPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxVaultIdActionsRefreshPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxVaultIdActionsRefreshPostAsync(char * accessToken,
	std::string vaultId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxVaultIdActionsRefreshPostHelper(accessToken,
	vaultId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxVaultIdActionsRefreshPostSync(char * accessToken,
	std::string vaultId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxVaultIdActionsRefreshPostHelper(accessToken,
	vaultId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSandboxVaultIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSandboxVaultIdGetHelper(char * accessToken,
	std::string vaultId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/sandbox/{vault_id}");
	int pos;

	string s_vaultId("{");
	s_vaultId.append("vault_id");
	s_vaultId.append("}");
	pos = url.find(s_vaultId);
	url.erase(pos, s_vaultId.length());
	url.insert(pos, stringify(&vaultId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSandboxVaultIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSandboxVaultIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSandboxVaultIdGetAsync(char * accessToken,
	std::string vaultId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxVaultIdGetHelper(accessToken,
	vaultId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSandboxVaultIdGetSync(char * accessToken,
	std::string vaultId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSandboxVaultIdGetHelper(accessToken,
	vaultId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSecuritypoliciesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSecuritypoliciesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/securitypolicies");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSecuritypoliciesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSecuritypoliciesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSecuritypoliciesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSecuritypoliciesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSecuritypoliciesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSecuritypoliciesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsSecuritypoliciesSecurityPolicyNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsSecuritypoliciesSecurityPolicyNameGetHelper(char * accessToken,
	std::string securityPolicyName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/securitypolicies/{security_policy_name}");
	int pos;

	string s_securityPolicyName("{");
	s_securityPolicyName.append("security_policy_name");
	s_securityPolicyName.append("}");
	pos = url.find(s_securityPolicyName);
	url.erase(pos, s_securityPolicyName.length());
	url.insert(pos, stringify(&securityPolicyName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsSecuritypoliciesSecurityPolicyNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsSecuritypoliciesSecurityPolicyNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsSecuritypoliciesSecurityPolicyNameGetAsync(char * accessToken,
	std::string securityPolicyName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSecuritypoliciesSecurityPolicyNameGetHelper(accessToken,
	securityPolicyName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsSecuritypoliciesSecurityPolicyNameGetSync(char * accessToken,
	std::string securityPolicyName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsSecuritypoliciesSecurityPolicyNameGetHelper(accessToken,
	securityPolicyName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersGetHelper(char * accessToken,
	std::string vaults, std::string excludeVaultMembership, std::string excludeAppLicensing, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&vaults, "std::string");
	queryParams.insert(pair<string, string>("vaults", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("vaults");
	}


	itemAtq = stringify(&excludeVaultMembership, "std::string");
	queryParams.insert(pair<string, string>("exclude_vault_membership", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("exclude_vault_membership");
	}


	itemAtq = stringify(&excludeAppLicensing, "std::string");
	queryParams.insert(pair<string, string>("exclude_app_licensing", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("exclude_app_licensing");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersGetAsync(char * accessToken,
	std::string vaults, std::string excludeVaultMembership, std::string excludeAppLicensing, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersGetHelper(accessToken,
	vaults, excludeVaultMembership, excludeAppLicensing, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersGetSync(char * accessToken,
	std::string vaults, std::string excludeVaultMembership, std::string excludeAppLicensing, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersGetHelper(accessToken,
	vaults, excludeVaultMembership, excludeAppLicensing, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersIdGetHelper(char * accessToken,
	std::string id, std::string excludeVaultMembership, std::string excludeAppLicensing, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&excludeVaultMembership, "std::string");
	queryParams.insert(pair<string, string>("exclude_vault_membership", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("exclude_vault_membership");
	}


	itemAtq = stringify(&excludeAppLicensing, "std::string");
	queryParams.insert(pair<string, string>("exclude_app_licensing", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("exclude_app_licensing");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/{id}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersIdGetAsync(char * accessToken,
	std::string id, std::string excludeVaultMembership, std::string excludeAppLicensing, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersIdGetHelper(accessToken,
	id, excludeVaultMembership, excludeAppLicensing, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersIdGetSync(char * accessToken,
	std::string id, std::string excludeVaultMembership, std::string excludeAppLicensing, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersIdGetHelper(accessToken,
	id, excludeVaultMembership, excludeAppLicensing, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersIdPermissionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersIdPermissionsGetHelper(char * accessToken,
	std::string id, std::string filter, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&filter, "std::string");
	queryParams.insert(pair<string, string>("filter", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("filter");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/{id}/permissions");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersIdPermissionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersIdPermissionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersIdPermissionsGetAsync(char * accessToken,
	std::string id, std::string filter, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersIdPermissionsGetHelper(accessToken,
	id, filter, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersIdPermissionsGetSync(char * accessToken,
	std::string id, std::string filter, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersIdPermissionsGetHelper(accessToken,
	id, filter, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersIdPutHelper(char * accessToken,
	std::string id, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/{id}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersIdPutAsync(char * accessToken,
	std::string id, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersIdPutHelper(accessToken,
	id, authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersIdPutSync(char * accessToken,
	std::string id, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersIdPutHelper(accessToken,
	id, authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersMeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersMeGetHelper(char * accessToken,
	std::string excludeVaultMembership, std::string excludeAppLicensing, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&excludeVaultMembership, "std::string");
	queryParams.insert(pair<string, string>("exclude_vault_membership", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("exclude_vault_membership");
	}


	itemAtq = stringify(&excludeAppLicensing, "std::string");
	queryParams.insert(pair<string, string>("exclude_app_licensing", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("exclude_app_licensing");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/me");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersMeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersMeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersMeGetAsync(char * accessToken,
	std::string excludeVaultMembership, std::string excludeAppLicensing, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersMeGetHelper(accessToken,
	excludeVaultMembership, excludeAppLicensing, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersMeGetSync(char * accessToken,
	std::string excludeVaultMembership, std::string excludeAppLicensing, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersMeGetHelper(accessToken,
	excludeVaultMembership, excludeAppLicensing, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersMePasswordPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersMePasswordPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/me/password");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersMePasswordPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersMePasswordPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersMePasswordPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersMePasswordPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersMePasswordPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersMePasswordPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersMePermissionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersMePermissionsGetHelper(char * accessToken,
	std::string filter, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&filter, "std::string");
	queryParams.insert(pair<string, string>("filter", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("filter");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/me/permissions");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersMePermissionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersMePermissionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersMePermissionsGetAsync(char * accessToken,
	std::string filter, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersMePermissionsGetHelper(accessToken,
	filter, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersMePermissionsGetSync(char * accessToken,
	std::string filter, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersMePermissionsGetHelper(accessToken,
	filter, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersMePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersMePutHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/me");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersMePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersMePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersMePutAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersMePutHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersMePutSync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersMePutHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersPutHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersPutAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersPutHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersPutSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersPutHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersUserIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersUserIdDeleteHelper(char * accessToken,
	std::string userId, bool domain, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&domain, "bool");
	queryParams.insert(pair<string, string>("domain", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("domain");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/{user_id}");
	int pos;

	string s_userId("{");
	s_userId.append("user_id");
	s_userId.append("}");
	pos = url.find(s_userId);
	url.erase(pos, s_userId.length());
	url.insert(pos, stringify(&userId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersUserIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersUserIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersUserIdDeleteAsync(char * accessToken,
	std::string userId, bool domain, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersUserIdDeleteHelper(accessToken,
	userId, domain, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersUserIdDeleteSync(char * accessToken,
	std::string userId, bool domain, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersUserIdDeleteHelper(accessToken,
	userId, domain, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsUsersUserIdVaultMembershipVaultIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsUsersUserIdVaultMembershipVaultIdPutHelper(char * accessToken,
	std::string userId, std::string vaultId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/users/{user_id}/vault_membership/{vault_id}");
	int pos;

	string s_userId("{");
	s_userId.append("user_id");
	s_userId.append("}");
	pos = url.find(s_userId);
	url.erase(pos, s_userId.length());
	url.insert(pos, stringify(&userId, "std::string"));
	string s_vaultId("{");
	s_vaultId.append("vault_id");
	s_vaultId.append("}");
	pos = url.find(s_vaultId);
	url.erase(pos, s_vaultId.length());
	url.insert(pos, stringify(&vaultId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsUsersUserIdVaultMembershipVaultIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsUsersUserIdVaultMembershipVaultIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsUsersUserIdVaultMembershipVaultIdPutAsync(char * accessToken,
	std::string userId, std::string vaultId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersUserIdVaultMembershipVaultIdPutHelper(accessToken,
	userId, vaultId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsUsersUserIdVaultMembershipVaultIdPutSync(char * accessToken,
	std::string userId, std::string vaultId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsUsersUserIdVaultMembershipVaultIdPutHelper(accessToken,
	userId, vaultId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsVaultActionsComparePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsVaultActionsComparePostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/vault/actions/compare");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsVaultActionsComparePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsVaultActionsComparePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsVaultActionsComparePostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsVaultActionsComparePostHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsVaultActionsComparePostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsVaultActionsComparePostHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool objectsVaultActionsConfigreportPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool objectsVaultActionsConfigreportPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/objects/vault/actions/configreport");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = objectsVaultActionsConfigreportPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), objectsVaultActionsConfigreportPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::objectsVaultActionsConfigreportPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsVaultActionsConfigreportPostHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::objectsVaultActionsConfigreportPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return objectsVaultActionsConfigreportPostHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool queryComponentsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool queryComponentsPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/query/components");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = queryComponentsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), queryComponentsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::queryComponentsPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return queryComponentsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::queryComponentsPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return queryComponentsPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool queryNextPagePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool queryNextPagePostHelper(char * accessToken,
	std::string nextPage, std::string authorization, std::string accept, bool xVaultAPIDescribeQuery, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-DescribeQuery: ");
		headerString.append(stringify(&xVaultAPIDescribeQuery, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/query/{next_page}");
	int pos;

	string s_nextPage("{");
	s_nextPage.append("next_page");
	s_nextPage.append("}");
	pos = url.find(s_nextPage);
	url.erase(pos, s_nextPage.length());
	url.insert(pos, stringify(&nextPage, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = queryNextPagePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), queryNextPagePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::queryNextPagePostAsync(char * accessToken,
	std::string nextPage, std::string authorization, std::string accept, bool xVaultAPIDescribeQuery, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return queryNextPagePostHelper(accessToken,
	nextPage, authorization, accept, xVaultAPIDescribeQuery, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::queryNextPagePostSync(char * accessToken,
	std::string nextPage, std::string authorization, std::string accept, bool xVaultAPIDescribeQuery, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return queryNextPagePostHelper(accessToken,
	nextPage, authorization, accept, xVaultAPIDescribeQuery, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool queryPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool queryPostHelper(char * accessToken,
	std::string authorization, std::string accept, bool xVaultAPIDescribeQuery, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-DescribeQuery: ");
		headerString.append(stringify(&xVaultAPIDescribeQuery, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/query");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = queryPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), queryPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::queryPostAsync(char * accessToken,
	std::string authorization, std::string accept, bool xVaultAPIDescribeQuery, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return queryPostHelper(accessToken,
	authorization, accept, xVaultAPIDescribeQuery, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::queryPostSync(char * accessToken,
	std::string authorization, std::string accept, bool xVaultAPIDescribeQuery, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return queryPostHelper(accessToken,
	authorization, accept, xVaultAPIDescribeQuery, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool queryPreviousPagePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool queryPreviousPagePostHelper(char * accessToken,
	std::string previousPage, std::string authorization, std::string accept, bool xVaultAPIDescribeQuery, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-DescribeQuery: ");
		headerString.append(stringify(&xVaultAPIDescribeQuery, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/query/{previous_page}");
	int pos;

	string s_previousPage("{");
	s_previousPage.append("previous_page");
	s_previousPage.append("}");
	pos = url.find(s_previousPage);
	url.erase(pos, s_previousPage.length());
	url.insert(pos, stringify(&previousPage, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = queryPreviousPagePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), queryPreviousPagePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::queryPreviousPagePostAsync(char * accessToken,
	std::string previousPage, std::string authorization, std::string accept, bool xVaultAPIDescribeQuery, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return queryPreviousPagePostHelper(accessToken,
	previousPage, authorization, accept, xVaultAPIDescribeQuery, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::queryPreviousPagePostSync(char * accessToken,
	std::string previousPage, std::string authorization, std::string accept, bool xVaultAPIDescribeQuery, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return queryPreviousPagePostHelper(accessToken,
	previousPage, authorization, accept, xVaultAPIDescribeQuery, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2MeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2MeGetHelper(char * accessToken,
	std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&attributes, "std::string");
	queryParams.insert(pair<string, string>("attributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("attributes");
	}


	itemAtq = stringify(&excludedAttributes, "std::string");
	queryParams.insert(pair<string, string>("excludedAttributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("excludedAttributes");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/Me");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2MeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2MeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2MeGetAsync(char * accessToken,
	std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2MeGetHelper(accessToken,
	attributes, excludedAttributes, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2MeGetSync(char * accessToken,
	std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2MeGetHelper(accessToken,
	attributes, excludedAttributes, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2MePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2MePutHelper(char * accessToken,
	std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&attributes, "std::string");
	queryParams.insert(pair<string, string>("attributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("attributes");
	}


	itemAtq = stringify(&excludedAttributes, "std::string");
	queryParams.insert(pair<string, string>("excludedAttributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("excludedAttributes");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/Me");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2MePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2MePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2MePutAsync(char * accessToken,
	std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2MePutHelper(accessToken,
	attributes, excludedAttributes, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2MePutSync(char * accessToken,
	std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2MePutHelper(accessToken,
	attributes, excludedAttributes, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2ResourceTypesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2ResourceTypesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/ResourceTypes");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2ResourceTypesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2ResourceTypesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2ResourceTypesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2ResourceTypesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2ResourceTypesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2ResourceTypesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2ResourceTypesTypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2ResourceTypesTypeGetHelper(char * accessToken,
	std::string type, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/ResourceTypes/{type}");
	int pos;

	string s_type("{");
	s_type.append("type");
	s_type.append("}");
	pos = url.find(s_type);
	url.erase(pos, s_type.length());
	url.insert(pos, stringify(&type, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2ResourceTypesTypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2ResourceTypesTypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2ResourceTypesTypeGetAsync(char * accessToken,
	std::string type, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2ResourceTypesTypeGetHelper(accessToken,
	type, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2ResourceTypesTypeGetSync(char * accessToken,
	std::string type, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2ResourceTypesTypeGetHelper(accessToken,
	type, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2SchemasGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2SchemasGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/Schemas");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2SchemasGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2SchemasGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2SchemasGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2SchemasGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2SchemasGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2SchemasGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2SchemasIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2SchemasIdGetHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/Schemas/{id}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2SchemasIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2SchemasIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2SchemasIdGetAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2SchemasIdGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2SchemasIdGetSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2SchemasIdGetHelper(accessToken,
	id, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2ServiceProviderConfigGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2ServiceProviderConfigGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/ServiceProviderConfig");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2ServiceProviderConfigGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2ServiceProviderConfigGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2ServiceProviderConfigGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2ServiceProviderConfigGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2ServiceProviderConfigGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2ServiceProviderConfigGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2TypeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2TypeGetHelper(char * accessToken,
	std::string type, std::string filter, std::string attributes, std::string excludedAttributes, std::string sortBy, std::string sortOrder, std::string startIndex, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&filter, "std::string");
	queryParams.insert(pair<string, string>("filter", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("filter");
	}


	itemAtq = stringify(&attributes, "std::string");
	queryParams.insert(pair<string, string>("attributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("attributes");
	}


	itemAtq = stringify(&excludedAttributes, "std::string");
	queryParams.insert(pair<string, string>("excludedAttributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("excludedAttributes");
	}


	itemAtq = stringify(&sortBy, "std::string");
	queryParams.insert(pair<string, string>("sortBy", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("sortBy");
	}


	itemAtq = stringify(&sortOrder, "std::string");
	queryParams.insert(pair<string, string>("sortOrder", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("sortOrder");
	}


	itemAtq = stringify(&startIndex, "std::string");
	queryParams.insert(pair<string, string>("startIndex", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("startIndex");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/{type}");
	int pos;

	string s_type("{");
	s_type.append("type");
	s_type.append("}");
	pos = url.find(s_type);
	url.erase(pos, s_type.length());
	url.insert(pos, stringify(&type, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2TypeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2TypeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2TypeGetAsync(char * accessToken,
	std::string type, std::string filter, std::string attributes, std::string excludedAttributes, std::string sortBy, std::string sortOrder, std::string startIndex, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2TypeGetHelper(accessToken,
	type, filter, attributes, excludedAttributes, sortBy, sortOrder, startIndex, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2TypeGetSync(char * accessToken,
	std::string type, std::string filter, std::string attributes, std::string excludedAttributes, std::string sortBy, std::string sortOrder, std::string startIndex, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2TypeGetHelper(accessToken,
	type, filter, attributes, excludedAttributes, sortBy, sortOrder, startIndex, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2TypeIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2TypeIdGetHelper(char * accessToken,
	std::string type, std::string id, std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&attributes, "std::string");
	queryParams.insert(pair<string, string>("attributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("attributes");
	}


	itemAtq = stringify(&excludedAttributes, "std::string");
	queryParams.insert(pair<string, string>("excludedAttributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("excludedAttributes");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/{type}/{id}");
	int pos;

	string s_type("{");
	s_type.append("type");
	s_type.append("}");
	pos = url.find(s_type);
	url.erase(pos, s_type.length());
	url.insert(pos, stringify(&type, "std::string"));
	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2TypeIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2TypeIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2TypeIdGetAsync(char * accessToken,
	std::string type, std::string id, std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2TypeIdGetHelper(accessToken,
	type, id, attributes, excludedAttributes, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2TypeIdGetSync(char * accessToken,
	std::string type, std::string id, std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2TypeIdGetHelper(accessToken,
	type, id, attributes, excludedAttributes, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2UsersGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2UsersGetHelper(char * accessToken,
	std::string filter, std::string attributes, std::string excludedAttributes, std::string sortBy, std::string sortOrder, std::string count, std::string startIndex, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&filter, "std::string");
	queryParams.insert(pair<string, string>("filter", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("filter");
	}


	itemAtq = stringify(&attributes, "std::string");
	queryParams.insert(pair<string, string>("attributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("attributes");
	}


	itemAtq = stringify(&excludedAttributes, "std::string");
	queryParams.insert(pair<string, string>("excludedAttributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("excludedAttributes");
	}


	itemAtq = stringify(&sortBy, "std::string");
	queryParams.insert(pair<string, string>("sortBy", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("sortBy");
	}


	itemAtq = stringify(&sortOrder, "std::string");
	queryParams.insert(pair<string, string>("sortOrder", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("sortOrder");
	}


	itemAtq = stringify(&count, "std::string");
	queryParams.insert(pair<string, string>("count", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("count");
	}


	itemAtq = stringify(&startIndex, "std::string");
	queryParams.insert(pair<string, string>("startIndex", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("startIndex");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/Users");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2UsersGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2UsersGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2UsersGetAsync(char * accessToken,
	std::string filter, std::string attributes, std::string excludedAttributes, std::string sortBy, std::string sortOrder, std::string count, std::string startIndex, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2UsersGetHelper(accessToken,
	filter, attributes, excludedAttributes, sortBy, sortOrder, count, startIndex, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2UsersGetSync(char * accessToken,
	std::string filter, std::string attributes, std::string excludedAttributes, std::string sortBy, std::string sortOrder, std::string count, std::string startIndex, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2UsersGetHelper(accessToken,
	filter, attributes, excludedAttributes, sortBy, sortOrder, count, startIndex, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2UsersIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2UsersIdGetHelper(char * accessToken,
	std::string id, std::string filter, std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&filter, "std::string");
	queryParams.insert(pair<string, string>("filter", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("filter");
	}


	itemAtq = stringify(&attributes, "std::string");
	queryParams.insert(pair<string, string>("attributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("attributes");
	}


	itemAtq = stringify(&excludedAttributes, "std::string");
	queryParams.insert(pair<string, string>("excludedAttributes", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("excludedAttributes");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/Users/{id}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2UsersIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2UsersIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2UsersIdGetAsync(char * accessToken,
	std::string id, std::string filter, std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2UsersIdGetHelper(accessToken,
	id, filter, attributes, excludedAttributes, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2UsersIdGetSync(char * accessToken,
	std::string id, std::string filter, std::string attributes, std::string excludedAttributes, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2UsersIdGetHelper(accessToken,
	id, filter, attributes, excludedAttributes, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2UsersIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2UsersIdPutHelper(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/Users/{id}");
	int pos;

	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2UsersIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2UsersIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2UsersIdPutAsync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2UsersIdPutHelper(accessToken,
	id, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2UsersIdPutSync(char * accessToken,
	std::string id, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2UsersIdPutHelper(accessToken,
	id, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool scimV2UsersPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool scimV2UsersPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/scim/v2/Users");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = scimV2UsersPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), scimV2UsersPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::scimV2UsersPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2UsersPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::scimV2UsersPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return scimV2UsersPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesCertificateCertIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesCertificateCertIdGetHelper(char * accessToken,
	std::string certId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/certificate/{cert_id}");
	int pos;

	string s_certId("{");
	s_certId.append("cert_id");
	s_certId.append("}");
	pos = url.find(s_certId);
	url.erase(pos, s_certId.length());
	url.insert(pos, stringify(&certId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesCertificateCertIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesCertificateCertIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesCertificateCertIdGetAsync(char * accessToken,
	std::string certId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesCertificateCertIdGetHelper(accessToken,
	certId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesCertificateCertIdGetSync(char * accessToken,
	std::string certId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesCertificateCertIdGetHelper(accessToken,
	certId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesConfigurationModeActionsDisablePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesConfigurationModeActionsDisablePostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/configuration_mode/actions/disable");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesConfigurationModeActionsDisablePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesConfigurationModeActionsDisablePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesConfigurationModeActionsDisablePostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesConfigurationModeActionsDisablePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesConfigurationModeActionsDisablePostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesConfigurationModeActionsDisablePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesConfigurationModeActionsEnablePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesConfigurationModeActionsEnablePostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/configuration_mode/actions/enable");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesConfigurationModeActionsEnablePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesConfigurationModeActionsEnablePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesConfigurationModeActionsEnablePostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesConfigurationModeActionsEnablePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesConfigurationModeActionsEnablePostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesConfigurationModeActionsEnablePostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesDirectdataFilesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesDirectdataFilesGetHelper(char * accessToken,
	std::string extractType, int startTime, int stopTime, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&extractType, "std::string");
	queryParams.insert(pair<string, string>("extract_type", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("extract_type");
	}


	itemAtq = stringify(&startTime, "int");
	queryParams.insert(pair<string, string>("start_time", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("start_time");
	}


	itemAtq = stringify(&stopTime, "int");
	queryParams.insert(pair<string, string>("stop_time", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("stop_time");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/directdata/files");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesDirectdataFilesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesDirectdataFilesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesDirectdataFilesGetAsync(char * accessToken,
	std::string extractType, int startTime, int stopTime, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesDirectdataFilesGetHelper(accessToken,
	extractType, startTime, stopTime, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesDirectdataFilesGetSync(char * accessToken,
	std::string extractType, int startTime, int stopTime, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesDirectdataFilesGetHelper(accessToken,
	extractType, startTime, stopTime, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesDirectdataFilesNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesDirectdataFilesNameGetHelper(char * accessToken,
	std::string name, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/directdata/files/{name}");
	int pos;

	string s_name("{");
	s_name.append("name");
	s_name.append("}");
	pos = url.find(s_name);
	url.erase(pos, s_name.length());
	url.insert(pos, stringify(&name, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesDirectdataFilesNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesDirectdataFilesNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesDirectdataFilesNameGetAsync(char * accessToken,
	std::string name, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesDirectdataFilesNameGetHelper(accessToken,
	name, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesDirectdataFilesNameGetSync(char * accessToken,
	std::string name, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesDirectdataFilesNameGetHelper(accessToken,
	name, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingItemsContentItemGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingItemsContentItemGetHelper(char * accessToken,
	std::string item, std::string authorization, std::string accept, std::string range, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Range: ");
		headerString.append(stringify(&range, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/items/content/{item}");
	int pos;

	string s_item("{");
	s_item.append("item");
	s_item.append("}");
	pos = url.find(s_item);
	url.erase(pos, s_item.length());
	url.insert(pos, stringify(&item, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingItemsContentItemGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingItemsContentItemGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingItemsContentItemGetAsync(char * accessToken,
	std::string item, std::string authorization, std::string accept, std::string range, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsContentItemGetHelper(accessToken,
	item, authorization, accept, range, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingItemsContentItemGetSync(char * accessToken,
	std::string item, std::string authorization, std::string accept, std::string range, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsContentItemGetHelper(accessToken,
	item, authorization, accept, range, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingItemsItemDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingItemsItemDeleteHelper(char * accessToken,
	std::string item, std::string recursive, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&recursive, "std::string");
	queryParams.insert(pair<string, string>("recursive", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("recursive");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/items/{item}");
	int pos;

	string s_item("{");
	s_item.append("item");
	s_item.append("}");
	pos = url.find(s_item);
	url.erase(pos, s_item.length());
	url.insert(pos, stringify(&item, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingItemsItemDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingItemsItemDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingItemsItemDeleteAsync(char * accessToken,
	std::string item, std::string recursive, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsItemDeleteHelper(accessToken,
	item, recursive, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingItemsItemDeleteSync(char * accessToken,
	std::string item, std::string recursive, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsItemDeleteHelper(accessToken,
	item, recursive, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingItemsItemGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingItemsItemGetHelper(char * accessToken,
	std::string item, std::string recursive, std::string limit, std::string formatResult, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&recursive, "std::string");
	queryParams.insert(pair<string, string>("recursive", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("recursive");
	}


	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&formatResult, "std::string");
	queryParams.insert(pair<string, string>("format_result", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("format_result");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/items/{item}");
	int pos;

	string s_item("{");
	s_item.append("item");
	s_item.append("}");
	pos = url.find(s_item);
	url.erase(pos, s_item.length());
	url.insert(pos, stringify(&item, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingItemsItemGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingItemsItemGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingItemsItemGetAsync(char * accessToken,
	std::string item, std::string recursive, std::string limit, std::string formatResult, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsItemGetHelper(accessToken,
	item, recursive, limit, formatResult, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingItemsItemGetSync(char * accessToken,
	std::string item, std::string recursive, std::string limit, std::string formatResult, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsItemGetHelper(accessToken,
	item, recursive, limit, formatResult, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingItemsItemPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingItemsItemPutHelper(char * accessToken,
	std::string item, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/items/{item}");
	int pos;

	string s_item("{");
	s_item.append("item");
	s_item.append("}");
	pos = url.find(s_item);
	url.erase(pos, s_item.length());
	url.insert(pos, stringify(&item, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingItemsItemPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingItemsItemPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingItemsItemPutAsync(char * accessToken,
	std::string item, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsItemPutHelper(accessToken,
	item, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingItemsItemPutSync(char * accessToken,
	std::string item, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsItemPutHelper(accessToken,
	item, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingItemsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingItemsPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentMD5, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-MD5: ");
		headerString.append(stringify(&contentMD5, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/items");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingItemsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingItemsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingItemsPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentMD5, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsPostHelper(accessToken,
	authorization, accept, contentMD5, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingItemsPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentMD5, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingItemsPostHelper(accessToken,
	authorization, accept, contentMD5, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingUploadGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingUploadGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/upload/");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingUploadGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingUploadGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingUploadGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingUploadGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingUploadPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingUploadPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/upload");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingUploadPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingUploadPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingUploadPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadPostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingUploadPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadPostHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingUploadUploadSessionIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingUploadUploadSessionIdDeleteHelper(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/upload/{upload_session_id}");
	int pos;

	string s_uploadSessionId("{");
	s_uploadSessionId.append("upload_session_id");
	s_uploadSessionId.append("}");
	pos = url.find(s_uploadSessionId);
	url.erase(pos, s_uploadSessionId.length());
	url.insert(pos, stringify(&uploadSessionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingUploadUploadSessionIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingUploadUploadSessionIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingUploadUploadSessionIdDeleteAsync(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdDeleteHelper(accessToken,
	uploadSessionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingUploadUploadSessionIdDeleteSync(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdDeleteHelper(accessToken,
	uploadSessionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingUploadUploadSessionIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingUploadUploadSessionIdGetHelper(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/upload/{upload_session_id}");
	int pos;

	string s_uploadSessionId("{");
	s_uploadSessionId.append("upload_session_id");
	s_uploadSessionId.append("}");
	pos = url.find(s_uploadSessionId);
	url.erase(pos, s_uploadSessionId.length());
	url.insert(pos, stringify(&uploadSessionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingUploadUploadSessionIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingUploadUploadSessionIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingUploadUploadSessionIdGetAsync(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdGetHelper(accessToken,
	uploadSessionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingUploadUploadSessionIdGetSync(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdGetHelper(accessToken,
	uploadSessionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingUploadUploadSessionIdPartsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingUploadUploadSessionIdPartsGetHelper(char * accessToken,
	std::string uploadSessionId, std::string limit, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/upload/{upload_session_id}/parts");
	int pos;

	string s_uploadSessionId("{");
	s_uploadSessionId.append("upload_session_id");
	s_uploadSessionId.append("}");
	pos = url.find(s_uploadSessionId);
	url.erase(pos, s_uploadSessionId.length());
	url.insert(pos, stringify(&uploadSessionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingUploadUploadSessionIdPartsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingUploadUploadSessionIdPartsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingUploadUploadSessionIdPartsGetAsync(char * accessToken,
	std::string uploadSessionId, std::string limit, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdPartsGetHelper(accessToken,
	uploadSessionId, limit, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingUploadUploadSessionIdPartsGetSync(char * accessToken,
	std::string uploadSessionId, std::string limit, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdPartsGetHelper(accessToken,
	uploadSessionId, limit, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingUploadUploadSessionIdPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingUploadUploadSessionIdPostHelper(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/upload/{upload_session_id}");
	int pos;

	string s_uploadSessionId("{");
	s_uploadSessionId.append("upload_session_id");
	s_uploadSessionId.append("}");
	pos = url.find(s_uploadSessionId);
	url.erase(pos, s_uploadSessionId.length());
	url.insert(pos, stringify(&uploadSessionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingUploadUploadSessionIdPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingUploadUploadSessionIdPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingUploadUploadSessionIdPostAsync(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdPostHelper(accessToken,
	uploadSessionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingUploadUploadSessionIdPostSync(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdPostHelper(accessToken,
	uploadSessionId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesFileStagingUploadUploadSessionIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesFileStagingUploadUploadSessionIdPutHelper(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIFilePartNumber, std::string contentMD5, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-FilePartNumber: ");
		headerString.append(stringify(&xVaultAPIFilePartNumber, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-MD5: ");
		headerString.append(stringify(&contentMD5, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/file_staging/upload/{upload_session_id}");
	int pos;

	string s_uploadSessionId("{");
	s_uploadSessionId.append("upload_session_id");
	s_uploadSessionId.append("}");
	pos = url.find(s_uploadSessionId);
	url.erase(pos, s_uploadSessionId.length());
	url.insert(pos, stringify(&uploadSessionId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesFileStagingUploadUploadSessionIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesFileStagingUploadUploadSessionIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesFileStagingUploadUploadSessionIdPutAsync(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIFilePartNumber, std::string contentMD5, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdPutHelper(accessToken,
	uploadSessionId, authorization, accept, contentType, xVaultAPIFilePartNumber, contentMD5, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesFileStagingUploadUploadSessionIdPutSync(char * accessToken,
	std::string uploadSessionId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIFilePartNumber, std::string contentMD5, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesFileStagingUploadUploadSessionIdPutHelper(accessToken,
	uploadSessionId, authorization, accept, contentType, xVaultAPIFilePartNumber, contentMD5, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesJobsHistoriesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesJobsHistoriesGetHelper(char * accessToken,
	std::string startDate, std::string endDate, std::string status, std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&startDate, "std::string");
	queryParams.insert(pair<string, string>("start_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("start_date");
	}


	itemAtq = stringify(&endDate, "std::string");
	queryParams.insert(pair<string, string>("end_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("end_date");
	}


	itemAtq = stringify(&status, "std::string");
	queryParams.insert(pair<string, string>("status", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("status");
	}


	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/jobs/histories");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesJobsHistoriesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesJobsHistoriesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesJobsHistoriesGetAsync(char * accessToken,
	std::string startDate, std::string endDate, std::string status, std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsHistoriesGetHelper(accessToken,
	startDate, endDate, status, limit, offset, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesJobsHistoriesGetSync(char * accessToken,
	std::string startDate, std::string endDate, std::string status, std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsHistoriesGetHelper(accessToken,
	startDate, endDate, status, limit, offset, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesJobsJobIdErrorsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesJobsJobIdErrorsGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/jobs/{job_id}/errors");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesJobsJobIdErrorsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesJobsJobIdErrorsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesJobsJobIdErrorsGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsJobIdErrorsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesJobsJobIdErrorsGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsJobIdErrorsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesJobsJobIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesJobsJobIdGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/jobs/{job_id}");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesJobsJobIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesJobsJobIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesJobsJobIdGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsJobIdGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesJobsJobIdGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsJobIdGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesJobsJobIdSummaryGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesJobsJobIdSummaryGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/jobs/{job_id}/summary");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesJobsJobIdSummaryGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesJobsJobIdSummaryGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesJobsJobIdSummaryGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsJobIdSummaryGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesJobsJobIdSummaryGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsJobIdSummaryGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesJobsJobIdTasksGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesJobsJobIdTasksGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/jobs/{job_id}/tasks");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesJobsJobIdTasksGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesJobsJobIdTasksGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesJobsJobIdTasksGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsJobIdTasksGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesJobsJobIdTasksGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsJobIdTasksGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesJobsMonitorsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesJobsMonitorsGetHelper(char * accessToken,
	std::string startDate, std::string endDate, std::string status, std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&startDate, "std::string");
	queryParams.insert(pair<string, string>("start_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("start_date");
	}


	itemAtq = stringify(&endDate, "std::string");
	queryParams.insert(pair<string, string>("end_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("end_date");
	}


	itemAtq = stringify(&status, "std::string");
	queryParams.insert(pair<string, string>("status", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("status");
	}


	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/jobs/monitors");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesJobsMonitorsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesJobsMonitorsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesJobsMonitorsGetAsync(char * accessToken,
	std::string startDate, std::string endDate, std::string status, std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsMonitorsGetHelper(accessToken,
	startDate, endDate, status, limit, offset, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesJobsMonitorsGetSync(char * accessToken,
	std::string startDate, std::string endDate, std::string status, std::string limit, std::string offset, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsMonitorsGetHelper(accessToken,
	startDate, endDate, status, limit, offset, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesJobsStartNowJobIdPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesJobsStartNowJobIdPostHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/jobs/start_now/{job_id}");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesJobsStartNowJobIdPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesJobsStartNowJobIdPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesJobsStartNowJobIdPostAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsStartNowJobIdPostHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesJobsStartNowJobIdPostSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesJobsStartNowJobIdPostHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesLoaderExtractPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesLoaderExtractPostHelper(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/loader/extract");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesLoaderExtractPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesLoaderExtractPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesLoaderExtractPostAsync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderExtractPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesLoaderExtractPostSync(char * accessToken,
	std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderExtractPostHelper(accessToken,
	authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesLoaderJobIdTasksTaskIdFailurelogGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesLoaderJobIdTasksTaskIdFailurelogGetHelper(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/loader/{job_id}/tasks/{task_id}/failurelog");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));
	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesLoaderJobIdTasksTaskIdFailurelogGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesLoaderJobIdTasksTaskIdFailurelogGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesLoaderJobIdTasksTaskIdFailurelogGetAsync(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderJobIdTasksTaskIdFailurelogGetHelper(accessToken,
	jobId, taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesLoaderJobIdTasksTaskIdFailurelogGetSync(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderJobIdTasksTaskIdFailurelogGetHelper(accessToken,
	jobId, taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesLoaderJobIdTasksTaskIdResultsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesLoaderJobIdTasksTaskIdResultsGetHelper(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/loader/{job_id}/tasks/{task_id}/results");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));
	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesLoaderJobIdTasksTaskIdResultsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesLoaderJobIdTasksTaskIdResultsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesLoaderJobIdTasksTaskIdResultsGetAsync(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderJobIdTasksTaskIdResultsGetHelper(accessToken,
	jobId, taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesLoaderJobIdTasksTaskIdResultsGetSync(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderJobIdTasksTaskIdResultsGetHelper(accessToken,
	jobId, taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesLoaderJobIdTasksTaskIdResultsRenditionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesLoaderJobIdTasksTaskIdResultsRenditionsGetHelper(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/loader/{job_id}/tasks/{task_id}/results/renditions");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));
	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesLoaderJobIdTasksTaskIdResultsRenditionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesLoaderJobIdTasksTaskIdResultsRenditionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesLoaderJobIdTasksTaskIdResultsRenditionsGetAsync(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderJobIdTasksTaskIdResultsRenditionsGetHelper(accessToken,
	jobId, taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesLoaderJobIdTasksTaskIdResultsRenditionsGetSync(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderJobIdTasksTaskIdResultsRenditionsGetHelper(accessToken,
	jobId, taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesLoaderJobIdTasksTaskIdSuccesslogGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesLoaderJobIdTasksTaskIdSuccesslogGetHelper(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/loader/{job_id}/tasks/{task_id}/successlog");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));
	string s_taskId("{");
	s_taskId.append("task_id");
	s_taskId.append("}");
	pos = url.find(s_taskId);
	url.erase(pos, s_taskId.length());
	url.insert(pos, stringify(&taskId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesLoaderJobIdTasksTaskIdSuccesslogGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesLoaderJobIdTasksTaskIdSuccesslogGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesLoaderJobIdTasksTaskIdSuccesslogGetAsync(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderJobIdTasksTaskIdSuccesslogGetHelper(accessToken,
	jobId, taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesLoaderJobIdTasksTaskIdSuccesslogGetSync(char * accessToken,
	std::string jobId, std::string taskId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderJobIdTasksTaskIdSuccesslogGetHelper(accessToken,
	jobId, taskId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesLoaderLoadPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesLoaderLoadPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/loader/load");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesLoaderLoadPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesLoaderLoadPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesLoaderLoadPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderLoadPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesLoaderLoadPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesLoaderLoadPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesPackageActionsValidatePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesPackageActionsValidatePostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/package/actions/validate");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesPackageActionsValidatePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesPackageActionsValidatePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesPackageActionsValidatePostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesPackageActionsValidatePostHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesPackageActionsValidatePostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesPackageActionsValidatePostHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesPackagePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesPackagePostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/package");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesPackagePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesPackagePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesPackagePostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesPackagePostHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesPackagePostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesPackagePostHelper(accessToken,
	authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesPackagePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesPackagePutHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/package");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesPackagePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesPackagePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesPackagePutAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesPackagePutHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesPackagePutSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesPackagePutHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesQueuesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesQueuesGetHelper(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/queues");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesQueuesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesQueuesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesQueuesGetAsync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesQueuesGetSync(char * accessToken,
	std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesGetHelper(accessToken,
	authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesQueuesQueueNameActionsDisableDeliveryPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesQueuesQueueNameActionsDisableDeliveryPutHelper(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/queues/{queue_name}/actions/disable_delivery");
	int pos;

	string s_queueName("{");
	s_queueName.append("queue_name");
	s_queueName.append("}");
	pos = url.find(s_queueName);
	url.erase(pos, s_queueName.length());
	url.insert(pos, stringify(&queueName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesQueuesQueueNameActionsDisableDeliveryPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesQueuesQueueNameActionsDisableDeliveryPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesQueuesQueueNameActionsDisableDeliveryPutAsync(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesQueueNameActionsDisableDeliveryPutHelper(accessToken,
	queueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesQueuesQueueNameActionsDisableDeliveryPutSync(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesQueueNameActionsDisableDeliveryPutHelper(accessToken,
	queueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesQueuesQueueNameActionsEnableDeliveryPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesQueuesQueueNameActionsEnableDeliveryPutHelper(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/queues/{queue_name}/actions/enable_delivery");
	int pos;

	string s_queueName("{");
	s_queueName.append("queue_name");
	s_queueName.append("}");
	pos = url.find(s_queueName);
	url.erase(pos, s_queueName.length());
	url.insert(pos, stringify(&queueName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesQueuesQueueNameActionsEnableDeliveryPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesQueuesQueueNameActionsEnableDeliveryPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesQueuesQueueNameActionsEnableDeliveryPutAsync(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesQueueNameActionsEnableDeliveryPutHelper(accessToken,
	queueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesQueuesQueueNameActionsEnableDeliveryPutSync(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesQueueNameActionsEnableDeliveryPutHelper(accessToken,
	queueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesQueuesQueueNameActionsResetPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesQueuesQueueNameActionsResetPutHelper(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/queues/{queue_name}/actions/reset");
	int pos;

	string s_queueName("{");
	s_queueName.append("queue_name");
	s_queueName.append("}");
	pos = url.find(s_queueName);
	url.erase(pos, s_queueName.length());
	url.insert(pos, stringify(&queueName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesQueuesQueueNameActionsResetPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesQueuesQueueNameActionsResetPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesQueuesQueueNameActionsResetPutAsync(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesQueueNameActionsResetPutHelper(accessToken,
	queueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesQueuesQueueNameActionsResetPutSync(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesQueueNameActionsResetPutHelper(accessToken,
	queueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesQueuesQueueNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesQueuesQueueNameGetHelper(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/queues/{queue_name}");
	int pos;

	string s_queueName("{");
	s_queueName.append("queue_name");
	s_queueName.append("}");
	pos = url.find(s_queueName);
	url.erase(pos, s_queueName.length());
	url.insert(pos, stringify(&queueName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesQueuesQueueNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesQueuesQueueNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesQueuesQueueNameGetAsync(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesQueueNameGetHelper(accessToken,
	queueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesQueuesQueueNameGetSync(char * accessToken,
	std::string queueName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesQueuesQueueNameGetHelper(accessToken,
	queueName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool servicesVobjectVaultPackageVPackageIdActionsValidatePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool servicesVobjectVaultPackageVPackageIdActionsValidatePostHelper(char * accessToken,
	std::string packageId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/services/vobject/vault_package__v/{package_id}/actions/validate");
	int pos;

	string s_packageId("{");
	s_packageId.append("package_id");
	s_packageId.append("}");
	pos = url.find(s_packageId);
	url.erase(pos, s_packageId.length());
	url.insert(pos, stringify(&packageId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = servicesVobjectVaultPackageVPackageIdActionsValidatePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), servicesVobjectVaultPackageVPackageIdActionsValidatePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::servicesVobjectVaultPackageVPackageIdActionsValidatePostAsync(char * accessToken,
	std::string packageId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesVobjectVaultPackageVPackageIdActionsValidatePostHelper(accessToken,
	packageId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::servicesVobjectVaultPackageVPackageIdActionsValidatePostSync(char * accessToken,
	std::string packageId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return servicesVobjectVaultPackageVPackageIdActionsValidatePostHelper(accessToken,
	packageId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool sessionDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool sessionDeleteHelper(char * accessToken,
	std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/session");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = sessionDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), sessionDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::sessionDeleteAsync(char * accessToken,
	std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return sessionDeleteHelper(accessToken,
	accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::sessionDeleteSync(char * accessToken,
	std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return sessionDeleteHelper(accessToken,
	accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool uicodeDistributionsDistributionNameCodeGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool uicodeDistributionsDistributionNameCodeGetHelper(char * accessToken,
	std::string distributionName, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/uicode/distributions/{distribution_name}/code");
	int pos;

	string s_distributionName("{");
	s_distributionName.append("distribution_name");
	s_distributionName.append("}");
	pos = url.find(s_distributionName);
	url.erase(pos, s_distributionName.length());
	url.insert(pos, stringify(&distributionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = uicodeDistributionsDistributionNameCodeGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), uicodeDistributionsDistributionNameCodeGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::uicodeDistributionsDistributionNameCodeGetAsync(char * accessToken,
	std::string distributionName, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsDistributionNameCodeGetHelper(accessToken,
	distributionName, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::uicodeDistributionsDistributionNameCodeGetSync(char * accessToken,
	std::string distributionName, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsDistributionNameCodeGetHelper(accessToken,
	distributionName, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool uicodeDistributionsDistributionNameDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool uicodeDistributionsDistributionNameDeleteHelper(char * accessToken,
	std::string distributionName, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/uicode/distributions/{distribution_name}");
	int pos;

	string s_distributionName("{");
	s_distributionName.append("distribution_name");
	s_distributionName.append("}");
	pos = url.find(s_distributionName);
	url.erase(pos, s_distributionName.length());
	url.insert(pos, stringify(&distributionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = uicodeDistributionsDistributionNameDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), uicodeDistributionsDistributionNameDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::uicodeDistributionsDistributionNameDeleteAsync(char * accessToken,
	std::string distributionName, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsDistributionNameDeleteHelper(accessToken,
	distributionName, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::uicodeDistributionsDistributionNameDeleteSync(char * accessToken,
	std::string distributionName, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsDistributionNameDeleteHelper(accessToken,
	distributionName, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool uicodeDistributionsDistributionNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool uicodeDistributionsDistributionNameGetHelper(char * accessToken,
	std::string distributionName, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/uicode/distributions/{distribution_name}");
	int pos;

	string s_distributionName("{");
	s_distributionName.append("distribution_name");
	s_distributionName.append("}");
	pos = url.find(s_distributionName);
	url.erase(pos, s_distributionName.length());
	url.insert(pos, stringify(&distributionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = uicodeDistributionsDistributionNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), uicodeDistributionsDistributionNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::uicodeDistributionsDistributionNameGetAsync(char * accessToken,
	std::string distributionName, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsDistributionNameGetHelper(accessToken,
	distributionName, accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::uicodeDistributionsDistributionNameGetSync(char * accessToken,
	std::string distributionName, std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsDistributionNameGetHelper(accessToken,
	distributionName, accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool uicodeDistributionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool uicodeDistributionsGetHelper(char * accessToken,
	std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/uicode/distributions");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = uicodeDistributionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), uicodeDistributionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::uicodeDistributionsGetAsync(char * accessToken,
	std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsGetHelper(accessToken,
	accept, authorization, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::uicodeDistributionsGetSync(char * accessToken,
	std::string accept, std::string authorization, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsGetHelper(accessToken,
	accept, authorization, xVaultAPIClientID, 
	handler, userData, false);
}

static bool uicodeDistributionsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool uicodeDistributionsPostHelper(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/uicode/distributions");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = uicodeDistributionsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), uicodeDistributionsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::uicodeDistributionsPostAsync(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsPostHelper(accessToken,
	accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::uicodeDistributionsPostSync(char * accessToken,
	std::string accept, std::string authorization, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return uicodeDistributionsPostHelper(accessToken,
	accept, authorization, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectVaultPackageVPackageIdActionsDeployPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectVaultPackageVPackageIdActionsDeployPostHelper(char * accessToken,
	std::string packageId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobject/vault_package__v/{package_id}/actions/deploy");
	int pos;

	string s_packageId("{");
	s_packageId.append("package_id");
	s_packageId.append("}");
	pos = url.find(s_packageId);
	url.erase(pos, s_packageId.length());
	url.insert(pos, stringify(&packageId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectVaultPackageVPackageIdActionsDeployPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectVaultPackageVPackageIdActionsDeployPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectVaultPackageVPackageIdActionsDeployPostAsync(char * accessToken,
	std::string packageId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectVaultPackageVPackageIdActionsDeployPostHelper(accessToken,
	packageId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectVaultPackageVPackageIdActionsDeployPostSync(char * accessToken,
	std::string packageId, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectVaultPackageVPackageIdActionsDeployPostHelper(accessToken,
	packageId, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectVaultPackageVPackageIdActionsDeployResultsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectVaultPackageVPackageIdActionsDeployResultsGetHelper(char * accessToken,
	std::string packageId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobject/vault_package__v/{package_id}/actions/deploy/results");
	int pos;

	string s_packageId("{");
	s_packageId.append("package_id");
	s_packageId.append("}");
	pos = url.find(s_packageId);
	url.erase(pos, s_packageId.length());
	url.insert(pos, stringify(&packageId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectVaultPackageVPackageIdActionsDeployResultsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectVaultPackageVPackageIdActionsDeployResultsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectVaultPackageVPackageIdActionsDeployResultsGetAsync(char * accessToken,
	std::string packageId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectVaultPackageVPackageIdActionsDeployResultsGetHelper(accessToken,
	packageId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectVaultPackageVPackageIdActionsDeployResultsGetSync(char * accessToken,
	std::string packageId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectVaultPackageVPackageIdActionsDeployResultsGetHelper(accessToken,
	packageId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetHelper(char * accessToken,
	std::string objectName, std::string jobStatus, std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/cascadedelete/results/{object_name}/{job_status}/{job_id}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_jobStatus("{");
	s_jobStatus.append("job_status");
	s_jobStatus.append("}");
	pos = url.find(s_jobStatus);
	url.erase(pos, s_jobStatus.length());
	url.insert(pos, stringify(&jobStatus, "std::string"));
	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetAsync(char * accessToken,
	std::string objectName, std::string jobStatus, std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetHelper(accessToken,
	objectName, jobStatus, jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetSync(char * accessToken,
	std::string objectName, std::string jobStatus, std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsCascadedeleteResultsObjectNameJobStatusJobIdGetHelper(accessToken,
	objectName, jobStatus, jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetHelper(char * accessToken,
	std::string objectName, std::string jobStatus, std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/deepcopy/results/{object_name}/{job_status}/{job_id}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_jobStatus("{");
	s_jobStatus.append("job_status");
	s_jobStatus.append("}");
	pos = url.find(s_jobStatus);
	url.erase(pos, s_jobStatus.length());
	url.insert(pos, stringify(&jobStatus, "std::string"));
	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetAsync(char * accessToken,
	std::string objectName, std::string jobStatus, std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetHelper(accessToken,
	objectName, jobStatus, jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetSync(char * accessToken,
	std::string objectName, std::string jobStatus, std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsDeepcopyResultsObjectNameJobStatusJobIdGetHelper(accessToken,
	objectName, jobStatus, jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsEdlItemVActionsCreateplaceholderPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsEdlItemVActionsCreateplaceholderPostHelper(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/edl_item__v/actions/createplaceholder");
	int pos;


	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsEdlItemVActionsCreateplaceholderPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsEdlItemVActionsCreateplaceholderPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsEdlItemVActionsCreateplaceholderPostAsync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsEdlItemVActionsCreateplaceholderPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsEdlItemVActionsCreateplaceholderPostSync(char * accessToken,
	std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsEdlItemVActionsCreateplaceholderPostHelper(accessToken,
	authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsMergesJobIdLogGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsMergesJobIdLogGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/merges/{job_id}/log");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsMergesJobIdLogGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsMergesJobIdLogGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsMergesJobIdLogGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsMergesJobIdLogGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsMergesJobIdLogGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsMergesJobIdLogGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsMergesJobIdResultsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsMergesJobIdResultsGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/merges/{job_id}/results");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsMergesJobIdResultsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsMergesJobIdResultsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsMergesJobIdResultsGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsMergesJobIdResultsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsMergesJobIdResultsGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsMergesJobIdResultsGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsMergesJobIdStatusGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsMergesJobIdStatusGetHelper(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/merges/{job_id}/status");
	int pos;

	string s_jobId("{");
	s_jobId.append("job_id");
	s_jobId.append("}");
	pos = url.find(s_jobId);
	url.erase(pos, s_jobId.length());
	url.insert(pos, stringify(&jobId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsMergesJobIdStatusGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsMergesJobIdStatusGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsMergesJobIdStatusGetAsync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsMergesJobIdStatusGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsMergesJobIdStatusGetSync(char * accessToken,
	std::string jobId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsMergesJobIdStatusGetHelper(accessToken,
	jobId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameActionsActionNamePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameActionsActionNamePostHelper(char * accessToken,
	std::string objectName, std::string actionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/actions/{action_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_actionName("{");
	s_actionName.append("action_name");
	s_actionName.append("}");
	pos = url.find(s_actionName);
	url.erase(pos, s_actionName.length());
	url.insert(pos, stringify(&actionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameActionsActionNamePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameActionsActionNamePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameActionsActionNamePostAsync(char * accessToken,
	std::string objectName, std::string actionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsActionNamePostHelper(accessToken,
	objectName, actionName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameActionsActionNamePostSync(char * accessToken,
	std::string objectName, std::string actionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsActionNamePostHelper(accessToken,
	objectName, actionName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameActionsChangetypePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameActionsChangetypePostHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/actions/changetype");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameActionsChangetypePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameActionsChangetypePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameActionsChangetypePostAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsChangetypePostHelper(accessToken,
	objectName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameActionsChangetypePostSync(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsChangetypePostHelper(accessToken,
	objectName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameActionsMergePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameActionsMergePostHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, std::list<_vobjects__object_name__actions_merge_post_request_inner> vobjectsObjectNameActionsMergePostRequestInner, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;
	//TODO: Map Container
	if (isprimitive("_vobjects__object_name__actions_merge_post_request_inner")) {
		node = converttoJson(&vobjectsObjectNameActionsMergePostRequestInner, "_vobjects__object_name__actions_merge_post_request_inner", "array");
	} else {
		node = json_node_alloc();
		json_array = json_array_new();
		for (std::list
			<_vobjects__object_name__actions_merge_post_request_inner>::iterator bodyIter = vobjectsObjectNameActionsMergePostRequestInner.begin(); bodyIter != vobjectsObjectNameActionsMergePostRequestInner.end(); ++bodyIter) {
			_vobjects__object_name__actions_merge_post_request_inner itemAt = (*bodyIter);
			char *jsonStr =  itemAt.toJson();
			JsonNode *node_temp = json_from_string(jsonStr, NULL);
			g_free(static_cast<gpointer>(jsonStr));
			json_array_add_element(json_array, node_temp);
		}
		json_node_init_array(node, json_array);
		json_array_unref(json_array);
	}
	




	char *jsonStr1 =  json_to_string(node, false);
	mBody.append(jsonStr1);
	g_free(static_cast<gpointer>(jsonStr1));

	string url("/vobjects/{object_name}/actions/merge");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameActionsMergePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameActionsMergePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameActionsMergePostAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, std::list<_vobjects__object_name__actions_merge_post_request_inner> vobjectsObjectNameActionsMergePostRequestInner, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsMergePostHelper(accessToken,
	objectName, authorization, contentType, accept, xVaultAPIClientID, vobjectsObjectNameActionsMergePostRequestInner, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameActionsMergePostSync(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, std::list<_vobjects__object_name__actions_merge_post_request_inner> vobjectsObjectNameActionsMergePostRequestInner, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsMergePostHelper(accessToken,
	objectName, authorization, contentType, accept, xVaultAPIClientID, vobjectsObjectNameActionsMergePostRequestInner, 
	handler, userData, false);
}

static bool vobjectsObjectNameActionsRecalculaterollupsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameActionsRecalculaterollupsGetHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/actions/recalculaterollups");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameActionsRecalculaterollupsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameActionsRecalculaterollupsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameActionsRecalculaterollupsGetAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsRecalculaterollupsGetHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameActionsRecalculaterollupsGetSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsRecalculaterollupsGetHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameActionsRecalculaterollupsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameActionsRecalculaterollupsPostHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/actions/recalculaterollups");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameActionsRecalculaterollupsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameActionsRecalculaterollupsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameActionsRecalculaterollupsPostAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsRecalculaterollupsPostHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameActionsRecalculaterollupsPostSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsRecalculaterollupsPostHelper(accessToken,
	objectName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameActionsUpdatecorporatecurrencyPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameActionsUpdatecorporatecurrencyPutHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/actions/updatecorporatecurrency");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameActionsUpdatecorporatecurrencyPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameActionsUpdatecorporatecurrencyPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameActionsUpdatecorporatecurrencyPutAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsUpdatecorporatecurrencyPutHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameActionsUpdatecorporatecurrencyPutSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameActionsUpdatecorporatecurrencyPutHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameAttachmentsBatchDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameAttachmentsBatchDeleteHelper(char * accessToken,
	std::string objectName, std::string idParam, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&idParam, "std::string");
	queryParams.insert(pair<string, string>("idParam", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("idParam");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/attachments/batch");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameAttachmentsBatchDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameAttachmentsBatchDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameAttachmentsBatchDeleteAsync(char * accessToken,
	std::string objectName, std::string idParam, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameAttachmentsBatchDeleteHelper(accessToken,
	objectName, idParam, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameAttachmentsBatchDeleteSync(char * accessToken,
	std::string objectName, std::string idParam, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameAttachmentsBatchDeleteHelper(accessToken,
	objectName, idParam, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameAttachmentsBatchPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameAttachmentsBatchPostHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/attachments/batch");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameAttachmentsBatchPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameAttachmentsBatchPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameAttachmentsBatchPostAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameAttachmentsBatchPostHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameAttachmentsBatchPostSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameAttachmentsBatchPostHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameAttachmentsBatchPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameAttachmentsBatchPutHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/attachments/batch");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameAttachmentsBatchPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameAttachmentsBatchPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameAttachmentsBatchPutAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameAttachmentsBatchPutHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameAttachmentsBatchPutSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameAttachmentsBatchPutHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameDeleteHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameDeleteAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameDeleteHelper(accessToken,
	objectName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameDeleteSync(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameDeleteHelper(accessToken,
	objectName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameIdRolesRoleNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameIdRolesRoleNameGetHelper(char * accessToken,
	std::string objectName, std::string id, std::string roleName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{id}/roles/{role_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_id("{");
	s_id.append("id");
	s_id.append("}");
	pos = url.find(s_id);
	url.erase(pos, s_id.length());
	url.insert(pos, stringify(&id, "std::string"));
	string s_roleName("{");
	s_roleName.append("role_name");
	s_roleName.append("}");
	pos = url.find(s_roleName);
	url.erase(pos, s_roleName.length());
	url.insert(pos, stringify(&roleName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameIdRolesRoleNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameIdRolesRoleNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameIdRolesRoleNameGetAsync(char * accessToken,
	std::string objectName, std::string id, std::string roleName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameIdRolesRoleNameGetHelper(accessToken,
	objectName, id, roleName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameIdRolesRoleNameGetSync(char * accessToken,
	std::string objectName, std::string id, std::string roleName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameIdRolesRoleNameGetHelper(accessToken,
	objectName, id, roleName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdActionsActionNameGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdActionsActionNameGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string actionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/actions/{action_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_actionName("{");
	s_actionName.append("action_name");
	s_actionName.append("}");
	pos = url.find(s_actionName);
	url.erase(pos, s_actionName.length());
	url.insert(pos, stringify(&actionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdActionsActionNameGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdActionsActionNameGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsActionNameGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string actionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsActionNameGetHelper(accessToken,
	objectName, objectRecordId, actionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsActionNameGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string actionName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsActionNameGetHelper(accessToken,
	objectName, objectRecordId, actionName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdActionsActionNamePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdActionsActionNamePostHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string actionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/actions/{action_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_actionName("{");
	s_actionName.append("action_name");
	s_actionName.append("}");
	pos = url.find(s_actionName);
	url.erase(pos, s_actionName.length());
	url.insert(pos, stringify(&actionName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdActionsActionNamePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdActionsActionNamePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsActionNamePostAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string actionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsActionNamePostHelper(accessToken,
	objectName, objectRecordId, actionName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsActionNamePostSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string actionName, std::string authorization, std::string contentType, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsActionNamePostHelper(accessToken,
	objectName, objectRecordId, actionName, authorization, contentType, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdActionsCascadedeletePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdActionsCascadedeletePostHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/actions/cascadedelete");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdActionsCascadedeletePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdActionsCascadedeletePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsCascadedeletePostAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsCascadedeletePostHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsCascadedeletePostSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsCascadedeletePostHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdActionsDeepcopyPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdActionsDeepcopyPostHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/actions/deepcopy");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdActionsDeepcopyPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdActionsDeepcopyPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsDeepcopyPostAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsDeepcopyPostHelper(accessToken,
	objectName, objectRecordId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsDeepcopyPostSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsDeepcopyPostHelper(accessToken,
	objectName, objectRecordId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdActionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdActionsGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&loc, "bool");
	queryParams.insert(pair<string, string>("loc", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("loc");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/actions");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdActionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdActionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsGetHelper(accessToken,
	objectName, objectRecordId, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdActionsGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, bool loc, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdActionsGetHelper(accessToken,
	objectName, objectRecordId, loc, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentFieldName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentFieldName("{");
	s_attachmentFieldName.append("attachment_field_name");
	s_attachmentFieldName.append("}");
	pos = url.find(s_attachmentFieldName);
	url.erase(pos, s_attachmentFieldName.length());
	url.insert(pos, stringify(&attachmentFieldName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentFieldName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetHelper(accessToken,
	objectName, objectRecordId, attachmentFieldName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentFieldName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFileGetHelper(accessToken,
	objectName, objectRecordId, attachmentFieldName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentFieldName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachment_fields/{attachment_field_name}/file");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentFieldName("{");
	s_attachmentFieldName.append("attachment_field_name");
	s_attachmentFieldName.append("}");
	pos = url.find(s_attachmentFieldName);
	url.erase(pos, s_attachmentFieldName.length());
	url.insert(pos, stringify(&attachmentFieldName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentFieldName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostHelper(accessToken,
	objectName, objectRecordId, attachmentFieldName, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentFieldName, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentFieldsAttachmentFieldNameFilePostHelper(accessToken,
	objectName, objectRecordId, attachmentFieldName, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachment_fields/file");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentFieldsFileGetHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteHelper(accessToken,
	objectName, objectRecordId, attachmentId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdDeleteHelper(accessToken,
	objectName, objectRecordId, attachmentId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetHelper(accessToken,
	objectName, objectRecordId, attachmentId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdGetHelper(accessToken,
	objectName, objectRecordId, attachmentId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutHelper(accessToken,
	objectName, objectRecordId, attachmentId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdPutHelper(accessToken,
	objectName, objectRecordId, attachmentId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteHelper(accessToken,
	objectName, objectRecordId, attachmentId, attachmentVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionDeleteHelper(accessToken,
	objectName, objectRecordId, attachmentId, attachmentVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}/file");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetHelper(accessToken,
	objectName, objectRecordId, attachmentId, attachmentVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionFileGetHelper(accessToken,
	objectName, objectRecordId, attachmentId, attachmentVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetHelper(accessToken,
	objectName, objectRecordId, attachmentId, attachmentVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionGetHelper(accessToken,
	objectName, objectRecordId, attachmentId, attachmentVersion, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, bool restore, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&restore, "bool");
	queryParams.insert(pair<string, string>("restore", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("restore");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions/{attachment_version}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));
	string s_attachmentVersion("{");
	s_attachmentVersion.append("attachment_version");
	s_attachmentVersion.append("}");
	pos = url.find(s_attachmentVersion);
	url.erase(pos, s_attachmentVersion.length());
	url.insert(pos, stringify(&attachmentVersion, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, bool restore, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostHelper(accessToken,
	objectName, objectRecordId, attachmentId, attachmentVersion, restore, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string attachmentVersion, bool restore, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsAttachmentVersionPostHelper(accessToken,
	objectName, objectRecordId, attachmentId, attachmentVersion, restore, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments/{attachment_id}/versions");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));
	string s_attachmentId("{");
	s_attachmentId.append("attachment_id");
	s_attachmentId.append("}");
	pos = url.find(s_attachmentId);
	url.erase(pos, s_attachmentId.length());
	url.insert(pos, stringify(&attachmentId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetHelper(accessToken,
	objectName, objectRecordId, attachmentId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string attachmentId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsAttachmentIdVersionsGetHelper(accessToken,
	objectName, objectRecordId, attachmentId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsFileGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsFileGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments/file");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsFileGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsFileGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsFileGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsFileGetHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsFileGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsFileGetHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsGetHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsGetHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAttachmentsPostHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/attachments");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAttachmentsPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAttachmentsPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsPostAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsPostHelper(accessToken,
	objectName, objectRecordId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAttachmentsPostSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAttachmentsPostHelper(accessToken,
	objectName, objectRecordId, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdAudittrailGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdAudittrailGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string startDate, std::string endDate, std::string formatResult, std::string limit, std::string offset, std::string events, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&startDate, "std::string");
	queryParams.insert(pair<string, string>("start_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("start_date");
	}


	itemAtq = stringify(&endDate, "std::string");
	queryParams.insert(pair<string, string>("end_date", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("end_date");
	}


	itemAtq = stringify(&formatResult, "std::string");
	queryParams.insert(pair<string, string>("format_result", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("format_result");
	}


	itemAtq = stringify(&limit, "std::string");
	queryParams.insert(pair<string, string>("limit", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("limit");
	}


	itemAtq = stringify(&offset, "std::string");
	queryParams.insert(pair<string, string>("offset", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("offset");
	}


	itemAtq = stringify(&events, "std::string");
	queryParams.insert(pair<string, string>("events", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("events");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}/audittrail");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdAudittrailGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdAudittrailGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdAudittrailGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string startDate, std::string endDate, std::string formatResult, std::string limit, std::string offset, std::string events, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAudittrailGetHelper(accessToken,
	objectName, objectRecordId, startDate, endDate, formatResult, limit, offset, events, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdAudittrailGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string startDate, std::string endDate, std::string formatResult, std::string limit, std::string offset, std::string events, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdAudittrailGetHelper(accessToken,
	objectName, objectRecordId, startDate, endDate, formatResult, limit, offset, events, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameObjectRecordIdGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameObjectRecordIdGetHelper(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/{object_record_id}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));
	string s_objectRecordId("{");
	s_objectRecordId.append("object_record_id");
	s_objectRecordId.append("}");
	pos = url.find(s_objectRecordId);
	url.erase(pos, s_objectRecordId.length());
	url.insert(pos, stringify(&objectRecordId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameObjectRecordIdGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameObjectRecordIdGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameObjectRecordIdGetAsync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdGetHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameObjectRecordIdGetSync(char * accessToken,
	std::string objectName, std::string objectRecordId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameObjectRecordIdGetHelper(accessToken,
	objectName, objectRecordId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNamePostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNamePostHelper(char * accessToken,
	std::string objectName, std::string idParam, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, bool xVaultAPINoTriggers, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-NoTriggers: ");
		headerString.append(stringify(&xVaultAPINoTriggers, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	

	itemAtq = stringify(&idParam, "std::string");
	queryParams.insert(pair<string, string>("idParam", itemAtq));
	if( itemAtq.empty()==true){
		queryParams.erase("idParam");
	}

	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNamePostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNamePostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNamePostAsync(char * accessToken,
	std::string objectName, std::string idParam, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, bool xVaultAPINoTriggers, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNamePostHelper(accessToken,
	objectName, idParam, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPINoTriggers, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNamePostSync(char * accessToken,
	std::string objectName, std::string idParam, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, bool xVaultAPINoTriggers, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNamePostHelper(accessToken,
	objectName, idParam, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPINoTriggers, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNamePutProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNamePutHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, bool xVaultAPINoTriggers, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-MigrationMode: ");
		headerString.append(stringify(&xVaultAPIMigrationMode, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-NoTriggers: ");
		headerString.append(stringify(&xVaultAPINoTriggers, "bool"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("PUT");

	if(strcmp("PUT", "PUT") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNamePutProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNamePutProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNamePutAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, bool xVaultAPINoTriggers, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNamePutHelper(accessToken,
	objectName, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPINoTriggers, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNamePutSync(char * accessToken,
	std::string objectName, std::string authorization, std::string contentType, std::string accept, bool xVaultAPIMigrationMode, bool xVaultAPINoTriggers, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNamePutHelper(accessToken,
	objectName, authorization, contentType, accept, xVaultAPIMigrationMode, xVaultAPINoTriggers, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameRolesDeleteProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameRolesDeleteHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/roles");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("DELETE");

	if(strcmp("PUT", "DELETE") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameRolesDeleteProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameRolesDeleteProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameRolesDeleteAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameRolesDeleteHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameRolesDeleteSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameRolesDeleteHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsObjectNameRolesPostProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsObjectNameRolesPostHelper(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Content-Type: ");
		headerString.append(stringify(&contentType, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/{object_name}/roles");
	int pos;

	string s_objectName("{");
	s_objectName.append("object_name");
	s_objectName.append("}");
	pos = url.find(s_objectName);
	url.erase(pos, s_objectName.length());
	url.insert(pos, stringify(&objectName, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("POST");

	if(strcmp("PUT", "POST") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsObjectNameRolesPostProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsObjectNameRolesPostProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsObjectNameRolesPostAsync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameRolesPostHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsObjectNameRolesPostSync(char * accessToken,
	std::string objectName, std::string authorization, std::string accept, std::string contentType, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsObjectNameRolesPostHelper(accessToken,
	objectName, authorization, accept, contentType, xVaultAPIClientID, 
	handler, userData, false);
}

static bool vobjectsOutboundPackageVPackageIdDependenciesGetProcessor(MemoryStruct_s p_chunk, long code, char* errormsg, void* userData,
	void(* voidHandler)())
{
	
	void(* handler)(Error, void* ) = reinterpret_cast<void(*)(Error, void* )> (voidHandler);
	JsonNode* pJson;
	char * data = p_chunk.memory;

	

	if (code >= 200 && code < 300) {
		Error error(code, string("No Error"));


		handler(error, userData);
		return true;



	} else {
		Error error;
		if (errormsg != NULL) {
			error = Error(code, string(errormsg));
		} else if (p_chunk.memory != NULL) {
			error = Error(code, string(p_chunk.memory));
		} else {
			error = Error(code, string("Unknown Error"));
		}
		handler(error, userData);
		return false;
	}
}

static bool vobjectsOutboundPackageVPackageIdDependenciesGetHelper(char * accessToken,
	std::string packageId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData, bool isAsync)
{

	//TODO: maybe delete headerList after its used to free up space?
	struct curl_slist *headerList = NULL;

	
	{
		string headerString("Authorization: ");
		headerString.append(stringify(&authorization, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("Accept: ");
		headerString.append(stringify(&accept, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	{
		string headerString("X-VaultAPI-ClientID: ");
		headerString.append(stringify(&xVaultAPIClientID, "std::string"));
		headerList = curl_slist_append(headerList, headerString.c_str());
	}

	string accessHeader = "Authorization: Bearer ";
	accessHeader.append(accessToken);
	headerList = curl_slist_append(headerList, accessHeader.c_str());
	headerList = curl_slist_append(headerList, "Content-Type: application/json");

	map <string, string> queryParams;
	string itemAtq;
	
	string mBody = "";
	JsonNode* node;
	JsonArray* json_array;

	string url("/vobjects/outbound_package__v/{package_id}/dependencies");
	int pos;

	string s_packageId("{");
	s_packageId.append("package_id");
	s_packageId.append("}");
	pos = url.find(s_packageId);
	url.erase(pos, s_packageId.length());
	url.insert(pos, stringify(&packageId, "std::string"));

	//TODO: free memory of errormsg, memorystruct
	MemoryStruct_s* p_chunk = new MemoryStruct_s();
	long code;
	char* errormsg = NULL;
	string myhttpmethod("GET");

	if(strcmp("PUT", "GET") == 0){
		if(strcmp("", mBody.c_str()) == 0){
			mBody.append("{}");
		}
	}

	if(!isAsync){
		NetClient::easycurl(DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg);
		bool retval = vobjectsOutboundPackageVPackageIdDependenciesGetProcessor(*p_chunk, code, errormsg, userData,reinterpret_cast<void(*)()>(handler));

		curl_slist_free_all(headerList);
		if (p_chunk) {
			if(p_chunk->memory) {
				free(p_chunk->memory);
			}
			delete (p_chunk);
		}
		if (errormsg) {
			free(errormsg);
		}
		return retval;
	} else{
		GThread *thread = NULL;
		RequestInfo *requestInfo = NULL;

		requestInfo = new(nothrow) RequestInfo (DefaultManager::getBasePath(), url, myhttpmethod, queryParams,
			mBody, headerList, p_chunk, &code, errormsg, userData, reinterpret_cast<void(*)()>(handler), vobjectsOutboundPackageVPackageIdDependenciesGetProcessor);;
		if(requestInfo == NULL)
			return false;

		thread = g_thread_new(NULL, __DefaultManagerthreadFunc, static_cast<gpointer>(requestInfo));
		return true;
	}
}




bool DefaultManager::vobjectsOutboundPackageVPackageIdDependenciesGetAsync(char * accessToken,
	std::string packageId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsOutboundPackageVPackageIdDependenciesGetHelper(accessToken,
	packageId, authorization, accept, xVaultAPIClientID, 
	handler, userData, true);
}

bool DefaultManager::vobjectsOutboundPackageVPackageIdDependenciesGetSync(char * accessToken,
	std::string packageId, std::string authorization, std::string accept, std::string xVaultAPIClientID, 
	
	void(* handler)(Error, void* ) , void* userData)
{
	return vobjectsOutboundPackageVPackageIdDependenciesGetHelper(accessToken,
	packageId, authorization, accept, xVaultAPIClientID, 
	handler, userData, false);
}

